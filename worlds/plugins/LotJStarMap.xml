<?xml version="1.0" encoding="iso-8859-1" ?> 
<!DOCTYPE muclient> 
<!--  Saved on Thursday, July 05, 2012, 1:04 AM   --> 
<!-- MuClient version 4.73 --> 
<muclient>
<plugin name="LotJStarMap" author="@Johnson+@Domovoi" id="dd5080a41939faabc233da8f" language="Lua" purpose="Dynamically display a system map with player location overlay" save_state="y" requires="4.73" version="2.3">
<description trim="y">
<![CDATA[
This plugin will gather information about the current galaxy's star systems 
using a datapad in order to display an up-to-date version of what the galaxy 
looks like. The map's scale is not preset, but gets cropped to the outermost 
star systems in order to reduce empty space.
This plugin relies on LotJMSDPHandler and LotJCalc to retrieve information 
about the player's current location and current destination in order to overlay
the ship position and hyperspace route.
This plugin also relies on an in-game datapad for galaxy information retrieval.
Basic usage:
Type "hypmap" to use a datapad to scan for starsystems and plot on map.
Type "showmap" to open map window without scanning, loading your saved planetary information.
Type "hidemap" to close map window, or click the X in the upper right to close.
Hover mouse over planets to see distances to other planets.
Click on a planet name to calculate a jump using LotJCalc.
Right click anywhere on the background to open an options menu where you can 
add/remove systems, customize system colors to your liking, rename the window, 
change the display font and restore the window to defaults.

Distance calculation corrected by @Domovoi

  ]]> 
  </description>
  </plugin>
<!--   Get our standard constants   --> 
  <include name="constants.lua" /> 
<!--   Triggers    --> 
<triggers>
	<trigger name="systemCapture" script="storeSystem" match="^(.*)\( (.*)\, (.*) \)$" regexp="y" group="StarCap" enabled="n" omit_from_log="y" omit_from_output="y" sequence="100" />
    <trigger name="systemCapTitle1" match="Listing publicly known starsystems:" group="StarCap" enabled="n" omit_from_log="y" omit_from_output="y" sequence="100" />
	<trigger name="starsFailed" script="toggleOff" match="^You must hold a datapad to do this\.$" regexp="y" enabled="n" group="StarCap" sequence="100" />
	<trigger name="systemCapDone" script="findClans" match="^$" regexp="y" group="StarCap" omit_from_log="y" enabled="n" omit_from_output="y" sequence="100" />
    <trigger name="planetCapTitle1" match="Major Organizations*Planets*Active Members" group="ClanCap" enabled="n" omit_from_log="y" omit_from_output="y" sequence="100" />
    <trigger name="planetCapTitle2" match="Minor Organizations*Members"  group="ClanCap" omit_from_log="y" enabled="n" omit_from_output="y" sequence="100" />
    <trigger name="clanCapture" script="storeClan" match="^(.*[a-zA-Z])(\s+((\d(.*)\+)|\d+\s+\(None\))(.*))$" group="ClanCap" enabled="n" regexp="y" omit_from_log="y" omit_from_output="y" sequence="100" />
    <trigger name="clanCapDone" script="findPlanets" match="^Use SHOWCLAN for more information\.$" regexp="y" enabled="n" group="ClanCap" omit_from_log="y" omit_from_output="y" sequence="100" />
    <trigger name="planetCapTitle" match="Planet*Starsystem*Governed By*Opinion*Military" group="PlanetCap" enabled="n" omit_from_log="y" omit_from_output="y" sequence="100" />
	<trigger name="planetCapture" script="storePlanet" match="^((\S(\s)?)+)\s+((\S(\s)?)+)\s+((\S(\s)?)+)(.*[^\.])$" regexp="y" enabled="n" group="PlanetCap" omit_from_log="y" omit_from_output="y" sequence="100" />
	<trigger name="planetCapDone" script="setupWindow" match="^Use SHOWPLANET \<planet\> for more information\.$" regexp="y" enabled="n" group="PlanetCap" omit_from_log="y" omit_from_output="y" sequence="100" />
	<!-- Lightspeed triggers -->
	<trigger name="partialJump" match="^Remaining jump distance\: (.*)$" script="storePartialJump" group="LotJStarMap" enabled="y" regexp="y" sequence="100" />
	<trigger name="completedjump" match="^Hyperjump complete\.$" script="clearJump" group="LotJStarMap" enabled="y" regexp="y" sequence="100" />
	<trigger name="calculatingjump" match="^Checking hyperspace course integrity\. Please wait\.$" script="jumpChecking" group="LotJStarMap" enabled="y" regexp="y" sequence="100" />
  <trigger name="lowfueljump" match="^Warning \- Not enough fuel to complete the jump to hyperspace\!$" script="jumpError" group="LotJStarMap" enabled="y" regexp="y" sequence="100" />
  <trigger name="calculatedjump" match="^\[Status\]\: Hyperspace Calculations have been completed\.$" script="jumpChecked" group="LotJStarMap" enabled="y" regexp="y" sequence="100" />
	<trigger name="abortedjump" match="^Hyperjump aborting\! Shutting down the Hyperdrive\.$" script="jumpAborted" group="LotJStarMap" enabled="y" regexp="y" sequence="100" />
  <trigger name="enterhyper" match="^The stars become streaks of light as you enter hyperspace\.$" script="enterHyper" group="LotJStarMap" enabled="y" regexp="y" sequence="100" />
  </triggers>
<!--   Aliases    --> 
<aliases>
  <alias name="initCommand" script="findStars" match="hypmap" enabled="y" regexp="n" group="LotJStarMap" ignore_case="y" sequence="100" />
  <alias name="createWindow" script="resetBounds" match="showmap" enabled="y" regexp="n" group="LotJStarMap" ignore_case="y" sequence="100" />
  <alias name="removeWindow" script="destroyWindow" match="hidemap" enabled="y" regexp="n" group="LotJStarMap" ignore_case="y" sequence="100" />
  </aliases>
<timers>
	<timer name="hyperJumpTicker" script="hyperJumpTick" enabled="n" second="2" group="LotJStarMap" />
</timers>
<!--   Script    --> 
<script>
<![CDATA[ 
require "movewindow"
require "serialize"
dofile(GetPluginInfo(GetPluginID(), 20) .. "LotJMSDPHelper.lua")
local win = "galaxy_map_" .. GetPluginID()  -- unique window name
systems = {}
clans = {}
local clan = {}
local system = {}
loadstring(GetVariable("systems") or "") ()
local font = "f"
local maxX = 0
local minX = 0
local maxY = 0
local minY = 0
local smaxX = 0
local smaxY = 0
local sminX = 0
local sminY = 0
local failsafe = 0
local visible = false
WINDOW_NAME = GetVariable("WINDOW_NAME") or "Galaxy Map"
default_font_name = "Courier New"
default_font_size = 10
font_name = GetVariable("font_name") or default_font_name
font_size = tonumber(GetVariable("font_size")) or default_font_size
-- hyperjump stuff
local totalJump = 0
local partialJump = 0
local startx = nil
local starty = nil
local realx = nil
local realy = nil
local currentX = nil
local currentY = nil
local currentPlanet = ""
local currentSystem = ""
local endX = nil
local endY = nil
local startrealx = nil
local startrealy = nil
local routeType = ""
local shipsize = 8
local inHyper = false
local coordchanged = false
-- Variables not saved.
local startposx   = ""  
local startposy   = ""
local posx        = "" 
local posy        = ""
local RESIZE_TAG_SIZE = 10
local MIN_WIDTH   = 50
local MIN_HEIGHT  = 50
local redraw_scheduled = false
local width       = tonumber(GetVariable("width")) or 800
local height      = tonumber(GetVariable("height")) or 600
clancolors = {"darkslategray", "lightcoral", "yellow", "dodgerblue", "darkviolet", "darkorange"}
function storePlanet(name, list, args)
    --Note("Debug: storePlanet called")
	--Note("0: '" .. args[0] .. "' 1: '"..args[1].."' 2: '"..args[2].."' 3:' "..args[3].."' 4: '"..args[4].."' 5: '"..args[5].."' 6: '"..args[6].."' 7: '"..args[7].."'")
    --Args 0: Whole match. Args 1: Planet, Args 4: System, Args 7: Clan
	for i, v in ipairs(systems) do
		local sysName = v.name
		if (string.find(args[0], sysName)) then -- if the system name was found in the grab text
			systems[i].planet = Trim(args[1]) -- set the planetname
            systems[i].clan = Trim(args[7])
			--Note("System: '" .. systems[i].name .. "' Planet: '" .. systems[i].planet .. "' Clan: '"..systems[i].clan.."'")
		end
	end
end

function storeClan(name, line, args)
    clan.name = tostring(args[1])
	clans[#clans + 1] = clan
    clan = {}
    --Note("Debug: storeClan called")
end

function findStars(name, list, args)
    systems = {}
	SendNoEcho("stars")
	toggleOn()
    --Note("Debug: findStars executed")
end
function findPlanets(name, list, args)
    toggleClansOff()
	SendNoEcho("planets")
	togglePlanetsOn()
    --Note("Debug: findPlanets executed")
end
function findClans(name, list, args)
    toggleOff()
    clans = {}
	SendNoEcho("clans")
	toggleClansOn()
    --Note("Debug: findClans executed")
end
function togglePlanetsOn(name, list, args)
	EnableTriggerGroup("PlanetCap", true)
end
function toggleOn(name, list, args)
	EnableTriggerGroup("StarCap", true)
	--WindowCreate (win, 0, 0, 800, 600, miniwin.pos_center_all, 0, ColourNameToRGB("black"))  -- create window
	--WindowFont (win, font, "Arial", 10, true, false, false, false) -- define font
end
function toggleClansOn(name, list, args)
    EnableTriggerGroup("ClanCap", true)
end
function storeSystem(name, list, args)
    --Note("Debug: storeSystem called")
	if (args[1] and args[2] and args[3]) then
		system.name = Trim(args[1])
		system.x = tonumber(args[2])
		system.y = tonumber(args[3])
		systems[#systems + 1] = system
    system = {}
	end
end
function toggleOff(name, list, args)
	EnableTriggerGroup("StarCap", false)
end
function togglePlanetsOff(name, list, args)
	EnableTriggerGroup("PlanetCap", false)
end
function toggleClansOff(name, list, args)
    EnableTriggerGroup("ClanCap", false)
end
function resetBounds()
	visible = false
	maxX = nil
	maxY = nil
	minX = nil
	minY = nil
	setupWindow()
end

 function setClanColors()
     for i in ipairs(clans) do
      if ( nil ~= clancolors[i] ) then
         clans[i].color = ColourNameToRGB(clancolors[i])
      end
     end
 end

function setupWindow(name, line, args)
    --Note("Debug: Reached setupWindow")
  if #systems == 0 then -- failsafe in case we try to display window without any planet information
    findStars()
    return
  end
	togglePlanetsOff()
    setClanColors()
	
	-- initialize our mins and maxes
	maxX = systems[1].x
	minX = systems[1].x
	maxY = systems[1].y
	minY = systems[1].y
	-- find our real max and min values so we can scale accordingly
	for i, v in pairs(systems) do
		local sys = v
		if (sys.x > maxX) then
			maxX = sys.x
		end
		if (sys.x < minX) then
		  minX = sys.x
		end
		if (sys.y > maxY) then
			maxY = sys.y
		end
		if (sys.y < minY) then
		  minY = sys.y
		end
	end	
		
	setupConflicts()
	
	visible = true
  scheduleRedraw()
end
function setupConflicts()
  -- setup our text boundaries since we just now figured out our max and min values for scaling
  for i, v in ipairs(systems) do
  	v.left = scaleXCoord(v.x) - WindowTextWidth(win, font, ((v.planet and v.planet) or v.name))/2 + 5
		v.top = scaleYCoord(v.y) + 5
		v.right = v.left + WindowTextWidth(win, font, ((v.planet and v.planet) or v.name)) -- font width
		v.bottom = v.top + WindowFontInfo(win, font, 1) -- font height
  end
  -- find our scaled max and mins
  smaxX = scaleXCoord(maxX)
  smaxY = scaleYCoord(maxY)
  sminX = scaleXCoord(minX)
  sminY = scaleYCoord(minY)
  
  -- recursively resolve conflicts with other systems
  failsafe = 0
  resolveConflicts()
end
function resolveConflicts()
  if failsafe <= 20 then -- we don't want to get stuck in an infinite recursion loop
  -- resolve window boundary conflicts
  for i, v in ipairs(systems) do
    if v.right > smaxX then
      v.left = smaxX - WindowTextWidth(win, font, ((v.planet and v.planet) or v.name))
      v.right = smaxX
    end
    if v.left < sminX then
      v.left = sminX
      v.right = v.left + WindowTextWidth(win, font, ((v.planet and v.planet) or v.name))
    end
    if v.bottom > sminY then
      v.top = sminY - WindowFontInfo(win, font, 1) - 5
      v.bottom = sminY - 5
    end
  end
  -- resolve system conflicts
  for i, v in ipairs(systems) do
    for j, k in ipairs(systems) do
      if (i ~= j) then -- don't check a system against itself
        if conflicts(v, k) then -- uh oh we have a collision!
          failsafe = failsafe + 1
          resolveConflicts()
        end
      end
    end
  end
  end
end
-- this needs to be done better TODO
-- at the moment this works, but I am envisioning a system of 
-- calculating many different label positions, finding the
-- distance of the label from the marker, then choosing the label positions 
-- that maintain the best position for all systems in the vicinity
-- maybe it's overkill but if it's worth doing, it's worth overdoing.
function conflicts(sys1, sys2)
  if topleftconflicts(sys1, sys2) then
    --Note("Top Left Collision detected! ("..sys1.name..","..sys2.name..")")
    -- top left collided, try shifting down (add pixels)
    sys1.top = sys2.bottom + 1
    sys1.bottom = sys1.top + WindowFontInfo(win, font, 1)
    --sys1, sys2 = findbestsolution(sys1, sys2)
    return true
  elseif bottomleftconflicts(sys1, sys2) then
    --Note("Bottom Left Collision detected! ("..sys1.name..","..sys2.name..")")
    -- bottom left collided, try shifting the other guy down (add pixels)
    sys2.top = sys1.bottom + 1
    sys2.bottom = sys2.top + WindowFontInfo(win, font, 1)
    --sys1, sys2 = findbestsolution(sys1, sys2)
    return true
  elseif toprightconflicts(sys1, sys2) then
    --Note("Top Right Collision detected! ("..sys1.name..","..sys2.name..")")
    -- try shifting down first (add pixels)
    sys1.top = sys2.bottom + 1
    sys1.bottom = sys1.top + WindowFontInfo(win, font, 1)
    --sys1, sys2 = findbestsolution(sys1, sys2)
    return true
  elseif bottomrightconflicts(sys1, sys2) then
    --Note("Bottom Right Collision detected! ("..sys1.name..","..sys2.name..")")
    -- bottom right collided, try shifting the other guy down (add pixels)
    sys2.top = sys1.bottom + 1
    sys2.bottom = sys2.top + WindowFontInfo(win, font, 1)
    --sys1, sys2 = findbestsolution(sys1, sys2)
    return true
  else
    return false
  end
end
function topleftconflicts(s1, s2)
  return ((s1.left >= s2.left and s1.left <= s2.right) and (s1.top <= s2.bottom and s1.top >= s2.top))
end
function bottomleftconflicts(s1, s2)
  return ((s1.left >= s2.left and s1.left <= s2.right) and (s1.bottom <= s2.bottom and s1.bottom >= s2.top))
end
function toprightconflicts(s1, s2)
  return ((s1.right >= s2.left and s1.right <= s2.right) and (s1.top <= s2.bottom and s1.top >= s2.top))
end
function bottomrightconflicts(s1, s2)
  return ((s1.right >= s2.left and s1.right <= s2.right) and (s1.bottom <= s2.bottom and s1.bottom >= s2.top))
end
local offsetgrid = { {-1, -1}, {-1, 0}, {-1, 1},
                     {0 , -1}, {0 , 0}, {0 , 1},
                     {1 , -1}, {1 , 0}, {1 , 1} }
function findbestsolution(sys1, sys2)
  local best = 10000 -- arbitrarily large number so we should always find something smaller
  local startsys1 = sys1
  local startsys2 = sys2
  local testsys1 = sys1
  local testsys2 = sys2
  local bestsys1 = sys1
  local bestsys2 = sys2
  for i=10, 200, 10 do
    for a, b in ipairs(offsetgrid) do
      testsys1.left = startsys1.left + b[1]*i
      testsys1.right = startsys1.right + b[1]*i
      testsys1.top = startsys1.top + b[2]*i
      testsys1.bottom = startsys1.bottom + b[2]*i
      for j, k in ipairs(offsetgrid) do
        testsys2.left = startsys2.left + k[1]*i
        testsys2.right = startsys2.right + k[1]*i
        testsys2.top = startsys2.top + k[2]*i
        testsys2.bottom = startsys2.bottom + k[2]*i
        if a~=j then -- don't test the same thing twice
          local test = systemnamedistance(testsys1, testsys2)
          if test < best then
            best = test
            bestsys1 = testsys1
            bestsys2 = testsys2
            Note("better solution found: 1="..bestsys1.name..":"..bestsys1.left..","..bestsys1.top.." 2="..bestsys2.name..":"..bestsys2.left..","..bestsys2.top.." dist: "..best)
          end
        end
      end
    end
  end
  Note("best solution found: 1="..bestsys1.name..":"..bestsys1.left..","..bestsys1.top.." 2="..bestsys2.name..":"..bestsys2.left..","..bestsys2.top.." dist: "..best)
  return bestsys1, bestsys2
end
function systemnamedistance(sys1, sys2)
  return sysdistance(sys1) + sysdistance(sys2)
end
   
function sysdistance(sys)
  local bx = (sys.left + ((sys.right-sys.left)/2))
  local by = (sys.top + ((sys.bottom-sys.top)/2))
  --return math.sqrt(((sys.x-bx)*(sys.x-bx))+((sys.y-by)*(sys.y-by)))
  local dx = math.abs(sys.x-bx)
  local dy = math.abs(sys.y-by)
  local dist = dx + dy
  return dist
end
  
function drawWindow(name, line, args)
	WindowRectOp (win, miniwin.rect_fill, 0, 0, width, height, ColourNameToRGB("black"))  -- draw blank rectangle to "erase" window contents
	
	 -- draw border
  WindowRectOp (win, 5, 0, 0, 0, 0, 5, 15 + 0x1000)
	
	WindowAddHotspot(win, "background", 0, WindowFontInfo(win, font, 1)+6, width-15, height-15, "", "", "MouseDown", "CancelMouseDown", "MouseUp", "", 0, 0)
	
	--drag handler
  movewindow.add_drag_handler (win, 0, 0, width-15, WindowFontInfo (win, font, 1)+5)

	
	for i=1,#systems,1 do
		local sys = systems[i]
        for i,v in ipairs(clans) do
            if sys.clan == clans[i].name then
                sys.colour = clans[i].color
            end
        end
		local x = scaleXCoord(sys.x)  -- scale X coordinate
		local y = scaleYCoord(sys.y) -- scale Y coordinate
		
		WindowText (win, font, ((sys.planet and sys.planet) or sys.name),   -- text
                sys.left, sys.top, sys.right, sys.bottom,        -- rectangle
                ColourNameToRGB ("white"), -- colour
                false)              -- not Unicode
                
    	WindowCircleOp (win, miniwin.circle_ellipse, -- circle
                x-5, y-5, x+5, y+5,                -- Left, Top, Right, Bottom
                sys.colour or ColourNameToRGB("lawngreen"), miniwin.pen_solid, 1, -- pen width 1
                sys.colour or ColourNameToRGB("lawngreen"), miniwin.brush_solid)  -- brush
        
        WindowAddHotspot(win, i,  
                -- x, y, WindowTextWidth (win, font, tostring(sys.name)), WindowFontInfo (win, font, 1),   -- rectangle, left, top, right, bottom
                 sys.left, sys.top, sys.right, sys.bottom,
                 "drawPaths", -- mousehover
                 "hidePaths",        -- mousecancelhover
                 "LeftClickOnly",         -- mousedown
                 "CancelMouseDown",   -- mousecanceldown
                 "",           -- mouseup
                 sys.name.. " (" .. sys.x .. "," .. sys.y .. ")",  -- tooltip text
                 1, 0)
    end
  
  	-- add the drag handler so they can move the window around
  	--local font_height = WindowFontInfo (win, font, 1)
  	--movewindow.add_drag_handler (win, 0, 0, 0, font_height)
  	
  	-- draw X in the corner to close the window
  	WindowLine (win, width-15, 5, width-5, 15, ColourNameToRGB ("white"), miniwin.pen_solid, 1)
  	WindowLine (win, width-15, 15, width-5, 5, ColourNameToRGB ("white"), miniwin.pen_solid, 1)
  	WindowAddHotspot(win, "windowX",
  			width-15, 5, width-5, 15,
  			"",                   --mousehover
  			"",                   --mouseoffhover
  			"destroyWindow",      --mousedown
  			"CancelMouseDown",                   --mouseoffdown
  			"LeftClickOnly",                   --mouseup
  			"Close hypmap window",
  			1, 0)
  
  	-- heading line
 	WindowText (win, font, WINDOW_NAME, 5, 5, 0, 0, ColourNameToRGB  "white")
 	
  -- draw hyper path and ship so they are always on top
	drawHyperpath()
	
  drawResizer(win, width, height)
 	
  WindowShow (win,  true)  -- show it
  BroadcastPlugin(999, "repaint")
end
function drawHyperpath()
	if haveCoords() then -- if we are in a location that can be drawn on the map
	  drawCoords()
	  if haveDestination() then -- if we have a destination that can be drawn on the map
	    drawRoute()
	  end
	end
end
function haveCoords()
  currentX = tonumber(getmsdp("SHIPGALX"))
  currentY = tonumber(getmsdp("SHIPGALY"))
  currentSystem = getmsdp("SHIPSYSNAME")
  -- currentPlanet = getmsdp("PLANET") -- this is only updated if you use 'showplanet', leads to planet ghosting so leaving it out for now
  
	-- this is a little wonky because MSDP reports SHIPGALX and SHIPGALY default values as being 0
	-- which could also be the center of the galaxy.
	
  if ((startx ~= nil and starty ~= nil) and inHyper) then -- if we have a starting spot on the map (we should be in hyper)
    --Note("passed havecoords 1")
    return true
  end
  if (currentX ~= 0 or currentY ~= 0 or currentSystem ~= "") and (currentX ~= nil and currentY ~= nil) then -- if we are in regular space
    --Note("passed havecoords 2")
    return true
  end 
  if currentPlanet ~= "" then -- we are on a planet
    return true
  end
  return false -- we arent anywhere! abort!!
end
function drawCoords()
  if currentX ~= 0 or currentY ~= 0 then -- our coords are in the x,y form
    --Note("passed drawcoords 1")
    realx = scaleXCoord(currentX)
    realy = scaleYCoord(currentY)
    startrealx = currentX
    startrealy = currentY
    --Note("Assigning new real values in x,y coords")
    --Tell("realx: "..string.format("%.0f",realx).." realy: "..string.format("%.0f",realy))
    --Tell(" startx: "..string.format("%.0f",startx or 0).." starty: "..string.format("%.0f",starty or 0))
    --Tell(" endX: "..string.format("%.0f",endX or 0).." endY: "..string.format("%.0f\n",endY or 0))
  else  -- not x,y coords
    for k, v in pairs(systems) do
      if currentSystem ~= "" and (v.name and string.lower(v.name) == string.lower(currentSystem)) then -- scroll planet list and see if our current system matches one of the system names
        --Note("passed drawcoords 2")
        realx = scaleXCoord(v.x)
        realy = scaleYCoord(v.y)
        startrealx = v.x
        startrealy = v.y
        --Note("Assigning new real values in system coords")
        --Tell("realx: "..string.format("%.0f",realx).." realy: "..string.format("%.0f",realy))
        --Tell(" startx: "..string.format("%.0f",startx or 0).." starty: "..string.format("%.0f",starty or 0))
        --Tell(" endX: "..string.format("%.0f",endX or 0).." endY: "..string.format("%.0f\n",endY or 0))
      elseif currentPlanet ~= "" and (v.planet and string.lower(v.planet) == string.lower(currentPlanet)) then -- scroll planet list and see if our current planet matches one of the planet names
        --Note("passed drawcoords 3")
        realx = scaleXCoord(v.x)
        realy = scaleYCoord(v.y)
        startrealx = v.x
        startrealy = v.y
        --Note("Assigning new real values in planet coords")
        --Tell("realx: "..string.format("%.0f",realx).." realy: "..string.format("%.0f",realy))
        --Tell(" startx: "..string.format("%.0f",startx or 0).." starty: "..string.format("%.0f",starty or 0))
        --Tell(" endX: "..string.format("%.0f",endX or 0).." endY: "..string.format("%.0f\n",endY or 0))
      end
    end
  end
  if not inHyper then
    WindowCircleOp(win, 1, realx-(shipsize/2), realy-(shipsize/2), realx+(shipsize/2), realy+(shipsize/2), ColourNameToRGB("red"), 0, 0, ColourNameToRGB("red"), 0)
  end
end
function haveDestination()
  local storedsystem = GetPluginVariable("b2c06b3dcc775c0ede861316", "planetname") or ""
  local storedX = nil
  local storedY = nil
  
  --Note("storedsystem: "..storedsystem)
  
  if storedsystem == "" then -- we didn't get anything from lotjcalc
    startx = nil
    starty = nil
    startrealx = nil
    startrealy = nil
    --coordchanged = false
    --Note("failed havedest 1")
    return false
  end
  if string.find(storedsystem, "%([%d-]+%,[%d-]+%)") then -- we got an uncharted coordinate from lotjcalc
    local ax, bx = string.find(storedsystem, "%([%d-]+%,", 0, false)
    storedX = tonumber(string.sub(storedsystem, ax+1, bx-1))
    local ay, by = string.find(storedsystem, "%,[%d-]+%)", bx, false)
    storedY = tonumber(string.sub(storedsystem, ay+1, by-1))
    endX = scaleXCoord(storedX)
    endY = scaleYCoord(storedY)
    --Note("passed havedest 2")
    --Note("storedX = "..string.format("%.0f",storedX).." storedY = "..string.format("%.0f",storedY))
    --Note("x,y = "..string.format("%.0f",endX).. ","..string.format("%.0f",endY))
    return true
  
  end
  -- if we make it this far, it means we got a planet or system name from lotjcalc, scroll through and find out who it belongs to
  for k, v in pairs(systems) do -- check to see if lotjcalc's system belongs to one of the known systems or planets
    if (v.name and string.lower(v.name) == string.lower(storedsystem)) or (v.planet and string.lower(v.planet) == string.lower(storedsystem)) then
      endX = scaleXCoord(v.x)
      endY = scaleYCoord(v.y)
      --Note("passed havedest 3")
      --Note("planet x,y = "..string.format("%.0f",endX)..","..string.format("%.0f",endY))
      return true
    end
  end
  --Note("failed havedest 4")
  return false
end
function drawRoute()
	local percent = 0
	local pixels = 0
  local routeColor = "gray"
	
	if (totalJump > 0 and partialJump > 0) then
		percent = (totalJump - partialJump) / totalJump
	end
  
  -- find our starting position to draw a line from
  if ((startx == nil) and (starty == nil)) then
    startx = startrealx
    starty = startrealy
  end
  -- check our route status to draw appropriate color
  if (routeType == "checking" or routeType == "aborted") then
    routeColor = "gray"
  elseif (routeType == "error") then
    routeColor = "darkred"
  elseif (routeType == "checked") then
    routeColor = "white"
  elseif (routeType == "completed") then
    routeColor = "lime"
  end
  
  -- draw our route and place on that route
  WindowLine(win, scaleXCoord(startx), scaleYCoord(starty), endX, endY, ColourNameToRGB(routeColor), miniwin.pen_solid, 2)
  if inHyper then
    if partialJump < 0 then
      WindowCircleOp(win, 1, endX-(shipsize/2), endY-(shipsize/2), endX+(shipsize/2), endY+(shipsize/2), ColourNameToRGB("red"), 0, 0, ColourNameToRGB("red"), 0)
    else
      --WindowCircleOp(win, 1, (((1-percent)*startx)+(percent*endX))-(shipsize/2), (((1-percent)*starty)+(percent*endY))-(shipsize/2), (((1-percent)*startx)+(percent*endX))+(shipsize/2), (((1-percent)*starty)+(percent*endY))+(shipsize/2), ColourNameToRGB("red"), 0, 0, ColourNameToRGB("red"), 0)
      WindowCircleOp(win, 1, (((1-percent)*scaleXCoord(startx))+(percent*endX))-(shipsize/2), (((1-percent)*scaleYCoord(starty))+(percent*endY))-(shipsize/2), (((1-percent)*scaleXCoord(startx))+(percent*endX))+(shipsize/2), (((1-percent)*scaleYCoord(starty))+(percent*endY))+(shipsize/2), ColourNameToRGB("red"), 0, 0, ColourNameToRGB("red"), 0)
    end
  end
end
function jumpChecking()
  routeType = "checking"
end
function jumpError()
  routeType = "error"
end
function jumpAborted()
  routeType = "aborted"
end
function jumpChecked()
  if (routeType == "checking") then
    routeType = "checked"
  end
end
function jumpCompleted()
  if (routeType == "checked") then
    routeType = "completed"
  end
end
function enterHyper()
  inHyper = true
end
function togglePaths(flags, hotspot_id)
	if(showPaths == true) then
		showPaths = false
		hidePaths()
	else
		showPaths = true
		drawPaths(flags, hotspotid)
	end
end
function hidePaths(flags, hotspot_id)
	--WindowRectOp (win, miniwin.rect_fill, 0, 0, 800, 600, ColourNameToRGB("black"))  -- draw blank rectangle to "erase" window contents
	scheduleRedraw() -- redraw window
	
end
function scaleXCoord(coord)
	local percent = ((-minX+coord) / (-minX + maxX))*100	
  return ((((100-percent) / 100) * 10) + ((percent) / 100) * (width-10))
end
function scaleYCoord(coord)
	local percent = ((-minY+coord) / (-minY + maxY))*100
  return ((((100-percent) / 100) * (height-10)) + ((percent) / 100) * 10)
end
function onClick(flags, hotspot_id)
	local sys = systems[tonumber(hotspot_id)]
	if (sys.planet) then
		Execute("calculate " .. sys.planet)
	else
		Execute("calculate '" .. sys.x .. " " .. sys.y .. "'")
	end
end
function drawPaths(flags, hotspot_id)
 -- bug out to prevent crashes when not connected
	local sys = systems[tonumber(hotspot_id)]
	if not sys then
		return
	end
  local fontheight = WindowFontInfo(win, font, 1)
	local ax = scaleXCoord(tonumber(sys.x))
	local ay = scaleYCoord(tonumber(sys.y))
  for i, v in ipairs(systems) do -- do this first so we don't overlap
		if (v ~= sys) then
			local bx = scaleXCoord(tonumber(v.x))
			local by = scaleYCoord(tonumber(v.y))
			WindowLine (win, ax, ay, bx, by, ColourNameToRGB ("orange"), miniwin.pen_solid, 1)
    end
  end
  
	for i, v in ipairs(systems) do
		if (v ~= sys) then
			local bx = scaleXCoord(tonumber(v.x))
			local by = scaleYCoord(tonumber(v.y))
      --make a box to more easily see the distance number
      local textwidth = WindowTextWidth(win, font, distance(sys, v))
      WindowRectOp (win, miniwin.rect_fill, ((ax+bx)/2)-(textwidth/2)-2, ((ay+by)/2)-(fontheight/2), ((ax+bx)/2)+(textwidth/2)+2, ((ay+by)/2)+(fontheight/2), ColourNameToRGB("black"))  -- draw blank rectangle to "erase" window contents
      WindowRectOp (win, 1, ((ax+bx)/2)-(textwidth/2)-2, ((ay+by)/2)-(fontheight/2), ((ax+bx)/2)+(textwidth/2)+2, ((ay+by)/2)+(fontheight/2), ColourNameToRGB("white"))
			WindowText (win, font, distance(sys, v),   -- text
                ((ax+bx)/2)-(textwidth/2), ((ay+by)/2)-(fontheight/2), ((ax+bx)/2)+(textwidth/2), ((ay+by)/2)+(fontheight/2),        --draw distance in the middle of draw path
                ColourNameToRGB ("white"), -- colour
                false)              -- not Unicode
			
		end
	end
	--WindowShow (win,  true)  -- show it
	scheduleRedraw()
	BroadcastPlugin(999, "repaint")
end
function destroyWindow(name, list, args)
	WindowShow (win, false)
	visible = false
	--WindowDelete(win)
end
function distance(a, b)
	--return string.format("%.0f", math.sqrt(((b.x-a.x)*(a.x-b.x))+((a.y-b.y)*(a.y-b.y))))
    local dx=math.abs(b.x-a.x)
    local dy=math.abs(b.y-a.y)
    local dist = dx+dy
    return string.format("%.0f", dist)
end

function hyperJumpTick()
	if (totalJump > 0 and partialJump > 0) then
		partialJump = partialJump - 50
		if (visible) then
			--Note("Tick: " .. partialJump .. "/" .. totalJump)
			scheduleRedraw()
		end
	end
end
function storeTotalJump(name, list, args)
	if (args[1] and tonumber(args[1]) > 0) then
		totalJump = tonumber(args[1])
	end
	if (visible) then
		scheduleRedraw()
	end
end
function storePartialJump(name, list, args)
	if (args[1] and tonumber(args[1]) > 0) then
		if (totalJump == 0) then
		  inHyper = true
			totalJump = tonumber(args[1])
			EnableTimer("hyperJumpTicker", true)
		end
		partialJump = tonumber(args[1])
	end
	if (visible) then
		--Note("Tock: " .. partialJump .. "/" .. totalJump)
		scheduleRedraw()
	end
end
function clearJump()
  startx = nil
  starty = nil
  startrealx = nil
  startrealy = nil
  realx = nil
  realy = nil
  storedsystem = ""
  storedX = nil
  storedY = nil
  endX = nil
  endY = nil
	totalJump = 0
	partialJump = 0
	inHyper = false
	coordchanged = false
	jumpCompleted()
	CallPlugin("b2c06b3dcc775c0ede861316", "clearPlanet", "")
	EnableTimer("hyperJumpTicker", false)
	if (visible) then
		scheduleRedraw()
	end
end
----------------------------------------------------------------------
-- Called as the windows are dragged around.
----------------------------------------------------------------------
function ResizeMoveCallback(flags, hotspot_id)
   posx, posy = WindowInfo (win, 17), WindowInfo (win, 18)
   width = width + posx - startposx
   startposx = posx
   if (width < MIN_WIDTH) then
      width = MIN_WIDTH
      startposx = windowinfo.window_left+width
   elseif (windowinfo.window_left+width > GetInfo(281)) then
      width = GetInfo(281)-windowinfo.window_left
      startposx = GetInfo(281)
   end
   
   height = height + posy - startposy
   startposy = posy
   if (height < MIN_HEIGHT) then
   	height = MIN_HEIGHT
   	startposy = windowinfo.window_top+height
   elseif (windowinfo.window_top+height > GetInfo(280)) then
   	height = GetInfo(280)-windowinfo.window_top
   	startposy = GetInfo(280)
   end
   
   
	if (utils.timer() - lastRefresh > 0.0333) then
		SetUpHotspotsAndDraw(false)
		lastRefresh = utils.timer()
	end
end
lastRefresh = 0
---------------------------------------------------------------------------------
-- Called after the resize widget is released.
---------------------------------------------------------------------------------
function ResizeReleaseCallback ()
   SetUpHotspotsAndDraw(false) -- true here causes old lines to re-wrap at the new size
end
---------------------------------------------------------------------------------
-- Called when mouse button is pressed on hotspot.
---------------------------------------------------------------------------------
function MouseDown(flags, hotspot_id)
   if (hotspot_id == "resize") then
     startposx, startposy = WindowInfo (win, 17), WindowInfo (win, 18)
   end
end
---------------------------------------------------------------------------------
-- Called when mouse moved away from hotspot. Doesn't really apply for draggables.
---------------------------------------------------------------------------------
function CancelMouseDown(flags, hotspot_id)
end
---------------------------------------------------------------------------------
-- Called when mouse button released on hotspot.
---------------------------------------------------------------------------------
function MouseUp(flags, hotspot_id, win)
   if bit.band (flags, miniwin.hotspot_got_rh_mouse) ~= 0 then
      right_click_menu()
      return true
   end
   return false
end
function LeftClickOnly(flags, hotspot_id, win)
	if bit.band (flags, miniwin.hotspot_got_lh_mouse) ~= 0 then
    local sys = systems[tonumber(hotspot_id)]
    if (sys.planet) then
      Execute("calculate " .. sys.planet)
    else
      Execute("calculate '" .. sys.x .. " " .. sys.y .. "'")
    end
    return true
	end
	return false
end
function OnPluginInstall () 
  
	 font_name = GetVariable("font_name") or default_font_name
   font_size = tonumber(GetVariable("font_size")) or default_font_size
	
    --- Setup the windows
   SetUpHotspotsAndDraw(true)
   
  -- add the fonts                
  --check(WindowFont (win, font, "Arial", 10, true, false, false, false))
  
  scheduleRedraw()
    
end -- OnPluginInstall
--================================================================================
-- Called by OnPluginInstall, but also by redraw routine to refresh the screen
-- and (if the first time) add the resizer tag, otherwise move the resizer relative
-- to the main window.
--=================================================================================
function SetUpHotspotsAndDraw(firstTime)
	if (firstTime) then
		WindowCreate (win, 0, 0, width, height, miniwin.pos_center_all, 0, ColourNameToRGB("black")) -- create windows
		windowinfo = movewindow.install (win, 6) -- default to 6 (on top right)
		check(WindowFont (win, font, font_name, font_size, false, false, false, false))
		effectiveWidth = math.min(width, GetInfo(281)-windowinfo.window_left)
		WindowAddHotspot (win, "resize", effectiveWidth-RESIZE_TAG_SIZE, height-RESIZE_TAG_SIZE, effectiveWidth, height, "MouseOver", "CancelMouseOver", "MouseDown", "CancelMouseDown", "MouseUp", "", 6, 0)
		WindowDragHandler(win, "resize", "ResizeMoveCallback", "ResizeReleaseCallback", 0)
	else -- not our first time drawing
		-- everything has already been made
		-- just move them back into place
		effectiveWidth = math.min(width, GetInfo(281)-windowinfo.window_left)
		WindowResize(win, effectiveWidth, height, 0x000000)
		WindowMoveHotspot(win, "resize", effectiveWidth-RESIZE_TAG_SIZE, height-RESIZE_TAG_SIZE, effectiveWidth, height)
		setupConflicts()
    redraw_scheduled = true
		drawWindows()
	end
end
function drawWindows()
	if redraw_scheduled == false then
		return
	else
		redraw_scheduled = false
	end
  if visible then
    drawWindow()
  end
end
function drawResizer(window, winwidth, winheight)
   -- draw the resize widget bottom right corner.
   WindowLine(window, winwidth-3, winheight-2, winwidth-2, winheight-3, 0xffffff, 0, 2)
   WindowLine(window, winwidth-4, winheight-2, winwidth-2, winheight-4, 0x696969, 0, 1)
   WindowLine(window, winwidth-6, winheight-2, winwidth-2, winheight-6, 0xffffff, 0, 2)
   WindowLine(window, winwidth-7, winheight-2, winwidth-2, winheight-7, 0x696969, 0, 1)
   WindowLine(window, winwidth-9, winheight-2, winwidth-2, winheight-9, 0xffffff, 0, 2)
   WindowLine(window, winwidth-10, winheight-2, winwidth-2, winheight-10, 0x696969, 0, 1)
   WindowLine(window, winwidth-12, winheight-2, winwidth-2, winheight-12, 0xffffff, 0, 2)
   WindowLine(window, winwidth-13, winheight-2, winwidth-2, winheight-13, 0x696969, 0, 1)
end
--============================================================================
-- Central function for listening to data broadcast by LotJMSDPHandler.xml
-- Stores broadcast information locally to be easily accessed by plugin
--============================================================================
function OnPluginBroadcast (msg, id, name, text)
	-- Look for MSDP Handler.
	if (id == 'b3aae34498d5bf19b5b2e2af') then
		if (text == 'reload') then
			-- invalidate current data
			page_built = false
			return
		end
	scheduleRedraw()
  end
end
function scheduleRedraw()
	if redraw_scheduled == false then
		redraw_scheduled = true
		DoAfterSpecial(0.1, 'drawWindows()', sendto.script)
	end
end
function OnPluginSaveState ()
  -- save window current location for next time  
  movewindow.save_state (win)
  SetVariable("WINDOW_NAME", WINDOW_NAME)
  SetVariable("width", width)
  SetVariable("height", height)
  SetVariable("font_name", font_name)
  SetVariable("font_size", font_size)
  SetVariable("systems", serialize.save("systems"))
end -- function OnPluginSaveState
require "checkplugin"
function OnPluginListChanged()
	do_plugin_check_now ("b3aae34498d5bf19b5b2e2af", "LotJMSDPHandler") -- check we have MSDP handler plugin
	do_plugin_check_now ("b2c06b3dcc775c0ede861316", "LotJCalc") -- check we have LotJCalc
end
function restoreDefaults()
ColourNote("limegreen","","Star Map reset to defaults.")
for i, v in pairs(systems) do
	v.colour = nil
end
DeleteVariable("WINDOW_NAME")
DeleteVariable("font_name")
DeleteVariable("font_size")
DeleteVariable("width")
DeleteVariable("height")
WINDOW_NAME = "Galaxy Map"
width = 800
height = 600
WindowDelete(win)
OnPluginInstall()
resetBounds()
end
-- right click menu
function right_click_menu (hotspot_id)
	hotspots = {background=true}
	menustring ="!"
	
	menustring = menustring.."Add System|>Remove System|"
	
	for i, v in ipairs(systems) do
		menustring = menustring..((v.planet and v.planet.." - ") or "")..v.name.."|"
	end
	menustring = menustring.."<|-|>Change System Color|"
	
	for i, v in ipairs(systems) do
		menustring = menustring..((v.planet and v.planet.." - ") or "")..v.name.."|"
	end
	menustring = menustring.."<|-|"
	
	menustring = menustring.."Rename Window|Change Font|-|Reset Window to Defaults"
	
	
	result = WindowMenu (win,
		WindowInfo (win, 14),  -- x position
		WindowInfo (win, 15),   -- y position
		menustring) -- content
			
	--Note("Result: "..result)
			
	if result ~= "" then
		numResult = tonumber(result)
		
		if numResult == 1 then -- add system
		
			system.name = utils.inputbox("Name for new system?", "System name", "", GetVariable("font_name"), GetVariable("font_size"))
			system.x = tonumber(utils.inputbox("New system X coordinate?", "System X coordinate", "", GetVariable("font_name"), GetVariable("font_size")))
			system.y = tonumber(utils.inputbox("New system Y coordinate?", "System Y coordinate", "", GetVariable("font_name"), GetVariable("font_size")))
			if system.name and system.x and system.y then
				systems[#systems + 1] = system
				ColourNote("limegreen","","System '"..system.name.."' added to Star Map at coords "..system.x..","..system.y..".")
				system = {}
				resetBounds()
			else
				ColourNote("red","","Invalid new system input, aborting.")
				return
			end
			
		
		elseif numResult > 1 and numResult < #systems+2 then -- chose to remove a system
			ColourNote("red","","System '"..systems[numResult-1].name.."' removed from Star Map.")
			table.remove(systems, numResult-1)
			resetBounds()
		elseif numResult > #systems+1 and numResult < (#systems*2)+2 then -- chose to colour a system
			new_colour = PickColour(64636)
			if new_colour then
				systems[(numResult-1)-#systems].colour = new_colour
				--OnPluginInstall()
				resetBounds()
			end
		elseif numResult == (#systems*2) + 2 then -- rename window
			wanted_name = utils.inputbox("Choose a new name for this window:", "Window name", WINDOW_NAME, GetVariable("font_name"), GetVariable("font_size"))
			if wanted_name then
				WINDOW_NAME = wanted_name
				SetVariable("WINDOW_NAME", WINDOW_NAME)
				OnPluginInstall()
			end
		elseif numResult == (#systems*2) + 3 then -- change window font
			wanted_font = utils.fontpicker (font_name, font_size) --font dialog
			if wanted_font then
				font_name = wanted_font.name
				font_size = wanted_font.size
				SetVariable ("font_name", font_name)
				SetVariable ("font_size", font_size)
				check(WindowFont (win, font, font_name, font_size, false, false, false, false))
				OnPluginInstall()
        resetBounds()
			end
		elseif numResult == (#systems*2) + 4 then -- reset window to defaults
			restoreDefaults()
			return
		end
	end
	OnPluginSaveState()
end -- right_click_menu
  ]]> 
  </script>
  </muclient>
