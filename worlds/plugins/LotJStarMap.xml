<?xml version="1.0" encoding="iso-8859-1" ?> 
<!DOCTYPE muclient> 
<muclient>
<plugin name="LotJStarMap" author="@Johnson" id="dd5080a41939faabc233da8f" language="Lua" purpose="Dynamically display a system map with player location overlay" save_state="y" requires="4.73" version="2.43">
<description trim="y">
<![CDATA[
This plugin will gather information about the current galaxy's star systems 
using a datapad in order to display an up-to-date version of what the galaxy 
looks like. The map's scale is not preset, but gets cropped to the outermost 
star systems in order to reduce empty space.
This plugin relies on LotJMSDPHandler and LotJCalc to retrieve information 
about the player's current location and current destination in order to overlay
the ship position and hyperspace route.
This plugin also relies on an in-game datapad for galaxy information retrieval.
Basic usage:
Type "hypmap" to use a datapad to scan for starsystems and plot on map.
Type "showmap" to open map window without scanning, loading your saved planetary information.
Type "hidemap" to close map window, or click the X in the upper right to close.
Hover mouse over planets to see distances to other planets.
Click on a planet name to calculate a jump using LotJCalc.
Right click anywhere on the background to open an options menu where you can 
add/remove systems, customize system colors to your liking, rename the window, 
change the display font and restore the window to defaults.
  ]]> 
  </description>
  </plugin>
<!--   Get our standard constants   --> 
  <include name="constants.lua" /> 
<!--   Triggers    --> 
<triggers>
	<trigger name="systemCapture" script="storeSystem" match="^(.*)\( (.*)\, (.*) \)$" regexp="y" group="StarCap" omit_from_log="n" omit_from_output="n" sequence="100" />
	<trigger name="starsFailed" script="toggleOff" match="^You must hold a datapad to do this\.$" regexp="y" group="StarCap" sequence="100" />
	<trigger name="systemCapDone" script="findPlanets" match="^Displayed (.*) starsystems.$" regexp="y" group="StarCap" omit_from_log="n" omit_from_output="n" sequence="100" />
	<trigger name="planetCapTitle" match="Planet*Starsystem*Governed By*Notices" enabled="n" group="PlanetCap" omit_from_log="n" omit_from_output="n" sequence="100" />
	<trigger name="planetCapture" script="storePlanet" match="^(.*)  (.*)$" regexp="y" enabled="n" group="PlanetCap" omit_from_log="n" omit_from_output="n" sequence="100" />
  <trigger name="planetCapDone" script="setupWindow" match="^Use SHOWPLANET \<planet\> for more information\.$" regexp="y" enabled="n" group="PlanetCap" omit_from_log="n" omit_from_output="n" sequence="100" />
	<!-- Lightspeed triggers -->
	<trigger name="partialJump" match="^Remaining jump distance\: (.*)$" script="storePartialJump" group="LotJStarMap" enabled="y" regexp="y" sequence="100" />
	<trigger name="completedjump" match="^Hyperjump complete\.$" script="clearJump" group="LotJStarMap" enabled="y" regexp="y" sequence="100" />
	<trigger name="calculatingjump" match="^Checking hyperspace course integrity\. Please wait\.$" script="jumpChecking" group="LotJStarMap" enabled="y" regexp="y" sequence="100" />
  <trigger name="lowfueljump" match="^Warning \- Not enough fuel to complete the jump to hyperspace\!$" script="jumpError" group="LotJStarMap" enabled="y" regexp="y" sequence="100" />
  <trigger name="calculatedjump" match="^\[Status\]\: Hyperspace calculations have been completed\.$" script="jumpChecked" group="LotJStarMap" enabled="y" regexp="y" sequence="100" />
	<trigger name="abortedjump" match="^Hyperjump aborting\! Shutting down the Hyperdrive\.$" script="jumpAborted" group="LotJStarMap" enabled="y" regexp="y" sequence="100" />
  <trigger name="enterhyper" match="^The stars become streaks of light as you enter hyperspace\.$" script="enterHyper" group="LotJStarMap" enabled="y" regexp="y" sequence="100" />
  </triggers>
<!--   Aliases    --> 
<aliases>
  <alias name="initCommand" script="findStars" match="hypmap" enabled="y" regexp="n" group="LotJStarMap" ignore_case="y" sequence="100" />
  <alias name="createWindow" script="resetBounds" match="showmap" enabled="y" regexp="n" group="LotJStarMap" ignore_case="y" sequence="100" />
  <alias name="removeWindow" script="destroyWindow" match="hidemap" enabled="y" regexp="n" group="LotJStarMap" ignore_case="y" sequence="100" />
  </aliases>
<timers>
	<timer name="hyperJumpTicker" script="hyperJumpTick" enabled="n" second="2" group="LotJStarMap" />
</timers>
<!--   Script    --> 
<script>
<![CDATA[ 

require "movewindow"
require "serialize"
dofile(GetPluginInfo(GetPluginID(), 20) .. "lotj_colors.lua")
dofile(GetPluginInfo(GetPluginID(), 20) .. "LotJMSDPHelper.lua")

-- set file name for star map background here --
default_background_image = "stars_800_600.png"
background_full_path = GetPluginInfo(GetPluginID(), 20) .. default_background_image

enable_background_image = true

local win = "galaxy_map_" .. GetPluginID()  -- unique window name
systems = {}
local system = {}

local font = "f"
local maxX = 0
local minX = 0
local maxY = 0
local minY = 0
local failsafe = 0
local visible = false
WINDOW_NAME = GetVariable("WINDOW_NAME") or "Galaxy Map"
default_font_name = "Courier New"
default_font_size = 10
font_name = GetVariable("font_name") or default_font_name
font_size = tonumber(GetVariable("font_size")) or default_font_size
-- hyperjump stuff
local totalJump = 0
local partialJump = 0
local startx = nil
local starty = nil
local realx = nil
local realy = nil
local currentX = nil
local currentY = nil
local currentPlanet = ""
local currentSystem = ""
local endX = nil
local endY = nil
local startrealx = nil
local startrealy = nil
local routeType = ""
local shipsize = 8
local inHyper = false
local coordchanged = false
-- Variables not saved.
local startposx   = ""  
local startposy   = ""
local posx        = "" 
local posy        = ""
local RESIZE_TAG_SIZE = 10
local MIN_WIDTH   = 50
local MIN_HEIGHT  = 50
local redraw_scheduled = false
local width       = tonumber(GetVariable("width")) or 800
local height      = tonumber(GetVariable("height")) or 600

require("tprint")

function storePlanet(name, list, args, styles)
	--Note("1: '" .. args[1] .. "'")
	for i, v in ipairs(systems) do
		local sysName = v.name
		if (string.find(args[0], sysName)) then -- if the system name was found in the grab text
			systems[i].planet = Trim(string.sub(args[0], 1, string.find(args[0], sysName)-1)) -- set the planetname
      -- determine system color based on the most prevalent color in the 'Governed By' string
      local _, systemEndIndex = string.find(args[0], sysName)
      local govEndIndex = string.find(args[0], '%[', systemEndIndex+1)
      if systemEndIndex and govEndIndex then
        local gov = Trim(string.sub(args[0], systemEndIndex+1, govEndIndex-1))
        local govStart, govEnd = string.find(args[0], gov or "") 
        local styled = StylesToColoursOneLine(styles, govStart, govEnd)
        local astyles = ColoursToStyles(styled)
        local styleFreq = {}
        for a, b in pairs(astyles) do
          if styleFreq[b.textcolour] then -- style already exists
            styleFreq[b.textcolour] = styleFreq[b.textcolour] + Trim(b.text):len() -- don't include spaces in length count
          else
            styleFreq[b.textcolour] = Trim(b.text):len()
          end  
        end
        local most = 0
        local mostColor = ""
        for a, b in pairs(styleFreq) do
          if b > most then
            most = b
            mostColor = a
          end
        end
        systems[i].colour = mostColor
        DeleteLines(1)
        for a, b in pairs(styles) do
         ColourTell (RGBColourToName(b.textcolour or 111111), RGBColourToName(b.backcolour or 0), b.text) 
        end 

        ColourNote("silver",""," Color found: ",RGBColourToName(mostColor),"",RGBColourToName(mostColor),"silver",""," ","red","",most,"silver",""," characters")

      end
			--Note("System: '" .. systems[i].name .. "' Planet: '" .. systems[i].planet .. "'")
		end
	end
end

function findStars(name, list, args)
  systems = {}
	SendNoEcho("stars")
	toggleOn()
end

function findPlanets(name, list, args)
	SendNoEcho("planets")
	togglePlanetsOn()
end

function togglePlanetsOn(name, list, args)
	EnableTriggerGroup("PlanetCap", true)
end

function toggleOn(name, list, args)
	EnableTriggerGroup("StarCap", true)
	--WindowCreate (win, 0, 0, 800, 600, miniwin.pos_center_all, 0, ColourNameToRGB("black"))  -- create window
	--WindowFont (win, font, "Arial", 10, true, false, false, false) -- define font
end

function storeSystem(name, list, args)
	if (args[1] and args[2] and args[3]) then
		system.name = Trim(args[1])
		system.x = tonumber(args[2])
		system.y = tonumber(args[3])
		systems[#systems + 1] = system
    system = {}
	end
end

function toggleOff(name, list, args)
	EnableTriggerGroup("StarCap", false)
end

function togglePlanetsOff(name, list, args)
	EnableTriggerGroup("PlanetCap", false)
end

function resetBounds()
	visible = false
	maxX = nil
	maxY = nil
	minX = nil
	minY = nil
	setupWindow()
end

local buffer = 5 -- assign a buffer of in-game sectors around the edge of our viewable area
local boundary = 10 -- this means planet labels cannot go within this many pixels of the window edge

function setupWindow(name, line, args)
  if not systems or #systems == 0 then -- failsafe in case we try to display window without any planet information
    findStars()
    return
  end
	toggleOff()
	togglePlanetsOff()
	
	-- initialize our mins and maxes
	maxX = systems[1].x
	minX = systems[1].x
	maxY = systems[1].y
	minY = systems[1].y
	-- find our real max and min values so we can scale accordingly
	for _, v in pairs(systems) do
    maxX = math.max(maxX, v.x)
    minX = math.min(minX, v.x)
    maxY = math.max(maxY, v.y)
    minY = math.min(minY, v.y)
	end	
  -- extend a buffer area around the edge of window where planets won't be drawn
  -- this buffer is in-game system size, so min and max will have a gap of <buffer> number of sectors
  maxX = maxX + buffer
  minX = minX - buffer
  maxY = maxY + buffer
  minY = minY - buffer
		
	setupConflicts()
	
	visible = true
  scheduleRedraw()
end

function setupConflicts()
  -- setup our text boundaries since we just now figured out our max and min values for scaling
  for i, v in ipairs(systems) do
  	v.left = scaleXCoord(v.x) - WindowTextWidth(win, font, ((v.planet and v.planet) or v.name or ""))/2 
		v.top = scaleYCoord(v.y) + 5
		v.right = v.left + WindowTextWidth(win, font, ((v.planet and v.planet) or v.name or "")) -- font width
		v.bottom = v.top + WindowFontInfo(win, font, 1) -- font height
  end
  
  -- recursively resolve conflicts with other systems
  failsafe = 0
  resolveConflicts()
end

function resolveConflicts()
  if failsafe <= 50 then -- we don't want to get stuck in an infinite recursion loop
    -- resolve window boundary conflicts
    for i, v in ipairs(systems) do
      if v.top < 0 + boundary then
        v.top = 0 + boundary
        v.bottom = v.top + WindowFontInfo(win, font, 1)
      end
      if v.right > width - boundary then
        v.right = width - boundary
        v.left = v.right - WindowTextWidth(win, font, ((v.planet and v.planet) or v.name))
      end
      if v.left < 0 + boundary then
        v.left = 0 + boundary
        v.right = v.left + WindowTextWidth(win, font, ((v.planet and v.planet) or v.name))
      end
      if v.bottom > height - boundary then
        v.bottom = height - boundary
        v.top = v.bottom - WindowFontInfo(win, font, 1)
      end
    end
    -- resolve system conflicts
    for i, v in ipairs(systems) do
      for j, k in ipairs(systems) do
        if (i ~= j) then -- don't check a system against itself
          if conflicts(v, k) then -- uh oh we have a collision!
            failsafe = failsafe + 1
            resolveConflicts()
          end
        end
      end
    end
  end
end
-- this needs to be done better TODO
-- at the moment this works, but I am envisioning a system of 
-- calculating many different label positions, finding the
-- distance of the label from the marker, then choosing the label positions 
-- that maintain the best position for all systems in the vicinity
-- maybe it's overkill but if it's worth doing, it's worth overdoing.

function conflicts(sys1, sys2)
  if topleftconflicts(sys1, sys2) then
    --Note("Top Left Collision detected! ("..sys1.name..","..sys2.name..")")
    -- top left collided, try shifting down (add pixels)
    if sys2.bottom + 1 + WindowFontInfo(win, font, 1) < height - boundary then
      sys1.top = sys2.bottom + 1
      sys1.bottom = sys1.top + WindowFontInfo(win, font, 1)
    return true
    end
    --sys1, sys2 = findbestsolution(sys1, sys2)
  elseif bottomleftconflicts(sys1, sys2) then
    --Note("Bottom Left Collision detected! ("..sys1.name..","..sys2.name..")")
    -- bottom left collided, try shifting up (remove pixels)
    sys1.top = sys1.top - 1
    sys1.bottom = sys1.top + WindowFontInfo(win, font, 1)
    --sys1, sys2 = findbestsolution(sys1, sys2)
    return true
  elseif toprightconflicts(sys1, sys2) then
    --Note("Top Right Collision detected! ("..sys1.name..","..sys2.name..")")
    -- try shifting down first (add pixels)
    sys1.top = sys2.bottom + 1
    sys1.bottom = sys1.top + WindowFontInfo(win, font, 1)
    --sys1, sys2 = findbestsolution(sys1, sys2)
    return true
  elseif bottomrightconflicts(sys1, sys2) then
    --Note("Bottom Right Collision detected! ("..sys1.name..","..sys2.name..")")
    -- bottom right collided, try shifting up (remove pixels)
    sys1.top = sys1.top - 1
    sys1.bottom = sys1.top + WindowFontInfo(win, font, 1)
    --sys1, sys2 = findbestsolution(sys1, sys2)
    return true
  else
    return false
  end
end

function topleftconflicts(s1, s2)
  return ((s1.left >= s2.left and s1.left <= s2.right) and (s1.top <= s2.bottom and s1.top >= s2.top))
end

function bottomleftconflicts(s1, s2)
  return ((s1.left >= s2.left and s1.left <= s2.right) and (s1.bottom <= s2.bottom and s1.bottom >= s2.top))
end

function toprightconflicts(s1, s2)
  return ((s1.right >= s2.left and s1.right <= s2.right) and (s1.top <= s2.bottom and s1.top >= s2.top))
end

function bottomrightconflicts(s1, s2)
  return ((s1.right >= s2.left and s1.right <= s2.right) and (s1.bottom <= s2.bottom and s1.bottom >= s2.top))
end
local offsetgrid = { {-1, -1}, {-1, 0}, {-1, 1},
                     {0 , -1}, {0 , 0}, {0 , 1},
                     {1 , -1}, {1 , 0}, {1 , 1} }

function findbestsolution(sys1, sys2)
  local best = math.huge -- arbitrarily large number so we should always find something smaller
  local startsys1 = sys1
  local startsys2 = sys2
  local testsys1 = sys1
  local testsys2 = sys2
  local bestsys1 = sys1
  local bestsys2 = sys2
  for i=10, 200, 10 do
    for a, b in ipairs(offsetgrid) do
      testsys1.left = startsys1.left + b[1]*i
      testsys1.right = startsys1.right + b[1]*i
      testsys1.top = startsys1.top + b[2]*i
      testsys1.bottom = startsys1.bottom + b[2]*i
      for j, k in ipairs(offsetgrid) do
        testsys2.left = startsys2.left + k[1]*i
        testsys2.right = startsys2.right + k[1]*i
        testsys2.top = startsys2.top + k[2]*i
        testsys2.bottom = startsys2.bottom + k[2]*i
        if a~=j then -- don't test the same thing twice
          local test = systemnamedistance(testsys1, testsys2)
          if test < best then
            best = test
            bestsys1 = testsys1
            bestsys2 = testsys2
            Note("better solution found: 1="..bestsys1.name..":"..bestsys1.left..","..bestsys1.top.." 2="..bestsys2.name..":"..bestsys2.left..","..bestsys2.top.." dist: "..best)
          end
        end
      end
    end
  end
  Note("best solution found: 1="..bestsys1.name..":"..bestsys1.left..","..bestsys1.top.." 2="..bestsys2.name..":"..bestsys2.left..","..bestsys2.top.." dist: "..best)
  return bestsys1, bestsys2
end

function systemnamedistance(sys1, sys2)
  return sysdistance(sys1) + sysdistance(sys2)
end

function sysdistance(sys)
  local bx = (sys.left + ((sys.right-sys.left)/2))
  local by = (sys.top + ((sys.bottom-sys.top)/2))
  local scaledx = scaleXCoord(sys.x)
  local sclaedy = scaleYCoord(sys.y)
  return math.sqrt(((scaledx-bx)*(scaledx-bx))+((scaledy-by)*(scaledy-by)))
end  

function drawWindow(name, line, args)
	WindowRectOp (win, miniwin.rect_fill, 0, 0, width, height, ColourNameToRGB("black"))  -- draw blank rectangle to "erase" window contents

  if enable_background_image then
    -- Draw background image  
    WindowDrawImage(win, "background_image", 0, 0, width, height, 2)
  end
	
	 -- draw border
  WindowRectOp (win, 5, 0, 0, 0, 0, 5, 15 + 0x1000)	
	
  -- draw cargo route if we received it from LotJCargo
  drawCargoRoute()

	for i=1,#systems,1 do
		local sys = systems[i]
		local x = scaleXCoord(sys.x)  -- scale X coordinate
		local y = scaleYCoord(sys.y) -- scale Y coordinate
		
		WindowText (win, font, ((sys.planet and sys.planet) or sys.name),   -- text
                sys.left or 0, sys.top or 0, sys.right or 0, sys.bottom or 0,        -- rectangle
                ColourNameToRGB ("white"), -- colour
                false)              -- not Unicode
                
    WindowCircleOp (win, miniwin.circle_ellipse, -- circle
              x-5, y-5, x+5, y+5,                -- Left, Top, Right, Bottom
              sys.colour or ColourNameToRGB("darkgray"), miniwin.pen_solid, 1, -- pen width 1
              --ColourNameToRGB("white"), miniwin.pen_solid, 1, -- this gives planet a white outline
              sys.colour or ColourNameToRGB("darkgray"), miniwin.brush_solid)  -- brush
      
    WindowAddHotspot(win, i,  
              sys.left, sys.top, sys.right, sys.bottom,
              "drawPaths", -- mousehover
              "hidePaths",        -- mousecancelhover
              "LeftClickOnly",         -- mousedown
              "CancelMouseDown",   -- mousecanceldown
              "",           -- mouseup
              sys.name.. " (" .. sys.x .. "," .. sys.y .. ")",  -- tooltip text
              1, 0)
  end

  -- draw X in the corner to close the window
  WindowLine (win, width-15, 5, width-5, 15, ColourNameToRGB ("white"), miniwin.pen_solid, 1)
  WindowLine (win, width-15, 15, width-5, 5, ColourNameToRGB ("white"), miniwin.pen_solid, 1)
  WindowAddHotspot(win, "windowX",
      width-15, 5, width-5, 15,
      "",                   --mousehover
      "",                   --mouseoffhover
      "destroyWindow",      --mousedown
      "CancelMouseDown",                   --mouseoffdown
      "LeftClickOnly",                   --mouseup
      "Close hypmap window",
      1, 0)

  -- heading line
 	WindowText (win, font, WINDOW_NAME, 5, 5, 0, 0, ColourNameToRGB("white"))
 	
  -- draw hyper path and ship so they are always on top of planets
	drawHyperpath()
	
  drawResizer(win, width, height)
 	
  WindowShow (win,  true)  -- show it
  BroadcastPlugin(999, "repaint")
end

local storedroutes = {}

function drawCargoRoute()
  local storedroute = GetPluginVariable("b4f195e776cff20d17a1abd2", "cargolist") or ""
  if storedroute ~= "" then -- make cargo routes take priority over calc routes
    storedroutes = {}
    local planets = utils.split(storedroute, ',')
    storedroutes = {}
    local prevx = 0
    local prevy = 0
    for i, v in ipairs(planets) do
      for k, sysv in pairs(systems) do
        if (v:lower() == sysv.name:lower()) or (sysv.planet and sysv.planet:lower() == v:lower()) then
          if i>1 then -- not first system in list
            local route = {startx = prevx, starty = prevy, endx = scaleXCoord(sysv.x), endy = scaleYCoord(sysv.y) }
            storedroutes[#storedroutes + 1] = route
          end
          prevx = scaleXCoord(sysv.x)
          prevy = scaleYCoord(sysv.y)
        end
      end
    end 
    if type(storedroutes)=="table" and #storedroutes > 0 then -- we have multiple routes, draw all the lines
    -- add the final line to connect the last system back to the first
    storedroutes[#storedroutes + 1] = {startx = prevx, starty = prevy, endx = storedroutes[1].startx, endy = storedroutes[1].starty }
      for i, v in ipairs(storedroutes) do
        WindowLine(win, v.startx, v.starty, v.endx, v.endy, ColourNameToRGB("gray"), 0, 2)
      end
    end
  end
end

function drawHyperpath()
	if haveCoords() then -- if we are in a location that can be drawn on the map
	  drawCoords()
	  if haveDestination() then -- if we have a destination that can be drawn on the map
	    drawRoute()
	  end
	end
end

function haveCoords()
  currentX = tonumber(getmsdp("SHIPGALX"))
  currentY = tonumber(getmsdp("SHIPGALY"))
  currentSystem = getmsdp("SHIPSYSNAME")
  -- currentPlanet = getmsdp("PLANET") -- this is only updated if you use 'showplanet', leads to planet ghosting so leaving it out for now
  
	-- this is a little wonky because MSDP reports SHIPGALX and SHIPGALY default values as being 0
	-- which could also be the center of the galaxy.
	
  if ((startx ~= nil and starty ~= nil) and inHyper) then -- if we have a starting spot on the map (we should be in hyper)
    return true
  end
  if (currentX ~= 0 or currentY ~= 0 or currentSystem ~= "") and (currentX ~= nil and currentY ~= nil) then -- if we are in regular space
    return true
  end 
  if currentPlanet ~= "" then -- we are on a planet
    return true
  end
  return false -- we arent anywhere! abort!!
end

function drawPlayerLocation(x, y)
    WindowCircleOp(win, 1, x-(shipsize/2)-5, y-(shipsize/2)-5, x+(shipsize/2)+5, y+(shipsize/2)+5, ColourNameToRGB("white"), 0, 0, 0, 0)
    WindowCircleOp(win, 1, x-(shipsize/2), y-(shipsize/2), x+(shipsize/2), y+(shipsize/2), ColourNameToRGB("red"), 0, 0, ColourNameToRGB("red"), 0)
    WindowLine(win, x, y+(shipsize/2)+10, x, y+(shipsize/2)+25, ColourNameToRGB("white"), miniwin.pen_solid, 1)
    WindowLine(win, x, y-(shipsize/2)-10, x, y-(shipsize/2)-25, ColourNameToRGB("white"), miniwin.pen_solid, 1)
    WindowLine(win, x+(shipsize/2)+10, y, x+(shipsize/2)+25, y, ColourNameToRGB("white"), miniwin.pen_solid, 1)
    WindowLine(win, x-(shipsize/2)-10, y, x-(shipsize/2)-25, y, ColourNameToRGB("white"), miniwin.pen_solid, 1)
end

function drawCoords()
  if currentX ~= 0 or currentY ~= 0 then -- our coords are in the x,y form
    realx = scaleXCoord(currentX)
    realy = scaleYCoord(currentY)
    startrealx = currentX
    startrealy = currentY
  else  -- not x,y coords
    for k, v in pairs(systems) do
      if currentSystem ~= "" and (v.name and string.lower(v.name) == string.lower(currentSystem)) then -- scroll planet list and see if our current system matches one of the system names
        realx = scaleXCoord(v.x)
        realy = scaleYCoord(v.y)
        startrealx = v.x
        startrealy = v.y
      elseif currentPlanet ~= "" and (v.planet and string.lower(v.planet) == string.lower(currentPlanet)) then -- scroll planet list and see if our current planet matches one of the planet names
        realx = scaleXCoord(v.x)
        realy = scaleYCoord(v.y)
        startrealx = v.x
        startrealy = v.y
      end
    end
  end
  if not inHyper then
    drawPlayerLocation(realx, realy)
  end
end

function haveDestination()
  local storedsystem = GetPluginVariable("b2c06b3dcc775c0ede861316", "planetname") or ""
  local storedX = nil
  local storedY = nil 
  
  if storedsystem == "" then -- we didn't get anything from lotjcalc or LotJCargo
    startx = nil
    starty = nil
    startrealx = nil
    startrealy = nil
    return false
  end
  if string.find(storedsystem, "%([%d-]+%,[%d-]+%)") then -- we got an uncharted coordinate from lotjcalc
    local ax, bx = string.find(storedsystem, "%([%d-]+%,", 0, false)
    storedX = tonumber(string.sub(storedsystem, ax+1, bx-1))
    local ay, by = string.find(storedsystem, "%,[%d-]+%)", bx, false)
    storedY = tonumber(string.sub(storedsystem, ay+1, by-1))
    endX = scaleXCoord(storedX)
    endY = scaleYCoord(storedY)
    return true
  
  end
  if storedsystem ~= "" then
    -- if we make it this far, it means we got a planet or system name from lotjcalc, scroll through and find out who it belongs to
    for k, v in pairs(systems) do -- check to see if lotjcalc's system belongs to one of the known systems or planets
      if (v.name and string.lower(v.name) == string.lower(storedsystem)) or (v.planet and string.lower(v.planet) == string.lower(storedsystem)) then
        endX = scaleXCoord(v.x)
        endY = scaleYCoord(v.y)
        return true
      end
    end
  end
  return false
end

function drawRoute()
	local percent = 0
	local pixels = 0
  local routeColor = "gray"
	
	if (totalJump > 0 and partialJump > 0) then
		percent = (totalJump - partialJump) / totalJump
	end
  
  -- find our starting position to draw a line from
  if ((startx == nil) and (starty == nil)) then
    startx = startrealx
    starty = startrealy
  end
  -- check our route status to draw appropriate color
  if (routeType == "checking" or routeType == "aborted") then
    routeColor = "gray"
  elseif (routeType == "error") then
    routeColor = "darkred"
  elseif (routeType == "checked") then
    routeColor = "white"
  elseif (routeType == "completed") then
    routeColor = "lime"
  end
  
  -- draw our route and place on that route
  WindowLine(win, scaleXCoord(startx), scaleYCoord(starty), endX, endY, ColourNameToRGB(routeColor), miniwin.pen_solid, 2)
  if inHyper then
    if partialJump < 0 then
      drawPlayerLocation(endX, endY)
    else
      drawPlayerLocation( (((1-percent)*scaleXCoord(startx))+(percent*endX)), (((1-percent)*scaleYCoord(starty))+(percent*endY)) )
    end
  end
end

function jumpChecking()
  routeType = "checking"
end

function jumpError()
  routeType = "error"
end

function jumpAborted()
  routeType = "aborted"
end

function jumpChecked()
  if (routeType == "checking") then
    routeType = "checked"
  end
end
function jumpCompleted()
  if (routeType == "checked") then
    routeType = "completed"
  end
end

function enterHyper()
  inHyper = true
end

function togglePaths(flags, hotspot_id)
	if(showPaths == true) then
		showPaths = false
		hidePaths()
	else
		showPaths = true
		drawPaths(flags, hotspotid)
	end
end

function hidePaths(flags, hotspot_id)
	scheduleRedraw() -- redraw window
	
end

function scaleXCoord(coord)
  local percent = (-minX + coord) / (-minX + maxX)
  return ((1 - percent)) + (percent * (width))

end

function scaleYCoord(coord)
  local percent = (-minY + coord) / (-minY + maxY)
  return ((1 - percent) * (height)) + (percent)
end

function onClick(flags, hotspot_id)
	local sys = systems[tonumber(hotspot_id)]
	if (sys.planet) then
		Execute("calculate " .. sys.planet)
	else
		Execute("calculate '" .. sys.x .. " " .. sys.y .. "'")
	end
end

function drawPaths(flags, hotspot_id)
 -- bug out to prevent crashes when not connected
	local sys = systems[tonumber(hotspot_id)]
	if not sys then
		return
	end
  local fontheight = WindowFontInfo(win, font, 1)
	local ax = scaleXCoord(tonumber(sys.x))
	local ay = scaleYCoord(tonumber(sys.y))
  for i, v in ipairs(systems) do -- do this first so we don't overlap
		if (v ~= sys) then
			local bx = scaleXCoord(tonumber(v.x))
			local by = scaleYCoord(tonumber(v.y))
			WindowLine (win, ax, ay, bx, by, ColourNameToRGB ("orange"), miniwin.pen_solid, 1)
    end
  end
  
	for i, v in ipairs(systems) do
		if (v ~= sys) then
			local bx = scaleXCoord(tonumber(v.x))
			local by = scaleYCoord(tonumber(v.y))
      --make a box to more easily see the distance number
      local textwidth = WindowTextWidth(win, font, distance(sys, v))
      WindowRectOp (win, miniwin.rect_fill, ((ax+bx)/2)-(textwidth/2)-2, ((ay+by)/2)-(fontheight/2), ((ax+bx)/2)+(textwidth/2)+2, ((ay+by)/2)+(fontheight/2), ColourNameToRGB("black"))  -- draw blank rectangle to "erase" window contents
      WindowRectOp (win, 1, ((ax+bx)/2)-(textwidth/2)-2, ((ay+by)/2)-(fontheight/2), ((ax+bx)/2)+(textwidth/2)+2, ((ay+by)/2)+(fontheight/2), ColourNameToRGB("white"))
			WindowText (win, font, distance(sys, v),   -- text
                ((ax+bx)/2)-(textwidth/2), ((ay+by)/2)-(fontheight/2), ((ax+bx)/2)+(textwidth/2), ((ay+by)/2)+(fontheight/2),        --draw distance in the middle of draw path
                ColourNameToRGB ("white"), -- colour
                false)              -- not Unicode
			
		end
	end
	--WindowShow (win,  true)  -- show it
	scheduleRedraw()
	BroadcastPlugin(999, "repaint")
end

function destroyWindow(name, list, args)
	WindowShow (win, false)
	visible = false
	--WindowDelete(win)
end

function distance(a, b)
	return string.format("%.0f", math.sqrt(((a.x-b.x)*(a.x-b.x))+((a.y-b.y)*(a.y-b.y))))
end

function hyperJumpTick()
	if (totalJump > 0 and partialJump > 0) then
		partialJump = partialJump - 50
		if (visible) then
			--Note("Tick: " .. partialJump .. "/" .. totalJump)
			scheduleRedraw()
		end
	end
end

function storeTotalJump(name, list, args)
	if (args[1] and tonumber(args[1]) > 0) then
		totalJump = tonumber(args[1])
	end
	if (visible) then
		scheduleRedraw()
	end
end

function storePartialJump(name, list, args)
	if (args[1] and tonumber(args[1]) > 0) then
		if (totalJump == 0) then
		  inHyper = true
			totalJump = tonumber(args[1])
			EnableTimer("hyperJumpTicker", true)
		end
		partialJump = tonumber(args[1])
	end
	if (visible) then
		--Note("Tock: " .. partialJump .. "/" .. totalJump)
		scheduleRedraw()
	end
end

function clearJump()
  startx = nil
  starty = nil
  startrealx = nil
  startrealy = nil
  realx = nil
  realy = nil
  storedsystem = ""
  storedroute = ""
  storedX = nil
  storedY = nil
  endX = nil
  endY = nil
	totalJump = 0
	partialJump = 0
	inHyper = false
	coordchanged = false
	jumpCompleted()
	CallPlugin("b2c06b3dcc775c0ede861316", "clearPlanet", "")
	EnableTimer("hyperJumpTicker", false)
	if (visible) then
		scheduleRedraw()
	end
end
----------------------------------------------------------------------
-- Called as the windows are dragged around.
----------------------------------------------------------------------

function ResizeMoveCallback(flags, hotspot_id)
   posx, posy = WindowInfo (win, 17), WindowInfo (win, 18)
   width = width + posx - startposx
   startposx = posx
   if (width < MIN_WIDTH) then
      width = MIN_WIDTH
      startposx = windowinfo.window_left+width
   elseif (windowinfo.window_left+width > GetInfo(281)) then
      width = GetInfo(281)-windowinfo.window_left
      startposx = GetInfo(281)
   end
   
   height = height + posy - startposy
   startposy = posy
   if (height < MIN_HEIGHT) then
   	height = MIN_HEIGHT
   	startposy = windowinfo.window_top+height
   elseif (windowinfo.window_top+height > GetInfo(280)) then
   	height = GetInfo(280)-windowinfo.window_top
   	startposy = GetInfo(280)
   end
   
   
	if (utils.timer() - lastRefresh > 0.0333) then
		SetUpHotspotsAndDraw(false)
		lastRefresh = utils.timer()
	end
end
lastRefresh = 0
---------------------------------------------------------------------------------
-- Called after the resize widget is released.
---------------------------------------------------------------------------------

function ResizeReleaseCallback ()
   SetUpHotspotsAndDraw(false) -- true here causes old lines to re-wrap at the new size
end
---------------------------------------------------------------------------------
-- Called when mouse button is pressed on hotspot.
---------------------------------------------------------------------------------

function MouseDown(flags, hotspot_id)
   if (hotspot_id == "resize") then
     startposx, startposy = WindowInfo (win, 17), WindowInfo (win, 18)
   end
end
---------------------------------------------------------------------------------
-- Called when mouse moved away from hotspot. Doesn't really apply for draggables.
---------------------------------------------------------------------------------

function CancelMouseDown(flags, hotspot_id)
end
---------------------------------------------------------------------------------
-- Called when mouse button released on hotspot.
---------------------------------------------------------------------------------

function MouseUp(flags, hotspot_id, win)
   if bit.band (flags, miniwin.hotspot_got_rh_mouse) ~= 0 then
      right_click_menu()
      return true
   end
   return false
end

function LeftClickOnly(flags, hotspot_id, win)
	if bit.band (flags, miniwin.hotspot_got_lh_mouse) ~= 0 then
    local sys = systems[tonumber(hotspot_id)]
    if (sys.planet) then
      Execute("calculate " .. sys.planet)
    else
      Execute("calculate '" .. sys.x .. " " .. sys.y .. "'")
    end
    return true
	end
	return false
end

function OnPluginInstall () 
  
  loadstring(GetVariable("systems") or "")()
  visible = GetVariable("visible") == "true"
  font_name = GetVariable("font_name") or default_font_name
  font_size = tonumber(GetVariable("font_size")) or default_font_size
  enable_background_image = GetVariable("enable_background_image") == "true"

  background_full_path = GetVariable("starmap_background") or GetPluginInfo(GetPluginID(), 20) .. default_background_image

  --- Setup the windows
  SetUpHotspotsAndDraw(true)
  resetBounds()
 
  scheduleRedraw()

end -- OnPluginInstall
--================================================================================
-- Called by OnPluginInstall, but also by redraw routine to refresh the screen
-- and (if the first time) add the resizer tag, otherwise move the resizer relative
-- to the main window.
--=================================================================================

function SetUpHotspotsAndDraw(firstTime)
	if (firstTime) then
		WindowCreate (win, 0, 0, width, height, miniwin.pos_center_all, 0, ColourNameToRGB("black")) -- create windows
		windowinfo = movewindow.install (win, 6) -- default to 6 (on top right)

		check(WindowFont (win, font, font_name, font_size, false, false, false, false))
    --drag handler
    movewindow.add_drag_handler (win, 0, 0, width-15, WindowFontInfo (win, font, 1)+5)

    WindowAddHotspot(win, "background", 0, WindowFontInfo(win, font, 1)+6, width-RESIZE_TAG_SIZE, height-RESIZE_TAG_SIZE, "", "", "MouseDown", "CancelMouseDown", "MouseUp", "", 0, 0)
		WindowAddHotspot (win, "resize", width-RESIZE_TAG_SIZE, height-RESIZE_TAG_SIZE, width, height, "MouseOver", "CancelMouseOver", "MouseDown", "CancelMouseDown", "MouseUp", "", 6, 0)
		WindowDragHandler(win, "resize", "ResizeMoveCallback", "ResizeReleaseCallback", 0)
    
    result = WindowLoadImage(win, "background_image", background_full_path)
    if result ~= error_code.eOK then
      enable_background_image = false
      ColourNote("red","","LotJStarMap failed to load background file: " .. background_full_path)
      ColourNote("red","","Please ensure you select only .PNG image files due to MUSHclient limitations.")
    end
	else -- not our first time drawing
		-- everything has already been made
		-- just move them back into place
		WindowResize(win, width, height, 0x000000)
    WindowMoveHotspot(win, "background", 0, WindowFontInfo(win, font, 1) + 6, width-RESIZE_TAG_SIZE, height-RESIZE_TAG_SIZE)
		WindowMoveHotspot(win, "resize", width-RESIZE_TAG_SIZE, height-RESIZE_TAG_SIZE, width, height)
		setupConflicts()
    redraw_scheduled = true
		drawWindows()
	end
end

function drawWindows()
	if not redraw_scheduled then
		return
	else
		redraw_scheduled = false
	end
  if visible then
    drawWindow()
  end
end

function drawResizer(window, winwidth, winheight)
   -- draw the resize widget bottom right corner.
   WindowLine(window, winwidth-3, winheight-2, winwidth-2, winheight-3, 0xffffff, 0, 2)
   WindowLine(window, winwidth-4, winheight-2, winwidth-2, winheight-4, 0x696969, 0, 1)
   WindowLine(window, winwidth-6, winheight-2, winwidth-2, winheight-6, 0xffffff, 0, 2)
   WindowLine(window, winwidth-7, winheight-2, winwidth-2, winheight-7, 0x696969, 0, 1)
   WindowLine(window, winwidth-9, winheight-2, winwidth-2, winheight-9, 0xffffff, 0, 2)
   WindowLine(window, winwidth-10, winheight-2, winwidth-2, winheight-10, 0x696969, 0, 1)
   WindowLine(window, winwidth-12, winheight-2, winwidth-2, winheight-12, 0xffffff, 0, 2)
   WindowLine(window, winwidth-13, winheight-2, winwidth-2, winheight-13, 0x696969, 0, 1)
end

--============================================================================
-- Central function for listening to data broadcast by LotJMSDPHandler.xml
-- Stores broadcast information locally to be easily accessed by plugin
--============================================================================
function OnPluginBroadcast (msg, id, name, text)
	-- Look for MSDP Handler.
	if (id == 'b3aae34498d5bf19b5b2e2af') then
		if (text == 'reload') then
			-- invalidate current data
			page_built = false
			return
		end
    scheduleRedraw()
  elseif id == 'b4f195e776cff20d17a1abd2' then -- LotJCargo
    if (text == 'reload') then
      scheduleRedraw()
    end
  end
end

function scheduleRedraw()
	if redraw_scheduled == false then
		redraw_scheduled = true
		DoAfterSpecial(0.1, 'drawWindows()', sendto.script)
	end
end

function OnPluginSaveState ()
  -- save window current location for next time  
  movewindow.save_state (win)
  SetVariable("visible", tostring(visible)) 
  SetVariable("WINDOW_NAME", WINDOW_NAME)
  SetVariable("width", width)
  SetVariable("height", height)
  SetVariable("font_name", font_name)
  SetVariable("font_size", font_size)
  SetVariable("systems", ((systems and serialize.save("systems")) or "")) -- make sure we don't serialize nil
  SetVariable("enable_background_image", tostring(enable_background_image))

  SetVariable("starmap_background", background_full_path or GetPluginInfo(GetPluginID(), 20) .. default_background_image)
end -- function OnPluginSaveState

require "checkplugin"

function OnPluginListChanged()
	do_plugin_check_now ("b3aae34498d5bf19b5b2e2af", "LotJMSDPHandler") -- check we have MSDP handler plugin
	do_plugin_check_now ("b2c06b3dcc775c0ede861316", "LotJCalc") -- check we have LotJCalc
end

function restoreDefaults()
  ColourNote("limegreen","","Star Map reset to defaults.")
  -- remove any custom colors that have been set
  for i=1, #systems, 1 do
    systems[i].colour = nil
  end
  DeleteVariable("WINDOW_NAME")
  DeleteVariable("font_name")
  DeleteVariable("font_size")
  DeleteVariable("width")
  DeleteVariable("height")
  enable_background_image = true
  background_full_path = GetPluginInfo(GetPluginID(), 20) .. default_background_image
  WINDOW_NAME = "Galaxy Map"
  width = 800
  height = 600
  WindowDelete(win)
  OnPluginSaveState()
  OnPluginInstall()
  resetBounds()
end

-- right click menu
function right_click_menu (hotspot_id)
	hotspots = {background=true}
	menustring ="!"
	
	menustring = menustring.."Add System|>Remove System|"
	
	for i, v in ipairs(systems) do
		menustring = menustring..((v.planet and v.planet.." - ") or "")..v.name.."|"
	end
	menustring = menustring.."<|-|>Change System Color|"
	
	for i, v in ipairs(systems) do
		menustring = menustring..((v.planet and v.planet.." - ") or "")..v.name.."|"
	end
	menustring = menustring.."<|-|"
	
	menustring = menustring.."Rename Window|Change Font|Remove Background Image|Set Background Image|-|Reset Window to Defaults"
	
	
	result = WindowMenu (win,
		WindowInfo (win, 14),  -- x position
		WindowInfo (win, 15),   -- y position
		menustring) -- content
			
	--Note("Result: "..result)
			
	if result ~= "" then
		numResult = tonumber(result)
		
		if numResult == 1 then -- add system
		
			system.name = utils.inputbox("Name for new system?", "System name", "", GetVariable("font_name"), GetVariable("font_size"))
			system.x = tonumber(utils.inputbox("New system X coordinate?", "System X coordinate", "", GetVariable("font_name"), GetVariable("font_size")))
			system.y = tonumber(utils.inputbox("New system Y coordinate?", "System Y coordinate", "", GetVariable("font_name"), GetVariable("font_size")))
			if system.name and system.x and system.y then
				systems[#systems + 1] = system
				ColourNote("limegreen","","System '"..system.name.."' added to Star Map at coords "..system.x..","..system.y..".")
				system = {}
				resetBounds()
			else
				ColourNote("red","","Invalid new system input, aborting.")
				return
			end
			
		
		elseif numResult > 1 and numResult < #systems+2 then -- chose to remove a system
			ColourNote("red","","System '"..systems[numResult-1].name.."' removed from Star Map.")
			table.remove(systems, numResult-1)
			resetBounds()
		elseif numResult > #systems+1 and numResult < (#systems*2)+2 then -- chose to colour a system
			new_colour = PickColour(systems[(numResult-1)-#systems].colour or ColourNameToRGB("darkgray"))
			if new_colour then
				systems[(numResult-1)-#systems].colour = new_colour
				--OnPluginInstall()
				resetBounds()
			end
		elseif numResult == (#systems*2) + 2 then -- rename window
			wanted_name = utils.inputbox("Choose a new name for this window:", "Window name", WINDOW_NAME, GetVariable("font_name"), GetVariable("font_size"))
			if wanted_name then
				WINDOW_NAME = wanted_name
				SetVariable("WINDOW_NAME", WINDOW_NAME)
				OnPluginInstall()
			end
		elseif numResult == (#systems*2) + 3 then -- change window font
			wanted_font = utils.fontpicker (font_name, font_size) --font dialog
			if wanted_font then
				font_name = wanted_font.name
				font_size = wanted_font.size
				SetVariable ("font_name", font_name)
				SetVariable ("font_size", font_size)
				check(WindowFont (win, font, font_name, font_size, false, false, false, false))
				OnPluginInstall()
        resetBounds()
			end
		elseif numResult == (#systems*2) + 4 then -- disable background image
      enable_background_image = false
      OnPluginSaveState()
      OnPluginInstall()
		elseif numResult == (#systems*2) + 5 then -- choose new background image
      new_image = utils.filepicker("Choose new background image", default_background_image, "png", { png = "PNG Image" }, false )
      if new_image then
        background_full_path = new_image
        ColourNote("limegreen","","New background image: "..background_full_path)
        enable_background_image = true
        OnPluginSaveState()
        OnPluginInstall()
      end

    elseif numResult == (#systems*2) + 6 then -- reset window to defaults
			restoreDefaults()
			return
		end
	end
	OnPluginSaveState()
end -- right_click_menu
  ]]> 
  </script>
  </muclient>
