<?xml version="1.0" encoding="iso-8859-1" ?> 
<!DOCTYPE muclient> 
<!--  Saved on Wednesday, July 25, 2012, 7:12 PM   -->  
<muclient>
<plugin name="LotJCargo" author="@Johnson" id="b4f195e776cff20d17a1abd2" language="Lua" purpose="Cargo Running Made Easy" save_state="y" requires="4.40" version="1.59">
<description trim="y">
<![CDATA[ 
Usage:
*NOTICE* This plugin has been expanded to allow usage of multiple ships stacked 
inside each other, referred to as 'parents' and 'children'. Ships must be 
defined with a 'cargo ship profile' and stored into the cargo ship database before 
they can be used for running cargo. Once your ship is stored into the database it 
will remain there so you can easily load up different configurations of ships for 
cargo running. Example situations follow below.
Example 1:
We want to use a single cargo ship: YG-4210 Transport 'GGCargo'
We must create a 'cargo ship profile' to suit this ship and define necessary info 
about it.
Step 1:
'cargoShipProfileSetup'  - This command will prompt you for all the info the plugin
                           needs to create a 'cargo ship profile'.
                           In this example it will be: ship name - 'GGCargo'
                                                       ship type - 'YG-4210 Transport'
                                                       ship size - '5'
                                dirs from hatch to pilot's chair - 'e;u;n'
                                dirs from pilot's chair to hatch - 's;d;w'
                             dirs from pilot's chair to nav room - ''
                             dirs from nav room to pilot's chair - ''
                                  number of hangars on this ship - '0'
                                  
This is a lot of info so if you need to cancel out don't worry, you can always enter
the command to input new fields while retaining what you already entered.
Step 2:
'cargoShipProfilePush'  - This command will save the working 'cargo ship profile' into
                          the cargo ship database for repeated usage and clear the working
                          'cargo ship profile' in case you want to add multiple ship types.
Step 3:
'cargoShipAdd GGCargo'  - This command will load the saved 'cargo ship profile' matching
                              'GGCargo' into the 'cargo ship list'. The 'cargo ship list' is
                              where we define our desired cargo ship structure. With this usage
                              ship 'GGCargo' gets added to the list as a single parent with no
                              children ships contained within, since it has no hangar space
                              available.
Step 4:
'cargoSetup'                - This command will prompt for the needed cargo planet information,
                              including planet name, resource to be bought, and trafficking 
                              preference for that planet.
    - or -
'cargoPlanets <planet1>,<resource1>,<trafficking>,<planet2>,<resource2>,<trafficking>,...'
                             - Instead of prompting for the cargo planet information this command
                               can be used to quickly define a cargo running route. Note: you can 
                               use 'none' in any of your cargo legs to skip buying cargo from that 
                               world. This can be used to automate flying a ship from world to world
                               without cargo pods, for training piloting or when making many short 
                               jumps in a public taxi, for instance.
Step 5:
'cargoStart'                 - This command will begin a cargo session by scanning current cargo
                               manifests of all cargo ships and selling off unwanted resources while
                               buying the necessary ones. Note: if the planet you are on doesn't deal
                               in the resources you have aboard, you'll have to find a planet that does,
                               or jettison some cargo into space. Note note: This command must be used
                               while standing outside your ship on the first world in your cargoPlanets list.
Step 6:
That's it! If everything was set up correctly the plugin should fly between worlds buying and selling cargo.
You can pause the script at any time by entering 'cargoauto'. You can clear the script and restart by
entering 'cargoclear'. Note: to clear your saved cargo ship list, enter 'cargoshipclear'.
Example 2:
We want to use four cargo ships: YG-4210 Transport 'GGCargo1'
                                 YG-4210 Transport 'GGCargo2'
                                 YG-4210 Transport 'GGCargo3'
                                 Praetor-Class Frigate 'GGFrigate'
                                 
We must create a 'cargo ship profile' for each ship and define necessary info 
about them.
Step 1:
'cargoShipProfileSetup'          - Prompt for information about first cargo ship.
                           In this example it will be: ship name - 'GGCargo1'
                                                       ship type - 'YG-4210 Transport'
                                                       ship size - '5'
                                dirs from hatch to pilot's chair - 'e;u;n'
                                dirs from pilot's chair to hatch - 's;d;w'
                             dirs from pilot's chair to nav room - ''
                             dirs from nav room to pilot's chair - ''
                                  number of hangars on this ship - '0'
Step 2:
'cargoShipProfileSave'            - Save working cargo ship profile 'GGCargo1' into cargo ship database.
                                    Note that unlike the previous example where we used 'push'
                                    this time we used 'save' to retain the working cargo ship
                                    profile to make creating multiple profiles easier.
Step 3:
'cargoShipProfileName GGCargo2'   - Change the working cargo ship profile name to match the next
                                    ship while retaining all the other info between shared ship
                                    types.
Step 4:
'cargoShipProfileSave'            - Save cargo ship profile 'GGCargo2' while retaining info.
Step 5:
'cargoShipProfileName GGCargo3'   - Change working cargo ship profile name again, retain other info.
Step 6:
'cargoShipProfilePush'            - Save cargo ship profile 'GGCargo3' and push it out of the working profile.
Step 7:
'cargoShipProfileSetup'           - Prompt for information about last cargo ship.
                           In this example it will be: ship name - 'GGFrigate'
                                                       ship type - 'Praetor-Class Frigate'
                                                       ship size - '35'
                                dirs from hatch to pilot's chair - 'n;4;n'
                                dirs from pilot's chair to hatch - 's;s;1'
                             dirs from pilot's chair to nav room - 'u'
                             dirs from nav room to pilot's chair - 'd'
                                  number of hangars on this ship - '2'
                                            capacity of hangar 1 - '5'
                                dirs from pilot room to hangar 1 - 's;s;3;s;s;s'
                                     dirs from hangar 1 to hatch - 'n;n;n;n;1'
                                            capacity of hangar 2 - '10'
                                dirs from pilot room to hangar 2 - 's;s;3;s;s;u;s'
                                     dirs from hangar 2 to hatch - 'n;d;n;n;n;1'
                                     
Step 8:
'cargoShipProfilePush'            - Save cargo ship profile 'GGFrigate' and push it out of working profile.
Step 9:
'cargoShipAdd GGFrigate'    - This command will load the saved 'cargo ship profile' matching
                              'GGFrigate' into the 'cargo ship list'. The 'cargo ship list' is
                              where we define our desired cargo ship structure. With this usage
                              ship 'GGFrigate' gets added to the list as a single parent with no
                              children.
Step 10:
'cargoShipAdd GGCargo1 GGFrigate 1'  - This command will load the saved 'cargo ship profile' matching
                                       'GGCargo1' into the 'cargo ship list' as a child of 'GGFrigate'
                                       into the first hangar bay.
Step 11:
'cargoShipAdd GGCargo2 GGFrigate'    - This command will load the saved 'cargo ship profile' matching
                                       'GGCargo2' into the 'cargo ship list' as a child of 'GGFrigate'
                                       into the first available hangar bay, in this case bay 2.
                                      
Step 12:
'cargoShipAdd GGCargo3 GGFrigate 2'  - This command will load the saved 'cargo ship profile' matching
                                       'GGCargo3' into the 'cargo ship list' as a child of 'GGFrigate'
                                       into the second hangar bay. Both hangar bays are now filled and
                                       and further attempts to add child ships will fail.
Step 13:
'cargoSetup'                - This command will prompt for the needed cargo planet information,
                              including planet name, resource to be bought, and trafficking 
                              preference for that planet.
    - or -
'cargoPlanets <planet1>,<resource1>,<trafficking>,<planet2>,<resource2>,<trafficking>,...'
                             - Instead of prompting for the cargo planet information this command
                               can be used to quickly define a cargo running route. Note: you can 
                               use 'none' in any of your cargo legs to skip buying cargo from that 
                               world. This can be used to automate flying a ship from world to world
                               without cargo pods, for training piloting or when making many short 
                               jumps in a public taxi, for instance.
Step 14:
'cargoStart'                 - This command will begin a cargo session by scanning current cargo
                               manifests of all cargo ships and selling off unwanted resources while
                               buying the necessary ones. Note: if the planet you are on doesn't deal
                               in the resources you have aboard, you'll have to find a planet that does,
                               or jettison some cargo into space. Note note: This command must be used
                               while standing outside your ship on the first world in your cargoPlanets list.
Step 15:
That's it! If everything was set up correctly the plugin should fly between worlds buying and selling cargo.
You can pause the script at any time by entering 'cargoauto'. You can clear the script and restart by
entering 'cargoclear'. Note: to clear your saved cargo ship list, enter 'cargoshipclear'.
More info on all plugin commands can be found using 'cargohelp'.
Initial contraband features added by @Domovoi.
  ]]> 
  </description>
  </plugin>
<!--   Get our standard constants   --> 
  <include name="constants.lua" /> 
<!--   Triggers    --> 
<triggers>
	<!-- Planet and System Capture Triggers -->
	<trigger name="cargoSystemCapture" script="storeSystem" match="^(.*)\( (.*)\, (.*) \)$" enabled="n" regexp="y" group="SystemCap" omit_from_log="y" omit_from_output="y" sequence="100" />
	<trigger name="cargoStarsFailed" script="toggleSystemCapOff" match="^You must hold a datapad to do this\.$" enabled="n" regexp="y" group="SystemCap" sequence="100" />
	<trigger name="cargoSystemCapDone" script="scanNext" match="^Displayed (.*) starsystems.$" regexp="y" enabled="n" group="SystemCap" omit_from_log="y" omit_from_output="y" sequence="100" />
	<!--trigger name="cargoBodyCapTitle" script="cleanUp" match="Planet*Starsystem*Governed By*Notices" enabled="n" group="BodyCap" omit_from_log="n" omit_from_output="n" sequence="100" -->
	<trigger name="cargoBodyCapture" script="storeBody" match="^(.*) (.*)$" regexp="y" enabled="n" group="BodyCap" keep_evaluating="true" omit_from_log="y" omit_from_output="y" sequence="100" />
  <trigger name="cargoBodyCapDone" script="scanNext" match="^Use SHOWPLANET( \<planet\>)? for more information.$" regexp="y" enabled="n" group="BodyCap" omit_from_log="y" omit_from_output="y" sequence="100" />
  <trigger name="cargoPriceOverlay" script="overlayPrice" match="^(?P<type>.*) \( Price per unit: (?P<price>.*)\)$" regexp="y" enabled="y" group="LotJCargoOverlay" omit_from_log="y" omit_from_output="y" sequence="100" />

	<!-- Resource Capture Triggers -->
	<trigger enabled="n" group="ResourceStart" match="^You use the datapad to lookup the information\.$" name="ShowplanetSuccess" script="showplanetSuccess" regexp="y" omit_from_log="y" omit_from_output="y" sequence="100" />
	<trigger enabled="n" group="ResourceStart" match="^No such planet\.$" name="ShowplanetFailure" script="showplanetFailure" regexp="y" omit_from_log="y" omit_from_output="y" sequence="100" /> 
	<trigger enabled="n" group="ResourceCap" match="^Planet\: (.*)$" name="storeTempPlanet" script="storeTempPlanet" regexp="y" omit_from_log="y" omit_from_output="y" sequence="100" />
	<trigger enabled="n" group="ResourceCap" match="^Starsystem\: (.*)$" name="SystemCap" script="storeTempSystem" regexp="y" omit_from_log="y" omit_from_output="y" sequence="100" />
	<trigger enabled="n" group="ResourceCap" match="^Coordinates\: (.*) (.*) (.*)$" name="CoordCap" script="storeCoords" regexp="y" omit_from_log="y" omit_from_output="y" sequence="100" />
	<trigger enabled="n" group="ResourceCap" match="^(.*) \( Price per unit\: (.*) ?\)$" name="ResourceCap" script="storeResource" regexp="y" omit_from_log="y" omit_from_output="y" sequence="100" />
	<trigger enabled="n" group="ResourceCap" match="^Tax Rate\: (.*)\%$" name="TaxCap" script="storeTax" regexp="y" omit_from_log="y" omit_from_output="y" sequence="100" />
	<trigger enabled="n" group="GagAll" match="^(.*)$" name="GagAll" regexp="y" keep_evaluating="y" omit_from_log="y" omit_from_output="y" sequence="100" />
  <trigger enabled="n" group="ResourceCap" match="^Use \'SHOWPLANET \<planet\> RESOURCES\' for current resources\.$" name="ResourceCoordEnd" regexp="y" omit_from_log="y" omit_from_output="y" script="resourceEnd" sequence="100" />
	<trigger enabled="n" group="ResourceCap" match="^Show what to whom\?$" regexp="y" name="resourceCapEnd" script="resourceEnd" omit_from_log="n" omit_from_output="y" sequence="100" />

  <!-- planet retrieval triggers -->
  <trigger match="^(.*)$" group="RetrievePlanet" regexp="y" keep_evaluating="y" omit_from_log="y" omit_from_output="y" sequence="100" />
  <trigger match="^Usage\: showplanet \<planet\>$" script="retrievePlanetFailed" regexp="y" enabled="n" group="RetrievePlanet" sequence="100" />
    <trigger match="--Planet Data: --([-]+)\nPlanet: (?P<planet>.*)\Z" script="storePlanet" regexp="y" enabled="n" multi_line="y" lines_to_match="2" omit_from_log="y" omit_from_output="y" group="RetrievePlanet" sequence="100" />
  <trigger match="^Use \'SHOWPLANET \<planet\> RESOURCES\' for current resources\.$" script="updateListPosition" regexp="y" enabled="n" group="RetrievePlanet" sequence="100" />
  <trigger match="^No such planet.$" script="retrievePlanetFailed" regexp="y" enabled="n" group="RetrievePlanet" sequence="100" />
  
	<!-- Automatic cargo triggers -->
	<trigger name="tradeCargo" script="leftShip" match="^You exit the ship\.$" enabled="n" regexp="y" group="AutoCargo" sequence="100" />
  <!--trigger name="soldcargo" script="soldCargo" match="^You sell (?P<quantity>.*) units of (?P<resource>.*) for (?P<credits>.*) credits\.$" enabled="n" regexp="y" group="AutoCargo" sequence="100" -->
  <trigger name="soldCargo" script="soldCargo" 
    match="^You sell (?P<quantity>.*) units of (?P<resource>.*) for (?P<credits>.*) credits\.\nTotal profit, accounting for purchase price: (?P<profit>.*). Tax paid: (?P<tax>.*).\Z"
    enabled="n"
    regexp="y"
    group="AutoCargo"
    multi_line="y"
    lines_to_match="2"
    sequence="100" />
	<trigger name="earnedmoney" script="gainMoney" match="^You earned (.*) credits from the sale and pay (.*) in taxes\.$" enabled="n" regexp="y" group="AutoCargo" sequence="100" />
	<trigger name="waitSell" script="waitSell" match="^The planet\'s funds can\'t support such a sale\!$" enabled="n" regexp="y" group="AutoCargo" sequence="100" />
  <trigger name="boughtcargo" script="boughtCargo" match="^You purchased (?P<quantity>.*) units of (?P<resource>.*) for (?P<credits>.*) credits\.$" enabled="n" regexp="y" group="AutoCargo" sequence="100" />
	<trigger name="lostmoney" script="loseMoney" match="^It cost you (.*) credits total\, (.*) credits in tax\.$" enabled="n" regexp="y" group="AutoCargo" sequence="100" />
	<trigger name="jumpCompleteTrigger" match="^Hyperjump complete\.$" script="jumpComplete" group="AutoCargo" enabled="n" regexp="y" sequence="100" />
	<trigger name="badsale" script="errorSelling" match="^You\'re not carrying any of the resource onboard\!$" group="AutoCargo" enabled="n" regexp="y" sequence="100" />
  <trigger name="contrasellsuccess" script="soldCargo" match="^You find a contact willing to pay (?P<credits>.*) credits to unload (?P<quantity>.*) units of smuggled (?P<resource>.*)\.$" group="AutoCargo" enabled="n" regexp="y" sequence="100" />
  <trigger name="contrabuysuccess" script="boughtCargo" match="^You pay (?P<credits>.*) credits to have (?P<quantity>.*) units of smuggled (?P<resource>.*) loaded on to your ship\.$" group="AutoCargo" enabled="n" regexp="y" sequence="100" />
  <trigger name="contrasellfail" script="contraSellFailed" match="^You fail\.\nYou lose your cargo\!\Z" lines_to_match="2" multi_line="y" group="AutoCargo" enabled="n" regexp="y" sequence="100" />
  <trigger name="contrabuyfail" script="contraBuyFailed" match="^You fail\.\nYou lose your credits\!\Z" lines_to_match="2" multi_line="y" group="AutoCargo" enabled="n" regexp="y" sequence="100" />

  
	<!-- Ship manifest triggers -->
  <trigger name="beginShipManifest" script="enableShipManifest" match="^Cargo Readout for (.*)\:$" group="ManifestStart" enabled="n" regexp="y" sequence="100" />
  <trigger name="errorwithmanifest" script="errorShipManifest" match="^Only the owner\/pilot\/copilot may view the cargo for that ship\!$" group="ManifestStart" enabled="n" regexp="y" sequence="100" />
  <trigger name="shipnotfound" script="errorShipManifest" match="^You can\'t find that ship here\!$" group="ManifestStart" enabled="n" regexp="y" sequence="100" />
  <trigger name="storeCargoPodTrig" script="storeCargoPod" match="^\[(\d+\s+)\] \[(.*)\] \[(\d+)\/(\d+\s+)\]$" group="Manifest" enabled="n" regexp="y" sequence="100" />
  <trigger name="endShipManifest" script="disableShipManifest" match="^$" group="Manifest" enabled="n" regexp="y" sequence="100" />
  <trigger name="nopodsfound" script="disableShipManifest" match="^This ship has absolutely no cargo containers\!$" group="ManifestStart" enabled="n" regexp="y" sequence="100" />
</triggers>

<aliases>
	<!-- Capture Aliases -->
	<alias name="populateTable" script="scanNext" match="^cargoscan$" enabled="y" regexp="y" ignore_case="y" group="LotJCargo" sequence="100" />
	<alias name="listsystems" script="listSystems" match="listsystems" enabled="y" ignore_case="y" group="LotJCargo" sequence="100" />
	<alias name="cargoBestRoute" script="find_the_best" match="^cargobest(\s+(.*))?$" enabled="y" ignore_case="y" regexp="y" group="LotJCargo" sequence="100" />
	<alias name="cargoBestRouteOld" script="cargoBestRoute" match="^cargobestold(\s+(.*))?$" enabled="y" ignore_case="y" regexp="y" group="LotJCargo" sequence="100" />
  <alias name="cargoPrintRoutes" script="printAllRoutes" match="^cargoprintroutes(\s*(?P<sorted>.*))?$" enabled="y" ignore_case="y" regexp="y" group="LotJCargo" sequence="100" />
	<alias name="Cargosetup" script="cargoSetup" match="^cargosetup$" enabled="y" ignore_case="y" regexp="y" group="LotJCargo" sequence="100" />
	<alias name="cargoHelp" script="cargoHelp" match="^cargohelp(\s*(.*))?$" enabled="y" regexp="y" ignore_case="y" group="LotJCargo" sequence="100" />
	<alias name="cargoStart" script="retrievePlanet" match="^cargostart(\s*(.*))?" enabled="y" regexp="y" ignore_case="y" group="LotJCargo" sequence="100" />
	<alias name="CargoAuto" match="^cargoauto( +(.*))?$" script="cargoAuto" enabled="y" regexp="y" group="LotJCargo" ignore_case="y" sequence="100" />
	<alias name="CargoList" script="cargoList" match="cargoList" enabled="y" group="LotJCargo" send_to="1" ignore_case="y" sequence="100" />
	<alias name="CargoClear" script="cargoClear" match="cargoclear" enabled="y" group="LotJCargo" ignore_case="y" send_to="1" sequence="100" />
	<alias name="Cargoefficiency" script="displayEfficiency" match="cargoefficiency" enabled="y" group="LotJCargo" ignore_case="y" sequence="100" />
	<alias name="CargoCycle" script="toggleCycle" match="cargocycle" enabled="y" group="LotJCargo" ignore_case="y" sequence="100" />
	<alias name="cargosetupplanetcmd" script="cargoSetupPlanets" match="^cargoplanets(\s*(.*))?$" enabled="y" regexp="y" group="LotJCargo" ignore_case="y" sequence="100" />
	<alias name="cargosetupshipcmd" script="cargoSetupShipName" match="cargoship *" enabled="y" group="LotJCargo" ignore_case="y" sequence="100" />
	<alias name="cargomanifestcmd" script="cargoManifest" match="cargomanifest" enabled="y" group="LotJCargo" ignore_case="y" sequence="100" />
  <alias match="^cargoManifestClear(.*?)?$" script="doClearCargo" enabled="y" group="LotJCargo" ignore_case="y" regexp="y" sequence="100" />
  <alias script="flyNext" match="cargonext" enabled="y" group="LotJCargo" ignore_case="y" sequence="100" />
  <alias match="^cargoShipProfileList(.*?)?$" script="shipProfileList" enabled="y" group="LotJCargo" ignore_case="y" regexp="y" sequence="100" />
  <alias match="^cargoShipProfileName(.*?)?$" script="shipProfileName" enabled="y" group="LotJCargo" ignore_case="y" regexp="y" sequence="100" />
  <alias match="^cargoShipProfileSetup(.*?)?$" script="shipProfileSetup" enabled="y" group="LotJCargo" ignore_case="y" regexp="y" sequence="100" />
  <alias match="^cargoShipProfileClear(.*?)?$" script="shipProfileClear" enabled="y" group="LotJCargo" ignore_case="y" regexp="y" sequence="100" />
  <alias match="^cargoShipProfileLoad(.*?)?$" script="shipProfileLoad" enabled="y" group="LotJCargo" ignore_case="y" regexp="y" sequence="100" />
  <alias match="^cargoShipProfileSave(.*?)?$" script="shipProfileSave" enabled="y" group="LotJCargo" ignore_case="y" regexp="y" sequence="100" />
  <alias match="^cargoShipProfilePush(.*?)?$" script="shipProfilePush" enabled="y" group="LotJCargo" ignore_case="y" regexp="y" sequence="100" />
  <alias match="^cargoShipDBList(.*?)?$" script="shipDBList" enabled="y" group="LotJCargo" ignore_case="y" regexp="y" sequence="100" />
  <alias match="^cargoShipDBRem(.*?)?$" script="shipDBRem" enabled="y" group="LotJCargo" ignore_case="y" regexp="y" sequence="100" />
  <alias match="^cargoShipDBClear(.*?)?$" script="shipDBClear" enabled="y" group="LotJCargo" ignore_case="y" regexp="y" sequence="100" />
  <alias match="^cargoShipDBRename(.*?)?$" script="shipDBRename" enabled="y" group="LotJCargo" ignore_case="y" regexp="y" sequence="100" />
  <alias match="^cargoShipList$" script="shipCargoList" enabled="y" group="LotJCargo" ignore_case="y" regexp="y" sequence="100" />
  <alias match="^cargoShipAdd(.*?)?$" script="shipCargoAdd" enabled="y" group="LotJCargo" ignore_case="y" regexp="y" sequence="100" />
  <alias match="^cargoShipRem(.*?)?$" script="shipCargoRem" enabled="y" group="LotJCargo" ignore_case="y" regexp="y" sequence="100" />
  <alias match="^cargoShipClear?$" script="shipCargoClear" enabled="y" group="LotJCargo" ignore_case="y" regexp="y" sequence="100" />
  <alias match="^cargoLoadShips$" script="loadShips" enabled="y" group="LotJCargo" ignore_case="y" regexp="y" sequence="100" />
  <alias match="^cargoUnloadShips$" script="unloadShips" enabled="y" group="LotJCargo" ignore_case="y" regexp="y" sequence="100" />
  <alias match="^cargoCloseBays$" script="toggleCloseBays" enabled="y" group="LotJCargo" ignore_case="y" regexp="y" sequence="100" />
  <alias match="^cargoTransactions$" script="printTransactions" enabled="y" group="LotJCargo" ignore_case="y" regexp="y" sequence="100" />
  <alias match="^cargoTransactionsClear$" script="clearTransactions" enabled="y" group="LotJCargo" ignore_case="y" regexp="y" sequence="100" />

</aliases>
<timers>
	<timer name="EfficiencyTimer" script="displayEfficiency" enabled="n" minute="5" group="AutoCargo" />
</timers>
<!--   Script    --> 
<script>
<![CDATA[
require "tprint"
require "commas"
require "serialize"
require "copytable"
local AUTHOR = GetPluginInfo(GetPluginID(), 2) -- author info
local VERSION = string.format("%1.2f", GetPluginInfo(GetPluginID(), 19)) -- version info

  -- require MSDP Helper module
  dofile(GetPluginInfo(GetPluginID(), 20) .. "LotJMSDPHelper.lua")

local tempPlanet = ""
local tempSystem = ""
local scanned = "none"
local percent = 0
local numBodies = 0
local autoCargo = false

local cVar = 0
local shipnum = 0
local closeBays = true
shipProfile = {}
local startTime = 0
local amountEarned = 0
local cycle = true
local tradingCompleted = false
local hyperCompleted = false
local scannedCargo = false
local lastsoldamount = 0
local lastsoldresource = ""
local lastboughtamount = 0
systems = {}
cPlanets = {}
ships = {}
shipdb = {}
transactions = {}
routes = {}
planet = ""
local darkblue = RGBColourToName(GetNormalColour(5))
local gray = RGBColourToName(GetBoldColour(1))
local cyan = RGBColourToName(GetBoldColour(7))
-- Activate some settings to ensure proper functioning
--SetOption("enable_aliases", true)
--SetOption("enable_timers", true)
--SetOption("enable_triggers", true)
--SetOption("enable_scripts", true)

function runDirs(dirs)
  dirs = splitBy(dirs, ",")
  dirs = splitBy(dirs, " ")
  dirs = splitBy(dirs, ";")
  dirs = splitBy(dirs, "|")
  for i, v in ipairs(dirs) do
    if v:lower() ~= "none" then
      Send(v)
    end
  end
end

function splitBy(str, delim)
  local ret = {}
  if type(str) == "string" then
    return utils.split(str, delim)
  elseif type(str) == "table" then
    for i, v in ipairs(str) do
      for k, j in ipairs(utils.split(v, delim)) do
        ret[#ret+1] = j
      end
    end
    return ret
  end
end

function toggleCloseBays(name, line, args)
  closeBays = not closeBays
  ColourNote("yellow","","Automatic closing and opening of hangar bays is "..((closeBays and "ON") or "OFF")..".")
  if not closeBays then
    ColourNote("red","","Disclaimer: It is potentially unsafe to leave hangars open, ensure you are willing to accept the risk!")
  end
end
toUnload = {}

function unloadShips(name, line, args)
  for i, v in ipairs(ships) do
    toUnload[#toUnload + 1] = v
  end
  while #toUnload > 0 do
    unloadNext(toUnload[1])
  end
end

function unloadNext(ship)
  if shipContainsChildren(ship) then
    Send("openhatch "..ship.name)
    Send("board "..ship.name)
    Send("closehatch")
    runDirs(ship.dirs["hatchtopilot"])
    Send("autopilot off")
    Send("openbay all")
    Send("autopilot on")
    for i, v in ipairs(ship.hangars or {}) do
      if hangarContainsChildren(v) then
        runDirs(v["pilottohangar"])
        for k, j in ipairs(v.ships or {}) do
          toUnload[#toUnload + 1] = j
          Send("unloadship "..j.name)
        end
        runDirs(v["hangartohatch"])
        runDirs(ship.dirs["hatchtopilot"])
      end
    end
    Send("autopilot off")
    Send("closebay all")
    Send("autopilot on")
    runDirs(ship.dirs["pilottohatch"])
    Send("openhatch")
    Send("leaveship")
    Send("closehatch "..ship.name)
  end
  table.remove(toUnload, 1)
end

function shipContainsChildren(ship)
  for i, v in ipairs(ship.hangars or {}) do
    if v.ships and #v.ships > 0 then
      return true
    end
  end
  return false
end
 
function hangarContainsChildren(hangar)
  if hangar.ships and #hangar.ships > 0 then
    return true
  else
    return false
  end
end

toLoad = {}

function loadShips(name, line, args)
  for i=getNumCargoShips(), 1, -1 do
    toLoad[#toLoad + 1] = getShip(i)
  end
  while #toLoad > 0 do
    loadNext(toLoad[1])
  end
end

function loadNext(ship)
  if shipContainsChildren(ship) then
    Send("openhatch "..ship.name)
    Send("enter "..ship.name)
    Send("closehatch")
    runDirs(ship.dirs["hatchtopilot"])
    Send("autopilot off")
    Send("openbay all")
    Send("autopilot on")
    runDirs(ship.dirs["pilottohatch"])
    Send("openhatch")
    Send("leaveship")
    Send("closehatch "..ship.name)
    for i, v in ipairs(ship.hangars or {}) do
      if hangarContainsChildren(v) then
        for k, j in ipairs(v.ships or {}) do
          Send("loadship \""..j.name.."\" \""..ship.name.."\" "..i)
        end
      end
    end
    Send("openhatch "..ship.name)
    Send("enter "..ship.name)
    Send("closehatch")
    runDirs(ship.dirs["hatchtopilot"])
    Send("autopilot off")
    Send("closebay all")
    Send("autopilot on")
    runDirs(ship.dirs["pilottohatch"])
    Send("openhatch")
    Send("leaveship")
    Send("closehatch "..ship.name)
  end
  table.remove(toLoad, 1)
end

function shipCargoClear(name, line, args)
  ships = {}
  ColourNote("yellow","","Cargo ship list cleared.")
end

function shipCargoRem(name, line, args)
  args = utils.split(Trim(args[1]), " ")
  if #args > 0 then -- user input 1 argument
    ColourNote("red","","Currently disabled, use shipCargoClear instead!")
  else
    ColourNote("red","","Usage: shipCargoRem <ship>")
    return
  end
end

function shipCargoAdd(name, line, args)
  args = utils.split(Trim(args[1]), " ")
  if #args > 0 then -- user input 1 word
    if #args > 1 then -- user input 2 words
      if #args > 2 then -- user input 3 words
        if args[1] and args[2] and not tonumber(args[2]) and tonumber(args[3]) then -- this is correct format, 'shipcargoadd child parent hangar'
          local child = args[1]
          local parent = args[2]
          local hangar = tonumber(args[3])
          internalAddCargoShip(child, parent, hangar)
        else
          ColourNote("red","","Usage: shipCargoAdd <child> <parent> <hangar>")
        end
        return
      end
      -- 2 arguments
      if args[1] and args[2] and not tonumber(args[2]) then -- format 'shipcargoadd child parent'
        local child = args[1]
        local parent = args[2]
        internalAddCargoShip(child, parent)
      else
        ColourNote("red","","Usage: shipCargoAdd <child> <parent> <hangar>")
      end
      return
    end
    -- 1 argument
    if args[1]~="" then -- format 'shipcargoadd child'
      local child = args[1]
      internalAddCargoShip(child)
    else
      ColourNote("red","","Usage: shipCargoAdd <child> <parent> <hangar>")
    end
    return
  end
end

function internalAddCargoShip(child, parent, hangar)
  childShip = ""
  parentShip = ""
  if child then -- child supplied, find it in the shipdb list
    local childFound = false
    for i, v in ipairs(shipdb) do
      if v.name:lower():find(child:lower()) or v.type:lower():find(child:lower()) or (tonumber(child) and tonumber(child) == i) then -- found matching ship
        childShip = v
        --ColourNote("yellow","","Child ship '"..v.name.."' found in shipdb.")
        childFound = true
        break
      end
    end
    if not childFound then
      ColourNote("red","","Child ship '"..child.."' not found in shipdb.")
      return
    end
    if parent then -- parent supplied, find it in the current ship list
      local parentFound = false
      for i, v in ipairs(ships) do
        parentShip = checkShip(v, parent)
        if parentShip then
          --ColourNote("yellow","","Parent ship '"..parentShip.name.."' found in ship list.")
          parentFound = true
          break
        end
      end
      if not parentFound then
        ColourNote("red","","Parent ship '"..parent.."' not found in ship list.")
        return
      end
      if hangar and tonumber(hangar)>0 then
        parentShip.hangars = parentShip.hangars or {}
        if tonumber(hangar) > #parentShip.hangars then -- supplied hangar number is greater than parent possesses
          ColourNote("red","","Parent '"..parentShip.name.."' doesn't have that many hangars.")
          return
        else -- valid hangar, check if there is space
          local spaceLeft = getHangarLeft(parentShip.hangars[tonumber(hangar)])
          if tonumber(childShip.size) <= spaceLeft then -- we have room in this hangar
            local ships = parentShip.hangars[tonumber(hangar)].ships or {}
            ships[#ships + 1] = copytable.deep(childShip)
            parentShip.hangars[tonumber(hangar)].ships = copytable.deep(ships)
            ColourNote("yellow","","Child ship '"..childShip.name.."' added to parent ship '"..parentShip.name.."' hangar "..tonumber(hangar)..".")
          else
            ColourNote("red","","Child ship '"..childShip.name.."' won't fit into parent ship '"..parentShip.name.."' hangar "..tonumber(hangar)..".")
          end
        end
      else -- no hangar provided, put child in the first hangar it will fit
        local childFits = false
        parentShip.hangars = parentShip.hangars or {}
        for i, v in ipairs(parentShip.hangars) do
          v.ships = v.ships or {}
          local spaceLeft = getHangarLeft(v)
          if tonumber(childShip.size) <= spaceLeft then -- we have room in this hangar
            v.ships[#v.ships + 1] = copytable.deep(childShip)
            ColourNote("yellow","","Child ship '"..childShip.name.."' added to parent ship '"..parentShip.name.."' hangar "..i..".")
            childFits = true
            break
          end
        end
        if not childFits then
          ColourNote("red","","Child ship '"..childShip.name.."' won't fit into parent ship '"..parentShip.name.."'.")
          return
        end
      end
    else -- no parent entered
      ships[#ships + 1] = copytable.deep(childShip)
      ColourNote("yellow","","Ship '"..childShip.name.."' added to cargo ship list with no parent ship.")
      return
    end
  else
    ColourNote("red","","Error: nothing supplied to internalAddCargoShip()!")
    return
  end
end

function checkShip(ship, search)
  local found = nil
  if ship.name:lower():find(search:lower()) or ship.type:lower():find(search:lower()) then -- found matching ship
    found = ship
  else
    for i, v in ipairs(ship.hangars or {}) do
      for k, j in ipairs(v.ships or {}) do
        found = checkShip(j, search)
        if found then return found end
      end
    end
  end
  return found
end

function shipCargoList(name, line, args)
  ColourNote(gray,"","Current cargo ship list (",cyan,"",getNumCargoShips().." ship"..((getNumCargoShips()~=1 and "s") or ""),gray,"","):")
  for i, v in ipairs(ships) do
    printShip(0, v)
  end
  --tprint(ships)
end

function printShip(indent, ship)
  ColourNote(gray,"",string.rep(" ", indent)..((indent>0 and "|->") or "").."[",cyan,"",((ship.type and ship.type) or "not set").." '"..((ship.name and ship.name) or "not set").."'",gray,"","] [",cyan,"","Size:"..((ship.size and ship.size) or 0),gray,"","] [",cyan,"","Hangars:"..((ship.hangars and #ship.hangars) or 0),gray,"","] (",cyan,"",getTotalHangarUsed(ship),gray,"","/",cyan,"",getTotalHangarCapacity(ship),gray,"",")")
  for i, v in ipairs(ship.hangars or {}) do
    ColourNote(gray,"",string.rep(" ", indent+2).."[Hangar ",cyan,"",i,gray,"","] (",cyan,"",getHangarUsed(v),gray,"","/",cyan,"",v.capacity,gray,"","):")
    for k, j in ipairs(v.ships or {}) do
      printShip(indent+5, j)
    end
  end
end

function getHangarLeft(hangar)
  local cap = tonumber(hangar.capacity)
  for i, v in ipairs(hangar.ships or {}) do
    cap = cap - tonumber(v.size)
  end
  return cap
end

function getHangarUsed(hangar)
  local used = 0
  for i, v in ipairs(hangar.ships or {}) do
    used = used + tonumber(v.size)
  end
  return used
end

function getTotalHangarCapacity(ship)
  local cap = 0
  for i, v in ipairs(ship.hangars or {}) do
    cap = cap + tonumber(v.capacity)
  end
  return cap
end

function getTotalHangarLeft(ship)
  local cap = getHangarCapacity(ship)
  for i, v in ipairs(ship.hangars or {}) do
    for k, j in ipairs(v.ships or {}) do
      cap = cap - tonumber(j.size)
    end
  end
  return cap
end

function getTotalHangarUsed(ship)
  local used = 0
  for i, v in ipairs(ship.hangars or {}) do
    for j, j in ipairs(v.ships or {}) do
      used = used + tonumber(j.size)
    end
  end
  return used
end

function getNumCargoShips()
  local count = 0
  for i, v in ipairs(ships) do
    count = count + countShip(v)
  end
  return count
end

function countShip(ship)
  local count = 1
  for i, v in ipairs(ship.hangars or {}) do
    for j, k in ipairs(v.ships or {}) do
      count = count + countShip(k)
    end
  end
  return count
end

function getShip(num)
  local num = num or shipnum
  local count = 0
  for i, v in ipairs(ships or {}) do
    ship, count = checkInsideShip(v, count, num)
    if ship then 
      return ship 
    end
  end
end

function checkInsideShip(ship, iCount, iNum)
  local found = nil
  iCount = iCount + 1
  if iCount == iNum then -- found matching ship
    found = ship
  else
    for i, v in ipairs(ship.hangars or {}) do
      for k, j in ipairs(v.ships or {}) do
        found, iCount = checkInsideShip(j, iCount, iNum)
        if found then 
          return found, iCount
        end
      end
    end
  end
  return found, iCount
end

function shipProfileList(name, line, args)
  args = utils.split(Trim(args[1]), " ")
  local v = shipProfile
  ColourNote(gray,"","Current working ship profile: ")
  ColourNote(gray,"","[",cyan,"",((v.type and v.type) or "not set").." '"..((v.name and v.name) or "not set").."'",gray,"","] [",cyan,"","Hangars: "..((v.hangars and #v.hangars) or 0),gray,"","] [",cyan,"","Size: "..((v.size and v.size) or "not set"),gray,"","] [",cyan,"","Dirs: ",((checkShipDirs(v) and "lime") or "red"),"",((checkShipDirs(v) and "set") or "not set"),gray,"","]")
  ColourNote(gray,"","[Dirs:]")
  for k, j in pairs(v.dirs or {}) do
    ColourNote(gray,"","  [",cyan,"",k..":".."'"..j.."'",gray,"","]")
  end
  if v.hangars and #v.hangars > 0 then
    ColourNote(gray,"","[Hangar Dirs:]")
    for k, j in ipairs(v.hangars or {}) do
      ColourNote(gray,"","  [",cyan,"","Hangar "..k,gray,"","]")
      ColourNote(gray,"","    [",cyan,"","pilottohangar:'"..((j["pilottohangar"] and j["pilottohangar"]) or "none").."'",gray,"","]")
      ColourNote(gray,"","    [",cyan,"","hangartohatch:"..((j["hangartohatch"] and j["hangartohatch"]) or "none").."'",gray,"","]")
    end
  end
  --tprint(shipProfile)
end

function shipProfileName(name, line, args)
  args = utils.split(Trim(args[1]), " ")
  if args[1] ~= "" then -- user input something
    shipProfile.name = args[1]
  else -- user input nothing, erase name
    shipProfile.name = nil
  end
  ColourNote("yellow", "", "Ship profile name set to "..((shipProfile.name and shipProfile.name) or "nil")..".")
end

function shipProfileSetup(name, line, args)
  shipProfile.name = utils.inputbox("Enter ship name for this profile", "Ship name", shipProfile.name or "profile1", GetInfo(23), GetInfo(215))
  shipProfile.type = utils.inputbox("Enter ship type (i.e. YG-4210 Transport, YT-1300 Light Freighter , etc)", "Ship type", shipProfile.type or "YG-1300", GetInfo(23), GetInfo(215))
  shipProfile.size = utils.inputbox("Enter ship size number (i.e. how many slots this ship takes up in a hangar via help shipsize)", "Ship size", shipProfile.size or "10", GetInfo(23), GetInfo(215))
  if not shipProfile.dirs then
    shipProfile.dirs = {}
  end
  shipProfile.dirs["hatchtopilot"] = utils.inputbox("Enter dirs from hatch to pilot room", "Hatch to pilot dirs", shipProfile.dirs["hatchtopilot"] or "",  GetInfo(23), GetInfo(215))
  shipProfile.dirs["pilottohatch"] = utils.inputbox("Enter dirs from pilot room to hatch", "Pilot to hatch dirs", shipProfile.dirs["pilottohatch"] or "",  GetInfo(23), GetInfo(215))
  shipProfile.dirs["pilottonav"] = utils.inputbox("Enter dirs from pilot room to nav room", "Pilot to nav dirs", shipProfile.dirs["pilottonav"] or "",  GetInfo(23), GetInfo(215))
  shipProfile.dirs["navtopilot"] = utils.inputbox("Enter dirs from nav room to pilot room", "Nav to pilot dirs", shipProfile.dirs["navtopilot"] or "",  GetInfo(23), GetInfo(215))
  local numhangars = utils.inputbox("Enter number of hangars on this ship", "Number of hangars", ((shipProfile.hangars and #shipProfile.hangars) or ""),  GetInfo(23), GetInfo(215))
  if tonumber(numhangars) then
    if not shipProfile.hangars then
      shipProfile.hangars = {}
    end
    local hangar = {}
    for i=1, tonumber(numhangars), 1 do
      if shipProfile.hangars[i] then
        hangar = copytable.deep(shipProfile.hangars[i])
      end
      hangar["capacity"] = utils.inputbox("Enter capacity of hangar "..i, "Capacity of hangar "..i, hangar["capacity"] or "", GetInfo(23), GetInfo(215))
      hangar["pilottohangar"] = utils.inputbox("Enter dirs from pilot room to hangar "..i, "Pilot to hangar "..i, hangar["pilottohangar"] or "",  GetInfo(23), GetInfo(215))
      hangar["hangartohatch"] = utils.inputbox("Enter dirs from hangar "..i.." to hatch.", "Hangar "..i.." to hatch", hangar["hangartohatch"] or "",  GetInfo(23), GetInfo(215))
      shipProfile.hangars[i] = copytable.deep(hangar)
      hangar = {}
    end
  end
end

function shipProfileClear(name, line, args)
  args = utils.split(Trim(args[1]), " ")
  shipProfile = {}
  ColourNote("yellow","","Ship profile cleared.")
end

function shipProfileLoad(name, line, args)
  args = utils.split(Trim(args[1]), " ")
  if args[1] ~= "" then -- user input something
    for i, v in ipairs(shipdb) do
      if v.name:lower():find(args[1]:lower()) or v.type:lower():find(args[1]:lower()) or (tonumber(args[1]) and tonumber(args[1]) == i) then -- found matching ship
        shipProfile = copytable.deep(v)
        ColourNote("yellow","","Matching ship '"..v.name.."' found in shipdb, loaded into ship profile.")
        return
      end
    end
    ColourNote("red","","Ship '"..args[1].."' not found in shipdb.")
  else -- user input nothing, print usage
    ColourNote("red","","Usage: shipProfileLoad <name/#>")
  end
end

function shipProfileSave(name, line, args)
  args = utils.split(Trim(args[1]), " ")
  if shipProfile.name and shipProfile.type then
    shipdb[#shipdb + 1] = copytable.deep(shipProfile)
    ColourNote("yellow","","Current profile '"..shipdb[#shipdb].name.."' saved to ship db.")
  else -- don't have a name or type, error out
    ColourNote("red","","Current ship profile is missing name or type.")
  end
end
-- push does the same thing as save except it also clears the current profile after pushing onto the list

function shipProfilePush(name, line, args)
  args = utils.split(Trim(args[1]), " ")
  if shipProfile.name and shipProfile.type then
    shipdb[#shipdb + 1] = copytable.deep(shipProfile)
    ColourNote("yellow","","Current profile '"..shipdb[#shipdb].name.."' saved to ship db.")
    shipProfile = {}
  else -- don't have a name or type, error out
    ColourNote("red","","Current ship profile is missing name or type.")
  end
end

function shipDBList(name, line, args)
  args = utils.split(Trim(args[1]), " ")
  local found = false
  local ship = nil
  if args[1] ~= "" then -- user input an argument
    for i, v in ipairs(shipdb) do
      if (tonumber(args[1]) and tonumber(args[1]) == i) or v.name:lower():find(args[1]:lower()) then
        ColourNote(gray,"","Found matching ship '",cyan,"",v.name,gray,"","' in ship db:")
        ColourNote(gray,"","[",cyan,"",string.format("%2d", i),gray,"","] [",cyan,"",v.type.." '"..v.name.."'",gray,"","] [",cyan,"","Hangars: "..((v.hangars and #v.hangars) or 0),gray,"","] [",cyan,"","Size: "..v.size,gray,"","] [",cyan,"","Dirs: ",((checkShipDirs(v) and "lime") or "brightred"),"",((checkShipDirs(v) and "set") or "not set"),gray,"","]")
        ColourNote(gray,"","[Dirs:]")
        for k, j in pairs(v.dirs or {}) do
          ColourNote(gray,"","  [",cyan,"",k..":".."'"..j.."'",gray,"","]")
        end
        if v.hangars and #v.hangars > 0 then
          ColourNote(gray,"","[Hangar Dirs:]")
          for k, j in ipairs(v.hangars) do
            ColourNote(gray,"","  [",cyan,"","Hangar "..k,gray,"","]")
            ColourNote(gray,"","    [",cyan,"","pilottohangar:'"..((j["pilottohangar"] and j["pilottohangar"]) or "none").."'",gray,"","]")
            ColourNote(gray,"","    [",cyan,"","hangartohatch:'"..((j["hangartohatch"] and j["hangartohatch"]) or "none").."'",gray,"","]")
          end
        end
        found = true
        break
      end
    end
  
  else -- no argument
    ColourNote(gray,"","Cargo ship db full ship list: ")
    for i, v in ipairs(shipdb) do
      ColourNote(gray,"","[",cyan,"",string.format("%2d", i),gray,"","] [",cyan,"",v.type.." '"..v.name.."'",gray,"","] [",cyan,"","Hangars: "..((v.hangars and #v.hangars) or 0),gray,"","] [",cyan,"","Size: "..v.size,gray,"","] [",cyan,"","Dirs: ",((checkShipDirs(v) and "lime") or "brightred"),"",((checkShipDirs(v) and "set") or "not set"),gray,"","]")  
    end
    ColourNote(gray,"","Showing ",cyan,"",((shipdb and #shipdb) or 0),gray,""," ship profiles saved total.")
    return
  end
  if not found then
    ColourNote("red","","Ship '"..args[1].."' not found in ship db.")
  end
  --tprint(shipdb)
end

function checkShipDirs(ship)
  local pass = true
  if ship.dirs then
    if not ship.dirs["hatchtopilot"] or not ship.dirs["pilottonav"] or not ship.dirs["hatchtopilot"] or not ship.dirs["navtopilot"] then
      pass = false
    end
  else
    pass = false
  end
  if ship.hangars then
    for i, v in ipairs(ship.hangars) do
      if not v["pilottohangar"] or not v["hangartohatch"] then
        pass = false
      end
    end
  else
    pass = false
  end
  return pass
end

function printDBShip(ship)
  ColourNote(gray,"","[",cyan,"","Num: "..i,gray,"","] [",cyan,"",ship.type.." '"..ship.name.."' ",gray,"","] [",cyan,"","Size: "..ship.size,gray,"","] [",cyan,"","Dirs: ",((checkShipDirs(ship) and "lime") or "brightred"),"",((checkShipDirs(ship) and "set") or "not set"),gray,"","]")  
end

function shipDBRem(name, line, args)
  args = utils.split(Trim(args[1]), " ")
  if args[1] ~= "" then -- user input something
    for i, v in ipairs(shipdb) do
      if v.name:lower():find(args[1]:lower()) or v.type:lower():find(args[1]:lower()) or (tonumber(args[1]) and tonumber(args[1]) == i) then -- found matching ship
        ColourNote("yellow","","Matching ship '"..v.name.."' found in shipdb, deleted.")
        table.remove(shipdb, i)
        OnPluginSaveState()
        return
      end
    end
    ColourNote("red","","Ship '"..args[1].."' not found in shipdb.")
  else -- user input nothing, print usage
    ColourNote("red","","Usage: shipDBRem <name/#>")
  end
end

function shipDBClear(name, line, args)
  args = utils.split(Trim(args[1]), " ")
  shipdb = {}
  ColourNote("yellow","","Ship profile list cleared.")
  OnPluginSaveState()
end

function shipDBRename(name, line, args)
  args = utils.split(Trim(args[1]), " ")
end


function GetPlanetList()
  local list = ""
  for i, v in ipairs(cPlanets) do
    list = list .. ((v.name and v.name) or "")
    if i < #cPlanets then list = list .. ',' end
  end
  return list or ""
end

function OnPluginInstall()
  loadstring(GetVariable("cPlanets") or "")()
  loadstring(GetVariable("ships") or "")()
  loadstring(GetVariable("shipdb") or "")()
  loadstring(GetVariable("transactions") or "")()
  loadstring(GetVariable("routes") or "")()
  loadstring(GetVariable("systems") or "")()

  autoCargo = GetVariable("autoCargo") == "true"
  EnableTriggerGroup("AutoCargo", autoCargo)
  cVar = tonumber(GetVariable("cVar")) or 0
  shipnum = tonumber(GetVariable("shipnum")) or 0
  closeBays = GetVariable("closeBays") == "true"

  -- Activate some settings to ensure proper functioning
  SetOption("enable_aliases", true)
  SetOption("enable_timers", true)
  SetOption("enable_triggers", true)
  SetOption("enable_scripts", true)

end

function OnPluginSaveState()
  SetVariable("autoCargo", tostring(autoCargo))
  SetVariable("closeBays", tostring(closeBays))
  SetVariable("shipnum", shipnum)
  SetVariable("cVar", cVar)
  SetVariable("cPlanets", ((cPlanets and serialize.save("cPlanets")) or ""))
  SetVariable("cargolist", GetPlanetList())
  SetVariable("ships", ((ships and serialize.save("ships")) or ""))
  SetVariable("shipdb", ((shipdb and serialize.save("shipdb")) or "")) -- don't set until shipdb variable exists
  SetVariable("transactions", ((transactions and serialize.save("transactions")) or ""))
  SetVariable("routes", ((routes and serialize.save("routes")) or ""))
  SetVariable("systems", ((systems and serialize.save("systems")) or ""))
end

function beginManifest()
  scannednum = 0
  scanNextManifest()
end

function scanNextManifest()
  scannednum = scannednum + 1
  if scannednum > getNumCargoShips() then -- finished manifest scan
    -- from disableshipmanifest
    ColourNote("yellow","","Beginning cargo session momentarily...")
    DoAfterSpecial(2, 'cargoStart()', sendto.script) 
  else
    if not getShip(scannednum).name or getShip(scannednum).name == "" then -- name isn't set, bug out
      ColourNote("red","","Error: ships must have a name assigned in order to scan manifest.")
      return
    else
      getShip(scannednum).cargo = {}
      Send("listcargo "..getShip(scannednum).name)
      EnableTriggerGroup("ManifestStart", true)
    end
  end
end

function doClearCargo(name, line, args)
  if args[1] == "" then -- no argument, clear it all
    clearCargoManifest(nil, true)
  else
    clearCargoManifest(Trim(args[1]), true)
  end
end

function clearCargoManifest(ship, display)
  if ship then -- provided a ship, find it
    local found = false
    for i=1, getNumCargoShips(), 1 do
      if string.find(getShip(i).name:lower(), ship, 0, true) then -- found the ship
        getShip(i).cargo = {}
        getShip(i).scanned = false
        if display then
          ColourNote("yellow","","Ship '"..getShip(i).name.."' cargo manifest cleared.")
        end
        found = true
        break
      end
    end
    if not found then
      ColourNote("red","","Ship '"..ship.."' not found in cargo ship list.")
    end
  else -- no ship provided, invalidate all
    for i=1, getNumCargoShips(), 1 do
      getShip(i).cargo = {}
      getShip(i).scanned = false
    end
    if display then
      ColourNote("yellow","","Cleared all cargo manifests.")
    end
  end
end

function errorShipManifest()
  EnableTriggerGroup("Manifest", false)
  EnableTriggerGroup("ManifestStart", false)
  ColourNote("red","","Error starting ship manifest. Make sure you are standing outside your cargo vessel, and that you are the owner/pilot/copilot.")
end

function enableShipManifest()
  EnableTriggerGroup("Manifest", true)
  ColourNote("yellow","","Enabled ship manifest capture.")
end
-- stores a pod into the current ship manifest

function storeCargoPod(name, line, args)
  if not args or args[1] == "" or args[2] == "" or args[3] == "" or args[4] == "" then
    return
  end
  local pod = { name=Trim(args[2]),held=tonumber(Trim(args[3])),cap=tonumber(Trim(args[4])) }
  getShip(scannednum).cargo[tonumber(Trim(args[1]))] = pod
end

function disableShipManifest()
 EnableTriggerGroup("Manifest", false)
  EnableTriggerGroup("ManifestStart", false)
  
  ColourNote("yellow","","Disabled ship manifest capture. Found "..#getShip(scannednum).cargo.." pods carrying "..getCargoCarrying(scannednum).."/"..getCargoCapacity(scannednum).." units.")
  getShip(scannednum).scanned = true
  scanNextManifest()
end
-- gets amount of cargo we're currently carrying

function getCargoCarrying(num)
  num = num or shipnum
  local retval = 0
  for i, v in ipairs(getShip(num).cargo) do
    retval = retval + v.held
  end
  return retval
end
-- gets amount of cargo we're capable of carrying

function getCargoCapacity(num)
  num = num or shipnum
  local retval = 0
  for i, v in ipairs(getShip(num).cargo) do
    retval = retval + v.cap
  end
  return retval
end


function cargoSetup() -- old setup function, replacement planned
	cPlanets = {}
	local planet = {}
	local numWorlds = tonumber(utils.inputbox("Number of worlds on cargo route?", "Number", "2", GetInfo(23), GetInfo(215)))
	for i = 1, (numWorlds or 0), 1 do
		planet.name = utils.inputbox("Name of world " .. i .. "?", "Name of world " .. i, "Name", GetInfo(23), GetInfo(215))
		planet.resource = utils.inputbox("Resource to be bought on world " .. i .. "?", "Resource of world " .. i, "Resource", GetInfo(23), GetInfo(215))
    --planet.landing = utils.inputbox("Preferring landing pad on this world?", "Landing pad", "", GetInfo(23), GetInfo(215))
    planet.contraband = utils.inputbox("Do you want to use buy/sellcontraband?", "Use Buy/Sellcontraband", "No", GetInfo(23), GetInfo(215))
    if not planet.name or not planet.resource or not planet.contraband then
      ColourNote("red","","Cancel detected, aborting.")
      return
    end
		cPlanets[#cPlanets + 1] = planet
		planet = {}
	end
  OnPluginSaveState()
  BroadcastPlugin(999, 'reload') -- sends a message to LotJStarMap to reload the map
end

function cargoSetupShipName(name, line, args)
  ColourNote("yellow","","This command has been superceded by the cargoShipProfile and cargoShipList systems,")
  ColourNote("yellow","","Please see their cargohelp topics for more information.")
end
cargoPlanetsUsage = "Usage: cargoPlanets <planet1>,<resource1>,<trafficking>,<planet2>,<resource2>,<trafficking>..."
                .."\n       cargoPlanets best <number> <contraband yes/no> "

function cargoSetupPlanets(name, line, args)
  if not args or args[1] == "" then
    ColourNote("red","",cargoPlanetsUsage)
    return
  end
  local planet = {}
  local addItems = {}
  if string.find(args[1], ",", 0, true) then
    addItems = utils.split(args[1], ",")
  elseif args[1]:find("best") then -- loading planets from best list
    local args = utils.split(args[1], ' ')
    local bestNum = tonumber(args[3]) or 0
    local contraband = ((args[4] ~= "" and args[4]) or "no")
    if bestNum < 1 or bestNum > #bestMatches then
      ColourNote("red","","Invalid best route index chosen, you must perform a `cargobest` search, then choose a valid result index.")
      return
    end
    local bestRoute = bestMatches[bestNum].route
    if not bestRoute then -- something went wrong
      ColourNote("red","","Something went wrong, unable to find best route with index "..bestNum)
      return
    end
    cPlanets = {}
    addItems = {}
    for i=1, #bestRoute-1, 1 do
      planet = {}
      planet.name = bestRoute[i]
      planet.resource = routes[bestRoute[i]][bestRoute[i+1]].resource or ""
      planet.contraband = contraband
      cPlanets[#cPlanets + 1] = planet
      ColourNote("yellow","","("..(planet.name or "")..","..(planet.resource or "")..","..(planet.contraband or "")..") added to cargo planets.")

    end
    if #cPlanets == #bestRoute-1 then
      ColourNote("yellow","","Successfully loaded "..#cPlanets.." planets from cargobest route result #"..bestNum.."!")
    end
    OnPluginSaveState()
    BroadcastPlugin(999, 'reload') -- sends a message to LotJStarMap to reload the map
    return
  else
    ColourNote("red","",cargoPlanetsUsage)
	  return
	end
  -- perform comprehensive input checking
  if not AllItemsAreValid(addItems) then
    return
  end
	cPlanets = {}
  ColourNote("yellow","","Cargo planet list cleared.")

  local i = 1
  while i < #addItems do
    planet = { name = addItems[i], resource = addItems[i+1], contraband = addItems[i+2] }
    table.insert(cPlanets, planet)
    ColourNote("yellow","","("..(planet.name or "")..","..(planet.resource or "")..","..(planet.contraband or "")..") added to cargo planets.")
    i = i + 3
  end

  OnPluginSaveState()
  BroadcastPlugin(999, 'reload')
end

function AllItemsAreValid(items)
  if #items % 3 ~= 0 then -- incorrect number of items given, should come in pairs of 3
    ColourNote("red","",cargoPlanetsUsage)
    return false
  end
  for i=1, #items, 3 do -- check each planet for validity
    items[i] = Trim(items[i])
    local found = false
    for k, v in pairs(systems) do
      for a, b in pairs(v.bodies) do
        if items[i]:lower() == b.name:lower() then
          found = true
        end
      end
    end
    if not found then
      ColourNote("red","","Invalid planet name given. '"..items[i].."' is not a valid planet.")
      return false
    end
  end
  for i=2, #items, 3 do -- check each resource for validity
    items[i] = Trim(items[i])
    local found = false
    if items[i]:lower() == "none" then
      found = true
    end
    for k, v in pairs(systems) do
      for a, b in pairs(v.bodies) do
        for c, d in pairs(b.resources) do
          if items[i]:lower() == d.name:lower() then
            found = true
          end
        end
      end
    end
    if not found then
      ColourNote("red","","Invalid resource name given. '"..items[i].."' is not a valid resource.")
      return false
    end
  end
  for i=3, #items, 3 do -- check each contraband parameter for validity
    items[i] = Trim(items[i])
    if items[i]:lower() ~= "yes" and items[i]:lower() ~= "no" and items[i]:lower() ~= "on" and items[i]:lower() ~= "off" then
      ColourNote("red","","Invalid option given to contraband, it must be 'yes', 'no', 'on', or 'off'.")
      return false
    end
  end
  return true
end

function contraSellFailed(name, line, args)
  removeCargo(lastsoldresource, lastsoldamount)
  buyRemaining()
end

function contraBuyFailed(name, line, args)
  -- need to add a line here to reduce amountearned or efficiency will be off!
  buyRemaining()
end

function printTransactions()
  local total = 0
  ColourNote("white","","[","yellow","",string.format("%30s", " Timestamp "),"white","","] [","yellow","",string.format("%-11s", "Transaction"),"white","","] [","yellow","",string.format("%-15s", "Resource"),"white","","] [","yellow","",string.format("%-7s", "Quantity"),"white","","] [","yellow","",string.format("%-10s", "Credits"),"white","","] [","yellow","",string.format("%-15s", "Planet"),"white","","]")
  for _, v in ipairs(transactions) do 
    ColourTell("white","","[ ","yellow","",string.format("%30s", os.date("%A, %b %d - %H:%M:%S", v.timestamp)), "white",""," ] ")
    ColourTell("white","","[ ","yellow","",string.format("%-11s", v.type),"white","","] [ ")
    ColourTell("white","","[ ","yellow","",string.format("%-15s", v.resource),"white","","] [ ")
    ColourTell("white","","[ ","yellow","",string.format("%-7s", commas(v.quantity)),"white","","] [ ")
    ColourTell("white","","[ ",((v.type == "sell" and "lime") or "red"),"",string.format("%-10s", commas(v.credits)),"white","","] [ ")
    ColourNote("white","","[ ","yellow","",string.format("%-15s", v.planet),"white","","]")
    total = total + ((v.type == "buy" and -v.credits) or v.credits)
  end
  ColourNote("cyan","",#transactions,"white",""," transactions stored in log.")
  ColourNote("white","","Total credit balance on transaction sheet: ","cyan","",total)
end

function clearTransactions()
  transactions = {}
  ColourNote("white","","LotJCargo transactions cleared.")
end

function addTransaction(timestamp, type, resource, qty, credits, planet)
  local transaction = {timestamp = timestamp, type = type, resource = resource, quantity = qty, credits = credits, planet = planet}
  transactions[#transactions + 1] = copytable.deep(transaction)
  ColourNote("yellow","","LotJCargo Transaction logged.")
end

function soldCargo(name, list, args)
  if args.quantity ~= nil and args.resource ~= nil then
    removeCargo(args.resource, tonumber(args.quantity))
    if args.credits ~= nil then
      amountEarned = amountEarned + tonumber(args.credits)
      local planet = getmsdp("PLANET")
      local time = os.time()
      addTransaction(time, "sell", args.resource, (tonumber(args.quantity) or -1), (tonumber(args.credits) or -1), ((planet~="" and planet) or "Unknown"))
    end
  
  end
  if not buyRemaining() then
    continueTrading()
  end
end

function boughtCargo(name, list, args)
  if args.quantity ~= nil and args.resource ~= nil then
    addCargo(args.resource, tonumber(args.quantity))
    if args.credits ~= nil then
      amountEarned = amountEarned - tonumber(args.credits)
      local planet = getmsdp("PLANET")
      local time = os.time()
      addTransaction(time, "buy", args.resource, (tonumber(args.quantity) or -1), (tonumber(args.credits) or -1), ((planet~="" and planet) or "Unknown"))
    end
  end
	continueTrading()
end

function removeCargo(cargotype, cargoamount)
  if cargotype == nil or cargoamount == nil then
    return
  end
  local found = false
  local amounttoremove = tonumber(cargoamount)
  for i, v in ipairs(getShip().cargo) do
    if amounttoremove > 0 and cargotype == v.name then -- cargo type matches type in pod
      found = true -- we found the cargo type we're removing in the manifest
      if amounttoremove >= v.held then -- we sold more than the pod is carrying
        amounttoremove = amounttoremove - v.held -- subtract amount pod is carrying from total to remove
        v.name = "(Empty)" -- set cargo type of pod to none
        v.held = 0 -- set amount pod is holding to 0
      else -- we only sold part of a pod
        v.held = v.held - amounttoremove -- subtract amount we sold from amount in pod
        amounttoremove = 0 -- the pod had more than we were trying to sell
      end
    else -- type doesn't match type in manifest
      if #getShip().cargo == i and not found then -- we tried to sell a cargo type we weren't carrying
        ColourNote("red","","Error occurred. Attempt to sell cargo not located in manifest.")
      end
    end
  end
end
      
-- usage: addcargo(name, amount)
function addCargo(cargotype, cargoamount)
  if cargotype == nil or cargoamount == nil then
    return
  end
  local amounttoadd = tonumber(cargoamount)
  for i, v in ipairs(getShip().cargo) do
    if amounttoadd > 0 then
      if cargotype == v.name then -- we found a pod of our cargo type
        local roomleft = v.cap - v.held -- figure out how much room's left in the pod
        if amounttoadd > roomleft then -- if we're adding more than we have room for
          v.held = v.held + roomleft -- increase amount in pod
          amounttoadd = amounttoadd - roomleft -- decrease amount we need to add
        else -- we have room for everything we're adding
          v.held = v.held + amounttoadd -- increase amount in pod
          amounttoadd = 0 -- we added everything we were trying to add
        end
      elseif v.name=="(Empty)" then -- we found an empty pod
        local roomleft = v.cap - v.held -- figure out how much room we have left (should always be cap)
        if amounttoadd > roomleft then -- if we're adding more than the pod has room for
          v.held = v.held + roomleft -- increase pod amount
          v.name = cargotype -- set the type of our pod to the type we're adding
          amounttoadd = amounttoadd - roomleft -- decrease amount we need to add
        else -- we have room for everything we're adding
          v.held = v.held + amounttoadd -- increase amount in pod
          v.name = cargotype -- set the type of our pod to the type we're adding
          amounttoadd = 0 -- we added everything we were trying to add
        end
      else -- can't use this pod
        if #getShip().cargo == i then -- reached end of list without adding our cargo
          ColourNote("red","","Error adding cargo type "..cargotype..". No suitable pod found in ship manifest.")
        end
      end
    end
  end
end

function cargoManifest()
  for i=0,getNumCargoShips(),1 do
    if getShip(i) then
      ColourNote(gray,"","Cargo readout for ",cyan,"",getShip(i).name..":")
      if getShip(i).cargo and #getShip(i).cargo > 0 then
        ColourNote(gray,"","-------------------------------------------")
        ColourNote(gray,"","[",darkblue,"","ID:",gray,"","] [",darkblue,"","Contents:           ",gray,"","] [",darkblue,"","Amount:  ",gray,"","]")
        for i, v in ipairs(getShip(i).cargo) do
          ColourNote(gray,"","[",cyan,"",string.format("%-3d",i),gray,"","] [",cyan,"",string.format("%-20s",v.name),gray,"","] [",cyan,"",string.format("%-9s",v.held.."/"..v.cap),gray,"","]")
        end
        Note("")
      else
        ColourNote(gray,"","No cargo pods.")
      end
    end
  end
end

function jumpComplete()
	hyperCompleted = true
end

function toggleCycle()
	if cycle then
		cycle = false
		ColourNote("yellow","","AutoCargo cycling is OFF.")
	else
		cycle = true
		ColourNote("yellow","","AutoCargo cycling is ON.")
	end
end

function gainMoney(name, list, args)
	local earned = tonumber(args[1]) - tonumber(args[2])
	amountEarned = amountEarned + earned
end

function loseMoney(name, list, args)
	amountEarned = amountEarned - tonumber(args[1])
end

function displayEfficiency()
	local newTime = os.time()
	local elapsed = newTime - startTime
	if amountEarned == 0 or not elapsed then
	  return
	end
	ColourNote("silver","","Credits made: ",cyan,"",commas(amountEarned),"silver",""," Elapsed: ",cyan,"",displayTime(elapsed))
	--,"silver",""," (",cyan,"",elapsed,"silver","",")"
	ColourNote("silver","","Credits per hour: ",cyan,"",commas(string.format("%d", ((amountEarned / (elapsed / 60) * 60)))))
end

function displayTime(time)
	local retval = {}
	local secs = tonumber(time)
	if (secs >= 315705600) then
		local decades = secs / 315705600
		secs = secs - (decades * 315705600)
		retval[#retval + 1] = tostring(string.format("%.1f", decades) .. " decades")
	end
	if (secs >= 31570560) then
		local years = secs / 31570560
		secs = secs - (years * 31570560)
		retval[#retval + 1] = tostring(string.format("%.1f", years) .. " years")
	end
	if (secs >= 2630880) then
		local months = secs / 2630880
		secs = secs - (months * 2630880)
		retval[#retval + 1] = tostring(string.format("%.1f", months) .. " months")
	end
	if (secs >= 604800) then
		local weeks = secs / 604800
		secs = secs - (weeks * 604800)
		retval[#retval + 1] = tostring(string.format("%.1f", weeks) .. " weeks")
	end
	if (secs >= 86400) then
		local days = secs / 86400
		secs = secs - (days * 86400)
		retval[#retval + 1] = tostring(string.format("%.1f", days) .. " days")
	end
	if (secs >= 3600) then
		local hours = secs / 3600
		secs = secs - (hours * 3600)
		retval[#retval + 1] = tostring(string.format("%.1f", hours) .. " hours")
	end
	if (secs >= 60) then
		local mins = secs / 60
		secs = secs - (mins * 60)
		retval[#retval + 1] = tostring(string.format("%.1f", mins) .. " mins")
	end
	if (secs >= 1) then
		retval[#retval + 1] = tostring(string.format("%.1f", secs) .. " secs")
	end
	--1,60,3600,86400,604800,2630880,31570560,315705600
	return table.concat(retval, ", ")
end

function leftShip()
  if not hyperCompleted or not tradingCompleted then
    return
  end
  planet = getName()
  unloadShips()
  beginTradingStage()
end

function beginTradingStage()
  tradingCompleted = false
  shipnum = 0
  beginNextTradingStage()
end

function beginNextTradingStage()
  -- first we try to sell what we're carrying
  if moveToNextShip() then -- we found a ship
    continueTrading()
  else
    ColourNote("yellow","","Trading completed. Loading up and flying to "..capitalize(getNextName()).." momentarily...")
    DoAfterSpecial(3, 'endTradingStage()', sendto.script)
  end
end

function continueTrading()
  -- updated to use sellOneType instead of sellOnePod here due to removal of planetary funds
  --if not sellOnePod() then -- if we are unable to sell anything, that means we need to move on
  if not sellOneType() then -- if we are unable to sell a single type, that means we move on to buying this round
    if not buyRemaining() then
      beginNextTradingStage()
    end
  end
end

function moveToNextShip()
  shipnum = shipnum + 1
  if shipnum > getNumCargoShips() then
    shipnum = 1
    return nil
  else
    return shipnum
  end
end

function endTradingStage()
  tradingCompleted = true
  loadShips()
  flyNext()
end

function errorSelling()
  ColourNote("red","","Attempted to sell bad resource, aborting cargo script to prevent credit loss. Please check your settings and rerun the script.")
  toggleACOff()
end

function processTransaction(qty, type, debug)
  if (qty > 0) then -- we are buying
    -- buy enough to fill any empty space in current ship
    if string.match("y", getContraband():lower()) or string.match("on", getContraband():lower()) then
      if debug then
        Note("buycontraband \""..getShip().name.."\" \""..type.."\" "..qty)
      else
        Send("buycontraband \""..getShip().name.."\" \""..type.."\" "..qty)
      end
    else
      if debug then
        Note("buycargo \""..getShip().name.."\" \""..type.."\" "..qty)
      else
        Send("buycargo \""..getShip().name.."\" \""..type.."\" "..qty)
      end
    end
  else -- we are selling
    -- sell the contents of the pod)
    qty = math.abs(qty)
    if string.match("y", getContraband():lower()) or string.match("on", getContraband():lower()) then
      -- we're using sellcontraband
      if debug then
        Note("sellcontraband \""..getShip().name.."\" \""..type.."\" "..qty)
      else
        Send("sellcontraband \""..getShip().name.."\" \""..type.."\" "..qty)
      end
      lastsoldamount = qty
      lastsoldresource = type
    else
      if debug then
        Note("sellcargo \""..getShip().name.."\" \""..type.."\" "..qty)
      else
        Send("sellcargo \""..getShip().name.."\" \""..type.."\" "..qty)
      end
      lastsoldamount = qty
      lastsoldresource = type
    end
  end
end

function sellOneType()
-- sell full amount of a single type of cargo all at once
  local sellQty = 0
  local sellType = ""
  for i, v in ipairs(getShip().cargo or {}) do
    if v.held > 0 and v.name:lower() ~= getResource():lower() then -- pod is carrying something we don't want 
      if sellType == "" and v.name ~= "(Empty)" then -- record the first occurrence of a non-matching cargo (that isn't an empty pod)
        sellType = v.name:lower()
        sellQty = v.held
      elseif (v.name:lower() == sellType) then -- we already stored a non-matching type, and this matches, add qty
        sellQty = sellQty + v.held
      end
      -- more than one non-matching type, discarded for later processing rounds
    end
  end
  if sellQty > 0 then
    processTransaction(-sellQty, sellType, false)
    return true
  end
  return false
end

function sellOnePod()
  for i, v in ipairs(getShip().cargo or {}) do
    if v.held > 0 and string.lower(v.name) ~= string.lower(getResource()) then -- pod is carrying something we don't want
      if getContraband():lower() == "yes" or getContraband():lower() == "y" then
      -- we're using sellcontraband
         Send("sellcontraband \""..getShip().name.."\" \""..v.name.."\" "..v.held)
         lastsoldamount = v.held
         lastsoldresource = v.name
      else
         Send("sellcargo \""..getShip().name.."\" \""..v.name.."\" "..v.held) -- sell the contents of the pod
         lastsoldamount = v.held
         lastsoldresource = v.name
      end
      return true -- abort out so we don't sell everything at once
    end
  end
  return false -- we didn't sell anything
end
-- buys a single pod's worth of cargo

function buyOnePod()
  if getResource() ~= "" and getResource() ~= "none" then -- our resource list indicates we want to buy something
    for i, v in ipairs(getShip().cargo or {}) do
      local needed = 0
      if (v.name == "(Empty)" or string.lower(v.name) == string.lower(getResource())) then -- our container is either empty or contains the resource we need
        needed = v.cap - v.held -- we need to buy remaining amount
        if needed > 0 then
          if getContraband():lower() == "yes" or getContraband():lower() == "y" then
            Send("buycontraband \""..getShip().name.."\" \""..getResource().."\" "..needed)
          else
            Send("buycargo \""..getShip().name.."\" \""..getResource().."\" "..needed)
          end
          return true-- abort out so we don't buy everything at once
        end
      end
    end
  end
  return false -- we didn't buy anything
end
-- fills any empty cargo space we may have

function buyRemaining()
  if getResource() ~= "" and getResource() ~= "none" then -- we need to buy something
    local needed = getCargoCapacity() - getCargoCarrying()
    if needed > 0 then
      processTransaction(needed, getResource(), false)
      return true -- we bought something
    end
  end
  return false -- we didn't buy anything
end

function waitSell()
	DoAfterSpecial (5, 'continueTrading()', sendto.script)
end

function retrievePlanetFailed()
  EnableTriggerGroup("RetrievePlanet", false)
  ColourNote("red","","Error: you must be standing outside your ship on a planet for cargostart to work!")
end

function retrievePlanet()
  shipnum = 1
	cVar = 1
amountEarned = 0
  clearCargoManifest(nil, false)
  ColourNote("yellow","","Retrieving current planet...")
  Send("showplanet")
  EnableTriggerGroup("RetrievePlanet", true)
end

function storePlanet(name, line, args)
  if args.planet then
    planet = Trim(args.planet)
    ColourNote("yellow","","Current planet found: "..planet)
  end
end

function updateListPosition()
  EnableTriggerGroup("RetrievePlanet", false)
  local found = false
  if planet and planet ~= "" then
    for i, v in ipairs(cPlanets or {}) do
      if v.name:lower() == planet:lower() then
        cVar = i
        found = true
        break
      end
    end
  end
  if found then
    ColourNote(gray,"","Adjusting cargo planet position to match current planet: ",cyan,"",cVar,gray,""," (",cyan,"",cPlanets[cVar].name,gray,"",")")
    ColourNote("yellow","","Beginning cargo run momentarily...")
    DoAfterSpecial(2, 'cargoStart()', sendto.script)
  else
    ColourNote("red","","Error: tried to run cargo from a planet not present on cargo planets list!")
  end
end

function cargoStart()
	startTime = os.time()
	if not getShip() or not getShip().name or getShip().name == "" then
	  ColourNote("red","","You must assign a ship name using cargoship <shipname> before starting your session.")
	  return
	end
	if not cPlanets or #cPlanets == 0 then
	  ColourNote("red","","You must assign your cargo route using cargosetup or cargoplanets <planet1>,<resource1>,<trafficking>,<planet2>,<resource2>,<trafficking>...")
	  return
	end
	if ((not checkAllCargoExists() or not checkAllScanned()) and checkForResources()) then -- make it possible to run script without any cargo by entering 'none' into every resource
    clearCargoManifest(nil, true)
	  ColourNote("yellow","","Retrieving ship's cargo manifest for you...")
	  beginManifest()
	  return
	end
	toggleACOn()
	hyperCompleted = true
	beginTradingStage() -- sell off stuff we don't want and refill the ship
end

function checkAllCargoExists()
  for i, v in ipairs(ships) do
    if not v.cargo then
      return false
    end
  end
  return true
end

function checkAllScanned()
  for i, v in ipairs(ships) do
    if not v.scanned then
      return false
    end
  end
  return true
end

function checkForResources()
  for i, v in pairs(cPlanets) do
    if v.resource:lower() ~= "none" and v.resource ~= "" then
      return true
    end
  end
  return false
end

function flyNext()
  if getResource() ~= "" and getResource() ~= "none" then
    buyRemaining() -- fill up the ship (without selling it off since hyperCompleted is now false)
  end
  cVar = cVar + 1
  if (cVar > #cPlanets) then  -- if we're at the end of the list
    if cycle then         -- wrap to the beginning
      cVar = 1
    else
      ColourNote("yellow","","LotJCargo reached and of trading list and cargo cycle is OFF. Ending cargo session.")
      cVar = #cPlanets
      toggleACOff()		-- abort out and quit
      return
    end
  end
  hyperCompleted = false
  Execute("flyto " .. getName())
end

function getNextName()
  if #cPlanets == 0 or cVar > #cPlanets then -- list is empty
    return ""
  end
  if cVar == #cPlanets then -- we're at end of list
    return cPlanets[1].name
  else
    return cPlanets[cVar+1].name -- we're in middle of list
  end
  return "" -- should never get here
end

function getNextResource()
  if #cPlanets == 0 or cVar > #cPlanets then
    return ""
  end
  if cVar == #cPlanets then
    return cPlanets[1].resource
  else
    return cPlanets[cVar+1].resource
  end
  return ""
end

function getNextPlanet()
  if #cPlanets == 0 or cVar > #cPlanets then
    return ""
  end
  if cVar == #cPlanets then
    return cPlanets[1]
  else
    return cPlanets[cVar+1]
  end
  return ""
end

function getName()
  if #cPlanets == 0 or cVar > #cPlanets then
    return ""
  end
  return cPlanets[cVar].name
end

function getResource()
  if #cPlanets == 0 or cVar > #cPlanets then
    return ""
  end
  return cPlanets[cVar].resource
end

function getPlanet()
  if #cPlanets == 0 or cVar > #cPlanets then
    return ""
  end
  return cPlanets[cVar]
end

function getContraband()
  if #cPlanets == 0 or cVar > #cPlanets then
    return ""
  end
  return cPlanets[cVar].contraband
end

function toggleACOn()
	autoCargo = true
	EnableTriggerGroup("AutoCargo", true)
	EnableTimer("EfficiencyTimer", true)
	ColourNote("yellow","","AutoCargo activated.")
end

function toggleACOff()
	autoCargo = false
	EnableTriggerGroup("AutoCargo", false)
	EnableTimer("EfficiencyTimer", false)
	ColourNote("yellow","","AutoCargo deactivated.")
end

require "copytable"

local prices = {}

function calculate_price_comparison()
    prices = {}
    for i, j in ipairs(systems) do -- systems
      for a, b in ipairs(j.bodies) do -- bodies
        if (#b.resources > 0) then -- body has resources
          for k, v in pairs(b.resources) do -- resources
            if prices[v.name] then -- price category already exists in prices list
              table.insert(prices[v.name], v.price)
            else -- price category doesn't exist in prices list
              prices[v.name] = { v.price }
            end
          end
        end
      end
    end
    for k, v in pairs(prices) do -- categories
      local min = v[1]
      local max = v[1]
      local sum = 0
      local avg = 0
      for _, price in ipairs(v) do -- prices
        if price > max then max = price end
        if price < min then min = price end
        sum = sum + price
      end
      avg = sum / #v
      v.min = min
      v.max = max
      v.avg = avg
    end
    --tprint(prices)

end

function capitalize(word)
  return (word:gsub("^%l", string.upper)) 
end

function get_price_color(type, price)
  if not prices then
    ColourNote("red","","Price comparisons haven't been calculated, please re-run cargoscan!")
    return "cyan"
    end
  if not prices[type] then
    return "cyan"
  end
  local min = prices[type].min
  local max = prices[type].max
  local avg = prices[type].avg
  local value = ((price - min) / (max - min)) * 100
  if (value < 10) then
    return "lime"
  elseif (value < 30) then
    return "darkgreen"
  elseif (value < 50) then
    return "green"
  elseif (value < 60) then
    return "white"
  elseif (value < 70) then
    return "orange"
  elseif (value < 90) then
    return "red"
  else
    return "darkred"
  end
end

function overlayPrice(name, line, args)
  local type = Trim(args.type)
  local price = tonumber(args.price)
  if not price then
    ColourNote("red","","Error in LotJCargo Price Overlay, invalid price passed: "..args[1])
    return
  end
  ColourNote("gray","",string.format("%-20s", type).." (","white",""," Price per unit: ",get_price_color(type, price),"",string.format("%2.2f",price),"gray","",")")
end

function listSystems(name, list, args)
  local tempsystems = copytable.deep(systems)
  for i, j in ipairs(tempsystems) do -- systems
    for a, b in ipairs(j.bodies) do -- bodies
      ColourNote("silver","",i..".","red","",b.name,"silver","",":")
      if #b.resources == 0 then
        ColourNote("silver","","  None.")
      end
      -- sort resources in ascending order by price
      table.sort (b.resources, 
          function (v1, v2)
            return v1.price < v2.price
          end -- function
          )
      for k, v in ipairs(b.resources) do
        ColourNote("silver","",string.format("  %-16s : ",v.name),get_price_color(v.name,v.price),"",string.format("%5.2f",v.price))
      end
    end
  end
	--tprint(systems)
end

function cargoClear(name, list, args)
  ship = { name = "", cargo = {} }
	cPlanets = {}
	startTime = 0
	amountEarned = 0
	cVar = 0
	cycle = true
  tradingCompleted = false
	hyperCompleted = false
	scannedCargo = false
  planet = ""
	ColourNote("yellow","","Cargo list cleared.")
	toggleACOff()
  OnPluginSaveState()
  BroadcastPlugin(999, 'reload')
end

function cargoAuto(name, list, args)
  if (args[1] == "on") then
    toggleACOn()
  else
    if (args[1] == "off") then
      toggleACOff()
    else
      if(autoCargo == true) then
        toggleACOff()
      else
        toggleACOn()
      end
    end
  end
end

-- this function finds the single best route from every planet in the galaxy
-- each planet should only have 1 best one-way route to another planet
-- these best routes are stored in the global routes[] table which will 
-- be used to find the best round trip routes with an arbitrary number
-- of stops
function generateRoutes()
    routes = {}
  for system1key, system1value in pairs(systems) do
    for system2key,system2value in pairs(systems) do
      if (system1value ~= system2value) then -- don't start and end at the same system
        for body1key, body1value in pairs(system1value.bodies) do
          for body2key, body2value in pairs(system2value.bodies) do
            if (body1value ~= body2value) then -- don't start and end at the same planet
              local body1tax = body1value.tax
              local body2tax = body2value.tax
              for resource1key, resource1value in pairs(body1value.resources) do
                for resource2key, resource2value in pairs(body2value.resources) do
                  if (resource1value.name == resource2value.name) then -- only store valid starting and ending routes
                    local routeProfit, routeTime = calculateRouteValue(system1value, system2value, resource2value.price, resource1value.price, body2tax, body1tax)
                    local routeValue = routeProfit / routeTime
                    if (routeValue > 0) then -- ignore routes that lose money
                      local planet1 = body1value.name
                      local planet2 = body2value.name
                      local resource = resource1value.name
                      local route = { value = routeValue, profit = routeProfit, time = routeTime, resource = resource1value.name }
                      -- store only the best resource route between 2 planets (this is the segment cost)
                      if not routes[planet1] then -- make sure the 2d array exists
                        routes[planet1] = {}
                      end
                      if (not routes[planet1][planet2] or routes[planet1][planet2].value < route.value) and route.time < 600 then
                        routes[planet1][planet2] = copytable.deep(route)
                      end
                    end
                  end
                end
              end
            end
          end
        end
      end
    end
  end
  --printAllRoutes()
  --tprint(routes)
  OnPluginSaveState()
end


function findPlanetIndex(list, planet)
  for i, v in ipairs(list) do
    if v.planet1 == planet then
      return i
    end
  end
  return 0
end

function printAllRoutes(name, line, args)
  local num = 0
  for k, v in pairs(routes) do
    for i, j in pairs(v) do
      num = num + 1
      ColourNote("white","",string.format("%3d",num)..") "..string.format("%-10s", k).." -> "..string.format("%-10s",i)..":"..string.format("%-15s",j.resource).." ("..string.format("%.2f",j.profit).."/"..string.format("%d",j.time)..")="..string.format("%.2f",j.value*1000)) 
    end
  end
end

local function countTable(t)
  local count = 0
  for _, v in pairs(t) do
    count = count + 1
  end
  return count
end

local function nodeInRoute(route, node)
  for k, v in ipairs(route) do
    if k > 1 and v == node then return true end
  end
  return false
end

local circularRoutes = {}
local iterations = 0
function find_most_valuable_route(graph, maxStops)
  circularRoutes = {}
  iterations = 0

  -- Iterate over each node in the graph
  for start_node, _ in pairs(graph) do
    local stack = {{start_node, {start_node}, 0}}
    local visited = 0

    -- Perform DFS iteratively
    while #stack > 0 do
      local current_node, route, value = stack[#stack][1], stack[#stack][2], stack[#stack][3]
      table.remove(stack)

      -- if current_node == start_node and we visited at least 1 system, then we have a valid route
      if current_node == start_node and visited > 1 then
        circularRoutes[#circularRoutes + 1] = {route = copytable.deep(route), value = (value / (#route - 1))}
      else
        for neighbor, neighbor_value in pairs(graph[current_node]) do
          if #route <= maxStops then -- don't get bogged down searching huge routes, this can easily stretch iterations into the millions
            if not nodeInRoute(route, neighbor) then
              local newRoute = copytable.deep(route)
              newRoute[#newRoute + 1] = neighbor
              local newValue = value + neighbor_value.value * 1000
              iterations = iterations + 1
              table.insert(stack, {neighbor, newRoute, newValue})
              -- visited[current_node.."-"..neighbor] = true
              visited = visited + 1
            end
          end
        end
      end
    end
  end
  table.sort(circularRoutes, function (k1, k2) return k1.value > k2.value end )
end

bestMatches = {}
function find_the_best(name, line, args)
  local startTime = GetInfo(232)
  local maxStops = 5 -- default to 5 planets max to keep search time down
  local args = utils.split(args[1], ' ')
  local search = ""
  if #args > 1 then -- entered some arguments
    if tonumber(args[2]) then
      maxStops = tonumber(args[2]) -- entered number as first argument, use it for max stops
      for i=3, #args, 1 do
        search = search .. " " .. args[i] -- append any remaining arguments into search terms
      end
    else
      for i=2, #args, 1 do
        search = search .. " " .. args[i] -- no number entered, all arguments are search terms
      end
    end
  end
  find_most_valuable_route(routes, maxStops) -- perform the search
  local endTime = GetInfo(232)
  ColourNote("white","","Searched "..iterations.." total routes in "..string.format("%1.3f", endTime-startTime).." seconds.")
  ColourNote("white","","Best routes up to ","red","",maxStops,"white",""," planets matching ","red","",((search == "" and "anything") or search)..":")
  bestMatches = {}
  local prevNum = 0
  local prevValue = 0
  for i, v in ipairs(circularRoutes) do
    local route = circularRoutes[i].route
    local value = circularRoutes[i].value
    if (search == "") or (string.match(route[1]:lower(), Trim(search):lower()) or string.match(routes[route[1]][route[2]].resource:lower(), Trim(search):lower())) then -- matched this route, print it
      if #route ~= prevNum or string.format("%0.4f", value) ~= string.format("%0.4f", prevValue) then
        bestMatches[#bestMatches + 1] = { route = route, value = value }
        if #bestMatches >= 10 then
          break
        end
      end
      prevNum = #route
      prevValue = value
    end
  end
  if #bestMatches == 0 then
    ColourNote("red","","Didn't find any routes matching "..search)
  else
    for i, v in ipairs(bestMatches) do
      local route = v.route
      local value = v.value
      ColourTell("white","",string.format("%2.0d", i).." ")
      for a=1, #route, 1 do
        ColourTell("white","",string.format("%9s", route[a]),"darkgray","",((a < #route and " ("..string.format("%-11s", routes[route[a]][route[a+1]].resource):gsub("Precious", "Prc"):gsub("Common", "Cmn")..")") or ""),"gray","",((a<#route and " -> ") or ""))
      end
    ColourNote("darkgray",""," = Value: ","red","",string.format("%0.2f", value))
    end
  end
end  


local routeValues = {}

function calculateRouteValues()
  routeValues = {}
  for system1key, system1value in pairs(systems) do
    for system2key, system2value in pairs(systems) do
      if (system1value ~= system2value) then
        for body1key, body1value in pairs(system1value.bodies) do
          for body2key, body2value in pairs(system2value.bodies) do
            if (body1value ~= body2value) then
              local tax1 = body1value.tax
              local tax2 = body2value.tax
              for resourcego1key, resourcego1value in pairs(body1value.resources) do
                for resourcego2key, resourcego2value in pairs(body2value.resources) do
                  if (resourcego1value.name == resourcego2value.name) then
                    for resourceret1key, resourceret1value in pairs(body1value.resources) do
                      for resourceret2key, resourceret2value in pairs(body2value.resources) do
                        if ((resourceret1value.name == resourceret2value.name) and (resourcego1value.name ~= resourceret1value.name)) then
                          local curGoProfit, curGoTime = calculateRouteValue(system1value, system2value, resourcego2value.price, resourcego1value.price, tax2, tax1)
                          local curRetProfit, curRetTime = calculateRouteValue(system1value, system2value, resourceret1value.price, resourceret2value.price, tax1, tax2)
                          local curTotalProfit = curGoProfit + curRetProfit
                          local curTotalTime = curGoTime + curRetTime
                          local curTotalValue = curTotalProfit / curTotalTime
                          local route = { value = curTotalValue, profit = curTotalProfit, time = curTotalTime, planet1 = body1value, planet2 = body2value, resource1 = resourcego1value, resource2 = resourceret1value }
                          routeValues[#routeValues + 1] = route
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
      end
    end
  end
  table.sort(routeValues, function (k1, k2) return k1.value > k2.value end )
end

function cargoBestRoute(name, list, args)					-- find the most profitable route in the entire galaxy
	foundPlanet = false

  local matches = {}
  local best = {}
  local match = false
  local step = 1
  local l1, l2, l3, l4 = 0, 0, 0, 0
  if (args[1] == "") then 
		ColourNote("silver","","Top 10 best routes in the entire galaxy:")
    step = 2
  else
		ColourNote("silver","","Top 10 best routes matching ",cyan,"",Trim(args[1]),"silver","",":")
  end
  for i=1, #routeValues, step do
    best = routeValues[i]
    if (args[1] == "") or (string.match(best.planet1.name:lower(), Trim(args[1]):lower()) or string.match(best.resource1.name:lower(), Trim(args[1]):lower())) then -- matched this route, print it
      foundPlanet = true
      matches[#matches + 1] = copytable.deep(routeValues[i])
      l1 = ((best.planet1.name:len() > l1 and best.planet1.name:len()) or l1)
      l2 = ((best.resource1.name:len() > l2 and best.resource1.name:len()) or l2)
      l3 = ((best.planet2.name:len() > l3 and best.planet2.name:len()) or l3)
      l4 = ((best.resource2.name:len() > l4 and best.resource2.name:len()) or l4)
      if #matches >= 10 then 
        break 
      end
    end
  end
  if not foundPlanet then -- entered a bad planet name or resource
    ColourNote("red","","None.")
  else
    for i, v in ipairs(matches) do
      ColourNote("red","",i..": ",
      "silver","","Start: ", "red","",string.format("%-"..l1.."s",v.planet1.name),
      "silver",""," (","red","",string.format("%-"..l2.."s",v.resource1.name),
      "silver","",") End: ","red","",string.format("%-"..l3.."s",v.planet2.name),
      "silver",""," (", "red","",string.format("%-"..l4.."s",v.resource2.name),
      "silver","",") Profit: ","red","",string.format("%.2f",v.profit), 
      "silver",""," Time: ","red","",string.format("%dmin, %.2ds", math.floor(v.time/60), (v.time-(math.floor(v.time/60)*60))),
      "silver",""," Value: ","red","",string.format("%.1f", v.value*1000)
      )
    end
  end
	
end

function calculateRouteValue(sys1, sys2, resourcecost1, resourcecost2, tax1, tax2)
	local distance = distance(sys1, sys2)
	local time = (((((distance * 10) / 95) * 1000) / 50) * 2)
	-- extra time it takes to get from A to B not including hyperspace. Launch time/calculation time/land time
  -- 270 = launch time/calc time/land time, 80 = cargo buy/sell time
	local constant = 270 + 80
	time = time + constant
	local profit = ((resourcecost1 * ((100-tax1)/100)) - (resourcecost2 * ((100-tax2)/100)))
	--Note("sys1: "..sys1.name.." sys2: "..sys2.name.." res1: "..resourcecost1.." res2: "..resourcecost2.." distance: "..distance.." profit: "..profit.." value: "..profit/distance)
	return profit, time
end

function distance(a, b)
	return math.sqrt(((a.x-b.x)*(a.x-b.x))+((a.y-b.y)*(a.y-b.y)))
end

function showplanetSuccess(name, list, args)
	EnableTriggerGroup("ResourceCap", true)
	EnableTriggerGroup("GagAll", true)
end

function showplanetFailure(name, list, args)
	EnableTriggerGroup("ResourceCap", false)
	EnableTriggerGroup("GagAll", false)
	EnableTriggerGroup("ResourceStart", false)
	ColourNote("red","","Invalid planet, unable to continue.")
end

function resourceEnd(name, list, args)
	EnableTriggerGroup("ResourceCap", false)
	DeleteLines(1)
	percent = percent + 1
	ColourNote("silver","",string.format("%.0f", (percent*100)/(numBodies*2)) .. "% complete.")
	if (percent >= (numBodies*2)) then
		percent = 0
		EnableTriggerGroup("GagAll", false)
		scanNext()
	end
end

function storeTempPlanet(name, list, args)
	tempPlanet = Trim(args[1])
end

function storeTempSystem(name, list, args)
	tempSystem = Trim(args[1])
end

function cleanUp()
	DeleteLines(1)
end

function scanNext(name, list, args)
	toggleSystemCapOff()
	toggleBodyCapOff()
	if (scanned == "none") then
		SendNoEcho("config -prompt")
    EnableTriggerGroup("GagAll", true)
		clearTables()
		ColourNote("silver","","Starting resource scan... this may take a few moments.")
		scanned = "systems"
		SendNoEcho("stars")
		toggleSystemCapOn()
	elseif (scanned == "systems") then
		scanned = "planet"
		SendNoEcho("planets")
		toggleBodyCapOn()
	elseif (scanned == "planet") then
		scanned = "moon"
		SendNoEcho("moons")
		toggleBodyCapOn()
	elseif (scanned == "moon") then
		scanned = "resources"
		numBodies = 0
			for k, v in pairs(systems) do
				for ka, va in pairs(v.bodies) do
					numBodies = numBodies + 1
					tempPlanet = ""
					tempSystem = ""
					SendNoEcho("showplanet \"" .. va.name .. "\"")
					SendNoEcho("showplanet \"" .. va.name .. "\" resources")
					SendNoEcho("show")
					EnableTriggerGroup("ResourceStart", true)
				end
			end
	elseif (scanned == "resources") then
		scanned = "none"
		EnableTriggerGroup("ResourceStart", false)
    EnableTriggerGroup("GagAll", false)
		SendNoEcho("config +prompt")
		ColourNote("silver","","Finished scanning galaxy resources. Found ",cyan,"",#systems,"silver",""," systems with ",cyan,"",numBodies,"silver",""," planets.")
    calculate_price_comparison()
    calculateRouteValues() -- this calculates the route values in an ordered list
    generateRoutes() -- this calculates route values in k,v pairs of routeValues[fromPlanet][toPlanet]
    -- this will be used to find best routes with more than 2 planets
    -- this is a variant of a traveling salesman problem
		listSystems()
	end
end

function cargoList()
  if #cPlanets == 0 then
    ColourNote("red","","Cargo route empty, add something first!")
  else
    ColourNote(gray,"","Cargo list contains ",cyan,"",#cPlanets,gray,""," planets: ")
    ColourNote(gray,"",string.rep("-", 57))
    ColourNote(gray,"","[",darkblue,"","Curr:",gray,"","] [",darkblue,"",string.format("%-14s", "Planet:"),gray,"","] [",darkblue,"",string.format("%-20s", "Resource:"),gray,"","] [",darkblue,"",string.format("%-7s", "Contra:"),gray,"","]")
    for i, v in ipairs(cPlanets) do
      ColourNote(gray,"","[",cyan,"",string.format("%-5s", ((i == cVar and "*") or "")),gray,"","] [",cyan,"",string.format("%-14s", v.name),gray,"","] [",cyan,"",string.format("%-20s", v.resource),gray,"","] [",cyan,"",string.format("%-7s",v.contraband),gray,"","]")
    end -- for
  end
  OnPluginSaveState()
  BroadcastPlugin(999, 'reload')
end

function storeBody(name, list, args)
	local storage = { name = "", type = "", tax = 0, x = 0, y = 0, z = 0, resources = {} }
	for k, v in pairs(systems) do
		local sysName = v.name
		if (string.find(args[0], sysName)) then -- if the system name was found in the grab text
			local bodyName = Trim(string.sub(args[0], 1, string.find(args[0], sysName)-1))  -- cut body name out of the grab text
			storage.name = bodyName															-- using system name as a point of reference
			storage.type = scanned
			v.bodies[#v.bodies+1] = storage
		end
	end
end

function storeCoords(name, list, args)
	for k, v in pairs(systems) do
		for ka, va in pairs(v.bodies) do
			if (va.name == tempPlanet) then
				va.x = tonumber(args[1])
				va.y = tonumber(args[2])
				va.z = tonumber(args[3])
			end
		end
	end
end

function storeTax(name, list, args)
	for k, v in pairs(systems) do
		for ka, va in pairs(v.bodies) do
			if (va.name == tempPlanet) then
				va.tax = tonumber(args[1])
        Note(va.name .. " stored tax: "..va.tax)
			end
		end
	end
end

function storeResource(name, list, args)
	local storage = { name = "", price = 0 }
	for k, v in pairs(systems) do
		for ka, va in pairs(v.bodies) do
			local bodyName = va.name
			if (bodyName == tempPlanet) then
				storage.name = Trim(args[1])
				storage.price = tonumber(args[2])
				va.resources[#va.resources+1] = storage
			end
		end	
	end
end
		
function toggleBodyCapOn(name, list, args)
	EnableTriggerGroup("BodyCap", true)
end

function toggleSystemCapOn(name, list, args)
	EnableTriggerGroup("SystemCap", true)
end

function storeSystem(name, list, args)
	local storage = {
		name = "",
		x = 0,
		y = 0,
		bodies = {}
		}
	if (args[1] and args[2] and args[3]) then
		storage.name = Trim(args[1])
		storage.x = tonumber(args[2])
		storage.y = tonumber(args[3])
		systems[#systems+1] = storage
	end
end

function clearTables()
	systems = {}
	ColourNote("yellow","","Cargo Tables cleared.")
end

function toggleSystemCapOff(name, list, args)
	EnableTriggerGroup("SystemCap", false)
end

function toggleBodyCapOff(name, list, args)
	EnableTriggerGroup("BodyCap", false)
end
-- define our help command structure
local commands = { { name = "cargoScan", desc = "Scans every system in the galaxy into the cargo database.",
                         args = {  }
                          },
               { name = "cargoBest", desc = "Searches through the cargo database to find the most profitable route.",
                        args = { { name = "<none>", desc = "Searches through cargo database to find the most profitable route in the entire galaxy."}, 
                                 { name = "<keyword>", desc = "Searches through cargo database to find the most profitable route from the given planet."},
                                 { name = "<num_planets> <keyword>", desc = "Indicate the maximum number of planets you would like to search for best routes. Searches through cargo database to find the most profitable route from the given keyword.\nWARNING: Searching many planets can get taxing quickly, any more than 4 or 5 will take several seconds for the operation to complete.\nDuring which time, your screen will appear frozen."},
                                  }
                          },
               { name = "cargoBestOld", desc = "Searches through the cargo database to find the most profitable route.",
                        args = { { name = "<none>", desc = "Searches through cargo database to find the most profitable route in the entire galaxy."}, 
                                 { name = "<planet>", desc = "Searches through cargo database to find the most profitable route from the given planet."}, }
                          },
               { name = "listSystems", desc = "Displays every system currently saved in the cargo database for debug purposes.",
                        args = { }
                          },
               { name = "cargoSetup", desc = "Initiates automatic prompting for information about cargo planets.",
                        args = { }
                          },
               { name = "cargoShip", desc = "Used to manually set the name of your cargo ship. This has been superceded by the cargoShipProfile and cargoShipList system, see below.",
                        args = { { name = "<shipname>", desc = "Assigns the given name as your current cargo ship."}, }
                          },
               { name = "cargoPlanets", desc = "Used to manually define your cargo running route.",
                        args = { { name = "<planet1>,<resource1>,<contraband>,<planet2>,<resource2>,<contraband>...", desc = "Manually define your cargo running route with comma-separated parameters. Must list planet, resource and contraband in triplets."},
                                 { name = "best <number> <on/off>", desc = "Use this syntax to load a cargobest result into your cargo planets list automatically. Third parameter on/off is optional for trafficking setting, it will default to off." }, }
                          },
               { name = "cargoList", desc = "Displays the current cargo running specifications.",
                        args = { }
                          },
               { name = "cargoStart", desc = "Begins cargo running from the first planet in the given cargoList.",
                        args = { }
                          },
               { name = "cargoCycle", desc = "Toggles whether to continue running cargo on a loop, or stop once the end of the list has been reached.",
                        args = { }
                          },
               { name = "cargoManifest", desc = "Displays the saved cargo manifest detailing your cargo ship contents.",
                        args = { }
                          },
               { name = "cargoManifestClear", desc = "Clears out the cargo manifest so it can be rescanned.",
                        args = { { name = "<ship>", desc = "Clear only the cargo on the given ship." } }
                          },
               { name = "cargoAuto", desc = "Toggles automatic cargo running on or off.",
                        args = { { name = "<on/off>", desc = "Sets automatic cargo running status to the given parameter."}, }
                          },
               { name = "cargoClear", desc = "Clears all cargo running settings.",
                        args = { }
                          },
               { name = "cargoEfficiency", desc = "Displays some stats to show how pro your cargo running skills are.",
                        args = { }
                          },
               { name = "cargoHelp", desc = "Displays this help file.",
                        args = { { name = "<command>", desc = "Displays more detailed information on the specified command."}, }
                          },
               { name = "cargoNext", desc = "Manually skip to the next planet in your route.",
                        args = {  }
                          },
               { name = "cargoShipProfileList", desc = "Display the full parameters of the working cargo ship profile.",
                        args = {  }
                          },
               { name = "cargoShipProfileName", desc = "Set the name of the working cargo ship profile.",
                        args = { { name = "<name>", desc = "This should be the name of the cargo ship you are defining in this profile."}, }
                          },
               { name = "cargoShipProfileSetup", desc = "Prompt for every field necessary for a cargo ship profile.",
                        args = {  }
                          },
               { name = "cargoShipProfileClear", desc = "Erase the working cargo ship profile.",
                        args = {  }
                          },
               { name = "cargoShipProfileLoad", desc = "Load a cargo ship profile stored in the cargo ship database into the working profile.",
                        args = { { name="<name>", desc="Load first matching instance of name from cargo ship database into working cargo profile." },
                                 { name="<#>", desc="Load profile number from cargo ship database into working cargo profile." } }
                          },
               { name = "cargoShipProfileSave", desc = "Save the working cargo ship profile into the cargo ship database without clearing the working profile.",
                        args = {  }
                          },
               { name = "cargoShipProfilePush", desc = "Save the working cargo ship profile into the cargo ship database and clear the working profile.",
                        args = {  }
                          },
               { name = "cargoShipDBList", desc = "Display cargo ship profiles stored in cargo ship database.",
                        args = {  }
                          },
               { name = "cargoShipDBRem", desc = "Remove a cargo ship profile from the cargo ship database.",
                        args = { { name="<name>", desc="Remove first matching instance of name from cargo ship database. Will match ship name or ship type." } }
                          },
               { name = "cargoShipDBClear", desc = "Erase the cargo ship database.",
                        args = {  }
                          },
               { name = "cargoShipDBRename", desc = "Rename a profile in the cargo ship database. *NOT CURRENTLY IMPLEMENTED*",
                        args = {  }
                          },
               { name = "cargoShipList", desc = "Display current list of cargo ship parents and children.",
                        args = {  }
                          },
               { name = "cargoShipAdd", desc = "Add a cargo ship into cargo ship list from cargo ship database.",
                        args = { { name="<ship>", desc="Used with a single argument, ship is loaded into main cargo ship list as primary cargo running vessel.", },
                                 { name="<child> <parent>", desc="Used with two arguments, the first ship is loaded into cargo ship list as a child of the parent ship in the first available hangar space of parent ship.", },
                                 { name="<child> <parent> <hangar>", desc="Used with three arguments, the first ship is loaded into the cargo ship list as a child of the parent ship in the designated hangar, if there is enough space." } }
                          },
               { name = "cargoShipRem", desc = "Remove a cargo ship from cargo ship list. *NOT CURRENTLY IMPLEMENTED*",
                        args = {  }
                          },
               { name = "cargoShipClear", desc = "Clear cargo ship list.",
                        args = {  }
                          },
               { name = "cargoLoadShips", desc = "Load all child ships into parent hangars.",
                        args = {  }
                          },
               { name = "cargoUnloadShips", desc = "Unload all child ships from parent hangars.",
                        args = {  }
                          },
               { name = "cargoTransactions", desc = "Print a list of all logged cargo transactions.",
                        args = {  }
                          },
               { name = "cargoTransactionsClear", desc = "Clear the cargo transactions log.",
                        args = {  }
                          },
                        }
                        
  --[[ 
    <alias script="flyNext" match="cargonext" enabled="y" group="LotJCargo" ignore_case="y" sequence="100" />
  <alias match="^cargoShipProfileList(.*?)?$" script="shipProfileList" enabled="y" group="LotJCargo" ignore_case="y" regexp="y" sequence="100" />
  <alias match="^cargoShipProfileName(.*?)?$" script="shipProfileName" enabled="y" group="LotJCargo" ignore_case="y" regexp="y" sequence="100" />
  <alias match="^cargoShipProfileSetup(.*?)?$" script="shipProfileSetup" enabled="y" group="LotJCargo" ignore_case="y" regexp="y" sequence="100" />
  <alias match="^cargoShipProfileClear(.*?)?$" script="shipProfileClear" enabled="y" group="LotJCargo" ignore_case="y" regexp="y" sequence="100" />
  <alias match="^cargoShipProfileLoad(.*?)?$" script="shipProfileLoad" enabled="y" group="LotJCargo" ignore_case="y" regexp="y" sequence="100" />
  <alias match="^cargoShipProfileSave(.*?)?$" script="shipProfileSave" enabled="y" group="LotJCargo" ignore_case="y" regexp="y" sequence="100" />
  <alias match="^cargoShipProfilePush(.*?)?$" script="shipProfilePush" enabled="y" group="LotJCargo" ignore_case="y" regexp="y" sequence="100" />
  <alias match="^cargoShipDBList(.*?)?$" script="shipDBList" enabled="y" group="LotJCargo" ignore_case="y" regexp="y" sequence="100" />
  <alias match="^cargoShipDBRem(.*?)?$" script="shipDBRem" enabled="y" group="LotJCargo" ignore_case="y" regexp="y" sequence="100" />
  <alias match="^cargoShipDBClear(.*?)?$" script="shipDBClear" enabled="y" group="LotJCargo" ignore_case="y" regexp="y" sequence="100" />
  <alias match="^cargoShipDBRename(.*?)?$" script="shipDBRename" enabled="y" group="LotJCargo" ignore_case="y" regexp="y" sequence="100" />
  <alias match="^cargoShipList$" script="shipCargoList" enabled="y" group="LotJCargo" ignore_case="y" regexp="y" sequence="100" />
  <alias match="^cargoShipAdd(.*?)?$" script="shipCargoAdd" enabled="y" group="LotJCargo" ignore_case="y" regexp="y" sequence="100" />
  <alias match="^cargoShipRem(.*?)?$" script="shipCargoRem" enabled="y" group="LotJCargo" ignore_case="y" regexp="y" sequence="100" />
  <alias match="^cargoShipClear?$" script="shipCargoClear" enabled="y" group="LotJCargo" ignore_case="y" regexp="y" sequence="100" />
  <alias match="^cargoLoadShips$" script="loadShips" enabled="y" group="LotJCargo" ignore_case="y" regexp="y" sequence="100" />
  <alias match="^cargoUnloadShips$"
  ]]--

function cargoHelp(name, line, args)
  local found = false
  if args[1] == "" then -- show general help
    ColourNote("white","",GetPluginInfo(GetPluginID(), 1),"cyan",""," v"..VERSION,"white",""," by "..AUTHOR..". Enter '","red","","cargohelp <command>","white","","' for more detailed information.")
    for a, b in ipairs(commands) do -- commands
      local command = b
      ColourNote("red","",string.format("%-20s", command.name),"silver",""," : "..command.desc)
    end
    Note()
  else -- entered something
    ColourNote("white","",GetPluginInfo(GetPluginID(), 1),"cyan",""," v"..VERSION,"white",""," by "..AUTHOR..". Enter '","red","","cargohelp","white","","' for more general information.")
    for a, b in ipairs(commands) do -- scroll through commands
      if (string.match(b.name:lower(), Trim(args[1]):lower())) then -- found our argument, using string match allows for partial matches
        found = true
        ColourNote("red","",b.name,"silver",""," : " .. b.desc)
        ColourNote("silver","","Available arguments:")
        if #b.args == 0 then -- no arguments
          ColourNote("red","","   None.")
        else -- arguments to print
          for i, k in ipairs(b.args) do
            ColourNote("red","",string.format("%20s", k.name),"silver",""," : " .. k.desc)
          end -- end print arguments
        end -- end no arguments
        Note()
      end -- end found command
    end -- end scroll commands
    if not found then
      ColourNote("red","","Command '"..args[1].."' not found.")
    end
  end -- end no input
end
require "checkplugin"

function OnPluginListChanged()
	do_plugin_check_now ("680bf1a4e5e600854747c379", "LotJFlight") -- check we have LotJFlight Plugin
	do_plugin_check_now ("b2c06b3dcc775c0ede861316", "LotJCalc") -- check we have LotJCalc Plugin
end
  ]]> 
  </script>
 <!--   Plugin help    -->
  <aliases>
  <alias script="OnHelp" match="LotJCargo:help" enabled="y" /> 
  </aliases>
 <script>
 <![CDATA[ function OnHelp ()
  world.Note (world.GetPluginInfo (world.GetPluginID (), 3))
end
  ]]> 
  </script>
  </muclient>
