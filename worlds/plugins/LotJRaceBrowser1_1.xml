<?xml version="1.0" encoding="iso-8859-1" ?> 
<!DOCTYPE muclient> 
<muclient>
<plugin name="LotJRaceBrowser" author="@Johnson" id="a4e8153e52b1b6d490ed4b10" language="Lua" purpose="Browse LotJ Races" save_state="y" requires="4.84" version="1.1">
<description trim="y">
<![CDATA[ 
Sections of this plugin are based on work by Fiendish of Aardwolfmud and other community members.
See 'http://www.gammon.com.au/forum/?id=9385'
To use this plugin:
Type 'racescan' to gather information from the game and populate into the browser.
Type 'raceshow' to display the browser if you previously closed it.
Type 'racehide' or click the X to close the browser.
Type 'raceclear' to clear the stored race information.
This plugin creates a visual index of all current LotJ races. The race list can be sorted by
right clicking anywhere in the window and choosing filters to apply.

Changenotes:
This is updated for Regnawm's showrace change by @Domovoi
  ]]> 
  </description>
  </plugin>
<!--   Get our standard constants   --> 
	<include name="constants.lua" /> 
<!--   Triggers    --> 
<triggers>

  <trigger match="^(\[([\s\d]+)\/([\s\d]+)\]\:)(\s+)([A-Za-z'_]{3,}+)(\s+)?([A-Za-z'_]{3,}+)?(\s+)?([A-Za-z'_]{3,}+)?(\s+)?([A-Za-z'_]{3,}+)?(\s+)?$" script="raceListScanAdd" regexp="y" enabled="n" group="RacelistScan"  omit_from_output="y" omit_from_log="y" sequence="100" />
  <trigger match="^^(\s+)([A-Za-z'_]{3,}+)(\s+)?([A-Za-z'_]{3,}+)?(\s+)?([A-Za-z'_]{3,}+)?(\s+)?([A-Za-z'_]{3,}+)?(\s+)?$" script="raceListScanAdd" regexp="y" enabled="n" group="RacelistScan"  omit_from_output="y" omit_from_log="y" sequence="100" />
  <trigger match="^(\[App Only ]\:)(\s+)([A-Za-z'_]{3,}+)(\s+)?([A-Za-z'_]{3,}+)?(\s+)?([A-Za-z'_]{3,}+)?(\s+)?([A-Za-z'_]{3,}+)?(\s+)?$" script="raceListScanAdd" regexp="y" enabled="n" group="RacelistScan"  omit_from_output="y" omit_from_log="y" sequence="100" />
<!--  <trigger match="^([\s\d]+)\((\d)\)\> (.*) (\d+)\((\d)\)\> (.*)$" script="raceListScanAdd" regexp="y" enabled="n" group="RacelistScan"  omit_from_output="y" omit_from_log="y" sequence="100" />
  <trigger match="^([\s\d]+)\((\d)\)\> (.*)$" script="raceListScanAdd" regexp="y" enabled="n" group="RacelistScan"  omit_from_output="y" omit_from_log="y" sequence="100" />
-->
  <trigger name="RacelistScanStart" match="-------------------------------------------------------------------------" script="enableRaceListScan" regexp="n" enabled="n"  omit_from_output="y" omit_from_log="y" sequence="100" />
  <trigger name="RacelistScanStop" match="^$" script="stopRacelistScan" regexp="y" enabled="n"  omit_from_output="y" omit_from_log="y" sequence="100" />
  
  <trigger lines_to_match="5"
   match="^\(R\)ace\: (.*)\n   Str Plus\:([\s\d,-]+)Dex Plus\:([\s\d,-]+)Wis Plus\:([\s\d,-]+)Int Plus\:([\s\d,-]+)\n   Con Plus\:([\s\d,-]+)Cha Plus\:([\s\d,-]+)Lck Plus\:([\s\d,-]+)\n   Hit Pts:([\s\d,-]+)AC Mod:([\s\d,-]+)Frc Plus:([\s\d,-]+)\n   Price\:([\s\d,-]+)Deposit\:([\s\d,-]+)App Only\:(.*)\Z"
   script="addRaceScanFirst"
   multi_line="y"
   regexp="y"
   enabled="n"
   group="raceScanFirst" omit_from_output="y" omit_from_log="y" 
   sequence="100" />
  
  <trigger match="^Players of this race must pick (.*) as their main\.$" script="addRaceMainClass" regexp="y" enabled="n" group="raceScanSecond"  omit_from_output="y" omit_from_log="y" sequence="100" />
  
  <trigger lines_to_match="2" match="\(D\)efault Language\: (.*)\n\(P\)ossible Skincolors\: \Z" script="addRaceScanSecond" multi_line="y" regexp="y" enabled="n" group="raceScanSecond" omit_from_output="y" omit_from_log="y" sequence="100" />
  
  <trigger match="^\((\d+)\)([\w\s]+)\((\d+)\)([\w\s]+)$" script="addSkinColors" regexp="y" group="SkinColors" enabled="n"  omit_from_output="y" omit_from_log="y" sequence="100" />
  <trigger match="^\((\d+)\)([\w\s]+)$" script="addSkinColors" regexp="y" group="SkinColors" enabled="n"  omit_from_output="y" omit_from_log="y" sequence="100" />
  <trigger match="^$" script="stopSkinColors" regexp="y" group="SkinColors" enabled="n"  omit_from_output="y" omit_from_log="y" sequence="100" />
  <trigger match="^(.*) \- (.*)$" script="addExtraAttrib" regexp="y" group="ExtraAttribs" enabled="n"  omit_from_output="y" omit_from_log="y" sequence="100" />
  <trigger match="^$" script="stopExtraAttribs" regexp="y" group="ExtraAttribs" enabled="n"  omit_from_output="n" omit_from_log="y" sequence="100" />
  <trigger match="^(.*)   (.*)$" script="addRaceLevels" regexp="y" group="RaceLevels" enabled="n"  omit_from_output="y" omit_from_log="y" sequence="100" />
  <!--trigger match="^science(.*)$" script="stopRaceLevels" regexp="y" group="RaceLevels" enabled="n"  omit_from_output="y" omit_from_log="y" sequence="101" -->
  <trigger name="gagAll" match="^(.*)$" regexp="y" keep_evaluating="y" omit_from_output="y" omit_from_log="y" enabled="n" sequence="100" />
</triggers>

<aliases>

	<alias match="racescan" script="startRacelistScan" enabled="y" regexp="n" ignore_case="y" group="LotJRaceBrowser" sequence="100" />
	<alias match="raceclear" script="clearTable" enabled="y" regexp="n" ignore_case="y" group="LotJRaceBrowser" sequence="100" />
	<alias match="raceshow" script="showWindow" enabled="y" regexp="n" ignore_case="y" group="LotJRaceBrowser" sequence="100" />
	<alias match="racehide" script="hideWindow" enabled="y" regexp="n" ignore_case="y" group="LotJRaceBrowser" sequence="100" />
  <alias match="raceprint *" script="printRace" enabled="y" regexp="n" ignore_case="y" group="LotJRaceBrowser" sequence="100" />



</aliases>
<!--   Script    --> 
<script>
<![CDATA[
require "movewindow"
require "copytable"
require "serialize"
require "tprint"
require "pairsByKeys"
 -- enable these to ensure everything works smooth
SetOption("enable_triggers", true)
SetOption("enable_scripts", true)
local AUTHOR = GetPluginInfo(GetPluginID(), 2) -- author info
local VERSION = string.format("%1.2f", GetPluginInfo(GetPluginID(), 19)) -- version info
local win = "win_" .. GetPluginID()  -- unique window name
local font = "f"
local default_font_name = GetInfo(20)
local default_font_size = GetInfo(243)
local font_name = GetVariable("font_name") or default_font_name
local font_size = tonumber(GetVariable("font_size")) or default_font_size
local RESIZE_TAG_SIZE = 10
local visible = GetVariable("visible") or "true"
local MIN_WIDTH   = 50
local MIN_HEIGHT  = 50
local MIN_SPLIT   = 75
local redraw_scheduled = false
-- default config
local default_config = {  height = 300,
            width = 750,
            split = 150, -- location from left for window split
            backcolor = "black",
            }
-- replace default with loaded config
loadstring(GetVariable("config") or "") ()
local SCROLL_BACKGROUND_COLOUR = 0xE8E8E8
local SCROLL_BAR_COLOUR = 0x111111
local SCROLL_DETAIL_COLOUR = 0x000000
local SCROLL_BAR_WIDTH = 15
local titleHeight = 0
local lastRefresh = 0
local filter_main_class = ""
local filter_classes = {}
local filter_stats = {}
races = {}
local newRace = {}
local raceSelected = -1
local raceDisplayedStart = 0
local raceDisplayedEnd = 0
local raceLineHeight = 0
local spacer = 3
local currentRace = {}
local currentRaceIndex = 0
local skinColors = {}
local extraAttribs = {}
local raceLevels = {{}}
local text = {}
local textStart = 0
local textEnd = 0
local lines = {}
local polys = {}
loadstring(GetVariable("races") or "") ()
function printBrowseList()
  local posy = titleHeight
  local font_height = WindowFontInfo(win, font, 1)
  if #races > 0 then
    for i = raceDisplayedStart, raceDisplayedEnd do
      WindowText (win, font, races[i].name, 5, posy, 0, 0, ColourNameToRGB(((i==raceSelected and "red") or ((races[i].str~=nil and "white") or "darkgray"))))
      posy = posy + font_height + spacer
    end
  end
end
function printRace(name, line, args)
  local num = tonumber(args[1])
  if num then
    if races[num] then
      tprint(races[num])
    end
  end
end
function raceClick()
  hottop = WindowHotspotInfo(win, "leftbackground", 2)
  clickpos = WindowInfo(win, 15)
  raceIndex = math.floor((clickpos-hottop)/raceLineHeight)+raceDisplayedStart
  --Note("tFit: "..textFit.." tStart: "..textStart.." eEnd: "..textEnd.." #text: "..#text)
  updateSelectedRace()
end
function updateRaceText()
  if raceSelected > -1 then -- we chose something
    local race = races[raceSelected]
    if race.price == nil or race.deposit==nil or race.language==nil or race.ac==nil or race.hp==nil or race.apponly==nil or race.str==nil or race.dex==nil or race.con==nil or race.int==nil or race.wis==nil or race.cha==nil or race.frc==nil or race.lck==nil or race.erarestrict==nil then
      -- tried to access while still scanning or invalid scan data
      addText( {"red","Either your race data is invalid or scan is still underway..."}, font, "center")
      textEnd = math.min(#text, textStart+textFit-2)
      return
    end
    if race ~= nil then
      text = {} -- clear the text
      lines = {}
      polys = {}
      local left = config.split+2
      local top = titleHeight
      local right = config.width-SCROLL_BAR_WIDTH
      local bot = config.height
      local filler = string.rep("-", 20)
      local title_width = WindowTextWidth(win, font, race.name)
      addText( {"white",filler.."Race"..filler}, font, "center")
      addText( {"cyan",race.name}, font, "center")
      
      addText( {"white", filler.."Stats"..filler}, font, "center")
      addText( {"white","Price: ",((race.price==0 and "lime") or "red"),race.price,"white"," Deposit: ",((race.deposit==0 and "lime") or "red"),race.deposit,"white"," Language: ","red",race.language}, font, "center")
      addText( {"white","AC: ","red",race.ac,"white"," Base HP: ","red",race.hp,"white"," App Only: ",((race.apponly=="Yes" and "red") or "lime"),race.apponly}, font, "center")
      addText( {"white","Str: ","red",race.str,"white"," Dex: ","red",race.dex,"white"," Con: ","red",race.con}, font, "center")
      addText( {"white","Int: ","red",race.int,"white"," Wis: ","red",race.wis,"white"," Cha: ","red",race.cha}, font, "center")
      addText( {"white","Frc: ","red",race.frc,"white"," Lck: ","red",race.lck,"white"," Era Restrict: ",((race.erarestrict==0 and "lime") or "red"),race.erarestrict}, font, "center")
      
      addText( {"white",filler.."Levels"..filler}, font, "center")
      local levelTitle = "               COM PIL ENG HUN SMU LEA ESP SLI MED SCI"
      addText( {"white",levelTitle}, font, "center")
      -- spacing stuff for class filter highlighting
      local levelTitleWidth = WindowTextWidth(win, font, "  "..levelTitle)
      local levelClassWidth = WindowTextWidth(win, font, "                ")
      local spaceWidth = WindowTextWidth(win, font, " ")
      local levelHeadingWidth = WindowTextWidth(win, font, " COM")
      
      local bound = { left = config.split+2, top = titleHeight, right = config.width-SCROLL_BAR_WIDTH, bot = config.height-2 } -- valid bounding box for drawing
      
      -- add highlight box for class filters
      for _, v in pairs(filter_classes) do
        local index = class_matrix[v] or 0
        local line = { left = (bound.left+((bound.right-bound.left)/2))-(levelTitleWidth/2)+levelClassWidth+(levelHeadingWidth*(index-1))-1,
                       top = bound.top+((#text-textStart)*textLineHeight),
                       right = (bound.left+((bound.right-bound.left)/2))-(levelTitleWidth/2)+levelClassWidth+(levelHeadingWidth+(levelHeadingWidth*(index-1)))-spaceWidth,
                       bot = bound.top+(((#text-textStart)+#matrix_class+1)*textLineHeight) }
        addPoly( string.format("%i,%i,%i,%i,%i,%i,%i,%i", line.left, line.top, line.right, line.top, line.right, line.bot, line.left, line.bot), ColourNameToRGB("white"), 1+0x2000, 1, ColourNameToRGB("white"), 1, true, false )
      end
            
      for a, b in pairsByKeys(race.levels) do
        local t = {}
        t[#t+1]=((a==race.mainclass and "cyan") or "white")
        t[#t+1]=string.format("%14s",a)..": "
        for i, j in ipairs(b.levels) do
          t[#t+1]=((tonumber(j)>130 and "red") or ((tonumber(j)>100 and "yellow") or ((tonumber(j)>70 and "cyan") or ((tonumber(j)>30 and "lime") or "blue"))))
          --((j=="5" and "red") or ((j=="4" and "yellow") or ((j=="3" and "cyan") or ((j=="2" and "lime") or "blue")))) 
          t[#t+1]=j.." "
        end
        addText( t, font, "center")
        -- add highlight box for main class filter
        if a==filter_main_class then
          local alltext = ""
          for x, y in ipairs(t) do
            if math.fmod(x-1, 2)==1 then -- text
              alltext = alltext..y
            end
          end
          local textWidth = WindowTextWidth(win, font, alltext)
          local line = { left = ((bound.left+((bound.right-bound.left)/2))-(textWidth/2)), top = bound.top+((#text-textStart)*textLineHeight), right = ((bound.left+((bound.right-bound.left)/2))+(textWidth/2)), bot = bound.top+(((#text-textStart)+1)*textLineHeight) }
          --addLine( line.left, line.top, line.right, line.top, ColourNameToRGB("white"), 0+0x0100, 1 )
          --addLine( line.left, line.bot, line.right, line.bot, ColourNameToRGB("white"), 0+0x0100, 1 )
          --addLine( line.left, line.top, line.left, line.bot, ColourNameToRGB("white"), 0+0x0100, 1 )
          --addLine( line.right, line.top, line.right, line.bot, ColourNameToRGB("white"), 0+0x0100, 1 )
          addPoly( string.format("%i,%i,%i,%i,%i,%i,%i,%i", line.left, line.top, line.right, line.top, line.right, line.bot, line.left, line.bot), ColourNameToRGB("white"), 1+0x2000, 1, ColourNameToRGB("white"), 1, true, false )
        end
      end
      if #race.attribs > 0 then
        addText( {"white",filler.."Extra Arributes"..filler}, font, "center")
        local temp = ""
        for i, j in ipairs(race.attribs) do
          addText( {"lime",j.name,"white"," - ","lime",j.desc}, font, "center")
        end
      end
    textEnd = math.min(#text, textStart+textFit-2)
    end
  end
  
end
function addText(addtext, font, align, pos)
  local line = { t = copytable.deep(addtext), f = font, a = align, p = pos }
  text[#text + 1] = line
end
function addLine(x1, y1, x2, y2, pencolour, penstyle, penwidth)
  --[[  pencolour is RGB colour for this line
        penstyle is 0 -- solid
                    1 -- dash: -------
                    2 -- dot:  .......
                    3 -- dashdot: _._._._.
                    4 -- dashdotdot: _.._.._
                    5 -- null (no pen)
                    6 -- insideframe: a solid pen, dawn inside the shape
                 
    -- also you can add in the style:
    
      0x0000 - round ends (0 = the default)
      0x0100 - square ends (256)
      0x0200 - flat ends (512)
      0x0000 - round joins (0 = the default)
      0x1000 - bevel joins (4096)
      0x2000 - miter joins (8192)
      
        penwidth - width of the pen in pixels. for styles 1 to 4 only a width of 1 is valid.
                   for a particular shape, specify style 5 (no pen) if you only want to fill 
                   the shape, and not stroke it as well.
      
    ]]--
    local line = { x1 = x1, y1 = y1, x2 = x2, y2 = y2, pc = pencolour, ps = penstyle, pw = penwidth }
    lines[#lines + 1] = line
end
function addPoly(points, pencolour, penstyle, penwidth, brushcolour, brushstyle, close, winding)
  local line = { p = points, pc = pencolour, ps = penstyle, pw = penwidth, bc = brushcolour, bs = brushstyle, cl = close, w = winding }
  polys[#polys + 1] = line
end
function drawText()
  --textEnd = math.min(textFit, #text)
  local posy = titleHeight
  local bound = { left = config.split+2, top = titleHeight, right = config.width-SCROLL_BAR_WIDTH, bot = config.height-2 } -- valid bounding box for drawing
  if #text >= 1 then
    for i = textStart, textEnd do
      v = text[i]
      if v~=nil then
        local pos = {}
        local alltext = ""
        for a, b in ipairs(v.t) do
          if math.fmod(a-1, 2)==1 then -- text
            alltext = alltext..b
          end
        end
      local textWidth = WindowTextWidth(win, v.f, alltext)
      local textHeight = WindowFontInfo(win, v.f, 1)
      if v.a == "left" then
        pos = { left = bound.left, top = posy, right = bound.left+textWidth, bot = posy+textHeight }
      elseif v.a == "center" then
        pos = { left = (bound.left+((bound.right-bound.left)/2))-(textWidth/2), top = posy, right = (bound.left+((bound.right-bound.left)/2))+(textWidth/2), bot = posy+textHeight }
      elseif v.a == "right" then
        pos = { left = bound.right-textWidth, top = posy, right = bound.right, bot = posy+textHeight }
      else
        pos = v.p
      end
      local colour = ""
      for a, b in ipairs(v.t) do
        if math.fmod(a-1, 2)==0 then -- got the colour
          colour = b
        elseif math.fmod(a-1, 2)==1 then -- got the text
          tWidth = WindowTextWidth(win, v.f, b)
          pos.left = pos.left + WindowText(win, v.f, b, pos.left, pos.top, pos.left+tWidth, pos.bot, ColourNameToRGB(colour))
        end
      end
      posy = posy + textLineHeight
    end
  end
  end
end
function drawLines()
  for i, v in ipairs(lines) do
    WindowLine(win, v.x1, v.y1, v.x2, v.y2, v.pc, v.ps, v.pw)
  end
end
function drawPolys()
  for i, v in ipairs(polys) do
    WindowPolygon(win, v.p, v.pc, v.ps, v.pw, v.bc, v.bs, v.cl, v.w)
  end
end
function findBestClass(levels)
  local best = 0
  
end
function addLevels(list)
  local total = 0
  for i, v in pairs(list) do
    total = total + v
  end
  return total
end

--[[
function raceListScanAdd(name, line, args)
  local race = {}
  for i, v in pairs(args) do
    if math.fmod(i-1, 3)==0 then -- index
      race.index = tonumber(v)
      --Note("found race index: "..v)
    elseif math.fmod(i-1, 3)==1 then -- era restrict
      race.erarestrict = tonumber(v)
      --Note("found era restrict: "..v)
    elseif math.fmod(i-1, 3)==2 then -- race name
      race.name = Trim(v)
      --Note("found race name: "..v)
      races[#races + 1] = race
      race = {}
    end
  end
end
]]--

function raceListScanAdd(name, line, args)
    local race = {}
    local numargs = #args
    local i = 1
    while (i < numargs) do
        if string.match (tostring(args[i]), "([A-Za-z'_]+)") then
            if tostring(args[i])=="[App Only ]:" then
                i=i+1
            else
            --Found race
            race.index = #races + 1
            race.erarestrict = 0
            race.name = args[i]
            races[#races + 1] = race
            i=i+1
            race = {}
            end
        else
            i=i+1
        end
    end
end

function startRacelistScan(name, line, args)
  races = {}
  SendNoEcho("showrace")
  EnableTrigger("RacelistScanStart", true)
  EnableTrigger("gagAll", true)
  ColourNote("yellow", "", "Racelist Scan started...")
end
function enableRaceListScan(name, line, args)
  EnableTriggerGroup("RacelistScan", true)
  EnableTrigger("RacelistScanStart", false)
  EnableTrigger("RacelistScanStop", true)
  
end
function stopRacelistScan(name, line, args)
  EnableTriggerGroup("RacelistScan", false)
  EnableTrigger("RacelistScanStart", false)
  EnableTrigger("RacelistScanStop", false)
  ColourNote("yellow", "", "Racelist Scan complete. Found "..#races.." races.")
  races.scantime = os.time()
  SetUpHotspotsAndDraw(false)
  --tprint(races)
  startRaceScan()
end
function startRaceScan(name, line, args)
  currentRaceIndex = 0
  ColourNote("yellow", "", "Race Scan started...\n\n")
  scanNextRace()
end
function scanNextRace(name, line, args)
  currentRaceIndex = currentRaceIndex + 1
  if currentRaceIndex > #races then
    ColourNote("yellow","","Race Scan complete.")
    EnableTrigger("gagAll", false)
    --tprint(races)
  else
    currentRace = races[currentRaceIndex]
    DeleteLines(1)
    ColourNote("silver","","Scan "..string.format("%2.2f",((currentRaceIndex/#races)*100)).."% completed.")
    SendNoEcho("showrace "..currentRace.name)
    EnableTriggerGroup("raceScanFirst", true)
  end
  scheduleRedraw()
end
function sortByAlpha()
  table.sort(races, function (k1, k2) return k1.name < k2.name end )
  clearFilters()
end
function sortByFilter(class, filter, stats)
  table.sort(races, function (k1, k2) return getSubclassLevelsByClass(k1, class, filter, stats) > getSubclassLevelsByClass(k2, class, filter, stats) end )
  updateSelectedRace()
end
function clearFilters()
  filter_main_class = ""
  filter_classes = {}
  filter_stats = {}
  updateSelectedRace()
end
  
function updateSelectedRace()
  if races[raceIndex] ~= nil then
    raceSelected = raceIndex
    updateRaceText()
  end
  forceRedraw()
end
class_matrix = {  ["combat"] = 1, 
                        ["piloting"] = 2, 
                        ["engineering"] = 3, 
                        ["bounty hunting"] = 4, 
                        ["smuggling"] = 5, 
                        ["leadership"] = 6, 
                        ["espionage"] = 7, 
                        ["slicer"] = 8, 
                        ["medical"] = 9, 
                        ["science"] = 10 }
                        
matrix_class = { "combat", "piloting", "engineering", "bounty hunting", "smuggling", "leadership", "espionage", "slicer", "medical", "science" }
matrix_stats = { "price", "deposit", "str", "dex", "con", "int", "wis", "cha", "frc", "lck", "ac", "hp", "apponly", "erarestrict" }
function getSubclassLevelsByClass(r, c, s, st)
  local num = 0
  if type(s)=="table" then
    for i, v in ipairs(s) do
      if c=="" then -- we didn't specify a class, take the average
        for a=1, #matrix_class do
          num = num + r.levels[matrix_class[a]].levels[class_matrix[v]]
        end
        num = num / #matrix_class
      else
        num = num + r.levels[c].levels[class_matrix[v]]
      end
    end
  end
  if st~=nil then
    if type(st)=="table" then
      for i, v in ipairs(st) do
        num = num + getRaceStat(r, v)
      end
    end
  end
  return num
end
function getRaceStat(r, s)
  if r[s] ~= nil then
    if s=="price" or s=="deposit" then -- normalize price and deposit to be in line with stats
      return -r[s]/1000
    elseif s=="apponly" then -- convert apponly into a number
      return ((r[s]=="Yes" and 10) or 0)
    elseif s=="ac" then -- convert ac to positive and normalize
      return -r[s]/25
    elseif s=="hp" then -- normalize hp
      return r[s]/250
    else
      return r[s]
    end
  end
end
function addRaceScanFirst(name, line, args)
-- "\(R\)ace\: (.*)\nStr Plus\: ([\s\d,-]+) Dex Plus\: ([\s\d,-]+) Wis Plus\: ([\s\d,-]+) Int Plus\: ([\s\d,-]+) \nCon Plus\: ([\s\d,-]+) Cha Plus\: ([\s\d,-]+) Lck Plus\: ([\s\d,-]+) \nHit Pts\: ([\s\d,-]+)AC Mod\: ([\s\d,-]+) Frc Plus\: ([\s\d,-]+) \nPrice\: ([\s\d,-]+)Deposit\: ([\s\d,-]+)App Only\: (.*)\n\(D\)efault Language\: (.*)\n\(P\)ossible Skincolors\:\Z"
  if currentRace.name ~= args[1] then
    ColourNote("red","","Mismatched race names detected ("..currentRace.name.."~="..args[1]..") aborting...")
    stopRaceScan()
    return
  end
  currentRace.str = tonumber(args[2])
  currentRace.dex = tonumber(args[3])
  currentRace.wis = tonumber(args[4])
  currentRace.int = tonumber(args[5])
  currentRace.con = tonumber(args[6])
  currentRace.cha = tonumber(args[7])
  currentRace.lck = tonumber(args[8])
  currentRace.hp =  tonumber(args[9])
  currentRace.ac =  tonumber(args[10])
  currentRace.frc = tonumber(args[11])
  currentRace.price = tonumber(args[12])
  currentRace.deposit = tonumber(args[13])
  currentRace.apponly = Trim(args[14])
  --currentRace.language = Trim(args[15])
  --races[currentRaceIndex] = currentRace
  EnableTriggerGroup("raceScanFirst", false)
  DeleteLines(1)
  startRaceScanSecond()
end
function addRaceMainClass(name, line, args)
  currentRace.mainclass = args[1]
end
function startRaceScanSecond(name, line, args)
  EnableTriggerGroup("raceScanSecond", true)
end
function addRaceScanSecond(name, line, args)
  currentRace.language = Trim(args[1])
  EnableTriggerGroup("raceScanSecond", false)
  DeleteLines(1)
  startSkinColors()
end
function startSkinColors(name, line, args)
  skinColors = {}
  EnableTriggerGroup("SkinColors", true)
end
function addSkinColors(name, line, args)
  local color = {}
  for i, v in pairs(args) do
    if math.fmod(i-1, 2)==0 then -- index
      color.index = tonumber(v)
      --Note("found race index: "..v)
    elseif math.fmod(i-1, 2)==1 then -- name
      color.name = Trim(v)
      --Note("found era restrict: "..v)
      skinColors[#skinColors + 1] = color
      color = {}
    end
  end
end
function stopSkinColors(name, line, args)
  EnableTriggerGroup("SkinColors", false)
  currentRace.skincolors = copytable.deep(skinColors)
  startExtraAttribs()
end
function startExtraAttribs(name, line, args)
  extraAttribs = {}
  EnableTriggerGroup("ExtraAttribs", true)
end
function addExtraAttrib(name, line, args)
  local attrib = { name = Trim(args[1]), desc = Trim(args[2]) }
  extraAttribs[#extraAttribs + 1] = attrib
end
  
function stopExtraAttribs(name, line, args)
  EnableTriggerGroup("ExtraAttribs", false)
  currentRace.attribs = copytable.deep(extraAttribs)
  startRaceLevels()
end
function startRaceLevels(name, line, args)
  raceLevels = {}
  EnableTriggerGroup("RaceLevels", true)
end
function addRaceLevels(name, line, args)
  local levels = {}
  --levels.class = Trim(args[1])
  args[2] = string.gsub(Trim(args[2]), "   ", " ")
  levels.levels = utils.split(Trim(args[2]), " ")
  --raceLevels[#raceLevels + 1] = levels
  raceLevels[Trim(args[1])] = levels
  if Trim(args[1])=="science" then stopRaceLevels(name, line, args) end
end
function stopRaceLevels(name, line, args)
  --Note("stopped race levels")
  EnableTriggerGroup("RaceLevels", false)
  currentRace.levels = copytable.deep(raceLevels)
  races[currentRaceIndex] = currentRace
  scanNextRace()
end
function stopRaceScan(name, line, args)
  Note("stopped race scan")
  EnableTriggerGroup("raceScanFirst", false)
  EnableTriggerGroup("SkinColors", false)
  EnableTriggerGroup("ExtraAttribs", false)
  EnableTriggerGroup("RaceLevels", false)
  EnableTrigger("gagAll", false)
end
function getRaceByIndex(index)
  for i, v in pairs(races) do
    if i==index then
      return v
    end
  end
  ColourNote("red","","Error, no race with that index ("..index..")")
  return
end
function beginScan(name, line, args)
end
function clearTable(name, line, args)
  races = {}
  text = {}
  config = default_config
  ColourNote("yellow","","Race list tables cleared.")
  OnPluginSaveState()
  SetUpHotspotsAndDraw(true)
end
function showWindow(name, line, args)
  visible = "true"
  scheduleRedraw()
end
function hideWindow(name, line, args)
  visible = "false"
  WindowShow(win, false)
end
function setupWindow(name, line, args)
end
function drawWindow(name, line, args)
	WindowRectOp (win, miniwin.rect_fill, 0, 0, config.width, config.height, ColourNameToRGB(config.backcolor))  -- draw blank rectangle to "erase" window contents
  -- drag handler
  movewindow.add_drag_handler (win, 0, 0, config.width-30, titleHeight)		
	 -- draw border
  WindowRectOp (win, miniwin.rect_draw_edge, 0, 0, 0, 0, miniwin.rect_edge_etched, miniwin.rect_edge_at_all)
  WindowRectOp (win, miniwin.rect_frame, 1, titleHeight, config.split, config.height-1, ColourNameToRGB("white"))
	WindowRectOp (win, miniwin.rect_frame, config.split+1, titleHeight, config.width-1, config.height-1, ColourNameToRGB("white"))
  printBrowseList()
    
  drawText()
  drawLines()
  drawPolys()
  
  -- draw scrollbars
  drawScrollbars()
    
    
  -- draw X in the corner to close the window
  --WindowRectOp(win, 5, config.width-15, 1, config.width, titleHeight, 5, 15+ 0x0800)
  WindowLine (win, config.width-15, 5, config.width-5, 15, ColourNameToRGB ("white"), miniwin.pen_solid, 1)
  WindowLine (win, config.width-15, 15, config.width-5, 5, ColourNameToRGB ("white"), miniwin.pen_solid, 1)
  WindowAddHotspot(win, "windowX", 
        config.width-15, 5, config.width-5, 15,
  			"",                   --mousehover
  			"",                   --mouseoffhover
  			"destroyWindow",      --mousedown
  			"CancelMouseDown",                   --mouseoffdown
  			"LeftClickOnly",                   --mouseup
  			"Close race browser window",
  			1, 0)
  -- heading line
 	WindowText (win, font, "LotJ Race Browser v"..VERSION, 3, 3, 0, 0, ColourNameToRGB  "white")
  drawRefreshButton()
  drawResizer(win, config.width, config.height)
  WindowShow (win,  true)
  --BroadcastPlugin(999, "repaint")
  
  
end
function drawRefreshButton()
  local display = ""
  if races.scantime then
    local daysold = tonumber(string.format("%1.0f", os.difftime(os.time(), tonumber(races.scantime))/86400))
    display = "Race data is "..((daysold>0 and daysold.." day"..((daysold>1 and "s")or "").." old") or "current")
  else
    display = "No race data"
  end
  WindowText(win, font, display, config.width-WindowTextWidth(win, font, display)-40, 3, 0, 0, ColourNameToRGB("white"))
  WindowAddHotspot(win, "refreshbutton", config.width-30, 1, config.width-15, titleHeight, "", "", "startRacelistScan", "", "", "Update race data", 1, 0)
  points = string.format("%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i", config.width-23, titleHeight-12, config.width-19, titleHeight-8, config.width-21,titleHeight-8,config.width-21, titleHeight-3,config.width-25, titleHeight-3,config.width-25,titleHeight-8,config.width-27, titleHeight-8)
  WindowPolygon(win, points, ColourNameToRGB("white"), 0, 1, ColourNameToRGB("white"), 0, true, false)
  
end
function drawScrollbars(name, line, args)
   -- left Scrollbar base
   WindowRectOp(win, 2, config.split-2-SCROLL_BAR_WIDTH, titleHeight, config.split-2, config.height-2, SCROLL_BACKGROUND_COLOUR) -- scroll bar background
   WindowRectOp(win, 1, config.split-2-SCROLL_BAR_WIDTH+1, SCROLL_BAR_WIDTH+titleHeight+1, config.split-2-1, config.height-SCROLL_BAR_WIDTH-1, SCROLL_DETAIL_COLOUR) -- scroll bar background inset rectangle
   
   -- right Scrollbar base
   WindowRectOp(win, 2, config.width-SCROLL_BAR_WIDTH, titleHeight, config.width, -SCROLL_BAR_WIDTH, SCROLL_BACKGROUND_COLOUR) -- scroll bar background
   WindowRectOp(win, 1, config.width-SCROLL_BAR_WIDTH+1, SCROLL_BAR_WIDTH+titleHeight+1, config.width-1, config.height-(2*SCROLL_BAR_WIDTH)-1, SCROLL_DETAIL_COLOUR) -- scroll bar background inset rectangle
   
   -- draw right scrollbar up and down arrows
   if (keepscrolling == "rightup") then
      -- draw top scroll button pressed
      WindowRectOp(win, 5, (config.width-SCROLL_BAR_WIDTH), titleHeight, 0, titleHeight+SCROLL_BAR_WIDTH, 10,  15 + 0x800) -- up arrow pushed
      points = string.format("%i,%i,%i,%i,%i,%i", (config.width-SCROLL_BAR_WIDTH)+3, titleHeight+9,(config.width-SCROLL_BAR_WIDTH)+7, titleHeight+5,(config.width-SCROLL_BAR_WIDTH)+11, titleHeight+9)
      WindowPolygon(win, points,
         0x000000, 0, 1, -- pen (solid, width 1)
         0x000000, 0, -- brush (solid)
         true, -- close
         false) -- alt fill
   else
      -- draw top scroll button unpressed
      WindowRectOp(win, 5, (config.width-SCROLL_BAR_WIDTH), titleHeight, config.width, titleHeight+SCROLL_BAR_WIDTH, 5, 15 + 0x800)
      points = string.format("%i,%i,%i,%i,%i,%i", (config.width-SCROLL_BAR_WIDTH)+3, titleHeight+9,(config.width-SCROLL_BAR_WIDTH)+7, titleHeight+5,(config.width-SCROLL_BAR_WIDTH)+11, titleHeight+9)
      WindowPolygon(win, points,
         0x000000, 0, 1,   -- pen (solid, width 1)
         0x000000, 0, --brush (solid)
         true, --close
         false)  --alt fill
   end
    
   if (keepscrolling == "rightdown") then
      -- draw bottom scroll button pressed
      WindowRectOp(win, 5, (config.width-SCROLL_BAR_WIDTH), config.height-(SCROLL_BAR_WIDTH*2), 0, config.height-SCROLL_BAR_WIDTH-1, 10,  15 + 0x800) 
      points = string.format("%i,%i,%i,%i,%i,%i", (config.width-SCROLL_BAR_WIDTH)+3, (config.height-SCROLL_BAR_WIDTH)-11,(config.width-SCROLL_BAR_WIDTH)+7, (config.height-SCROLL_BAR_WIDTH)-7, (config.width-SCROLL_BAR_WIDTH)+11,(config.height-SCROLL_BAR_WIDTH)-11)
      WindowPolygon(win, points,
         0x000000, 0, 1, -- pen (solid, width 1)
         0x000000, 0, -- brush (solid)
         true, -- close
         false) -- alt fill
   else
      -- draw bottom scroll button unpressed
      WindowRectOp(win, 5, (config.width-SCROLL_BAR_WIDTH), config.height-(SCROLL_BAR_WIDTH*2), config.width, config.height-SCROLL_BAR_WIDTH, 5,  15 + 0x800)
      points = string.format("%i,%i,%i,%i,%i,%i", (config.width-SCROLL_BAR_WIDTH)+3, (config.height-SCROLL_BAR_WIDTH)-11,(config.width-SCROLL_BAR_WIDTH)+7, (config.height-SCROLL_BAR_WIDTH)-7, (config.width-SCROLL_BAR_WIDTH)+11,(config.height-SCROLL_BAR_WIDTH)-11)
      WindowPolygon(win, points,
         0x000000, 0, 1,   -- pen (solid, width 1)
         0x000000, 0, --brush (solid)
         true, --close
         false) --alt fill
   end
   
      -- draw left scrollbar up and down arrows
   if (keepscrolling == "leftup") then
      -- draw top scroll button pressed
      WindowRectOp(win, 5, (config.split-SCROLL_BAR_WIDTH-2), titleHeight, config.split-2, titleHeight+SCROLL_BAR_WIDTH, 10,  15 + 0x800) -- up arrow pushed
      points = string.format("%i,%i,%i,%i,%i,%i", (config.split-SCROLL_BAR_WIDTH-2)+3, titleHeight+9,(config.split-SCROLL_BAR_WIDTH-2)+7, titleHeight+5,(config.split-SCROLL_BAR_WIDTH-2)+11, titleHeight+9)
      WindowPolygon(win, points,
         0x000000, 0, 1, -- pen (solid, width 1)
         0x000000, 0, -- brush (solid)
         true, -- close
         false) -- alt fill
   else
      -- draw top scroll button unpressed
      WindowRectOp(win, 5, (config.split-SCROLL_BAR_WIDTH-2), titleHeight, config.split-2, titleHeight+SCROLL_BAR_WIDTH, 5, 15 + 0x800)
      points = string.format("%i,%i,%i,%i,%i,%i", (config.split-SCROLL_BAR_WIDTH-2)+3, titleHeight+9,(config.split-SCROLL_BAR_WIDTH-2)+7, titleHeight+5,(config.split-SCROLL_BAR_WIDTH-2)+11, titleHeight+9)
      WindowPolygon(win, points,
         0x000000, 0, 1,   -- pen (solid, width 1)
         0x000000, 0, --brush (solid)
         true, --close
         false)  --alt fill
   end
    
   if (keepscrolling == "leftdown") then
      -- draw bottom scroll button pressed
      WindowRectOp(win, 5, (config.split-SCROLL_BAR_WIDTH-2), config.height-SCROLL_BAR_WIDTH, config.split-2, config.height-1, 10,  15 + 0x800) 
      points = string.format("%i,%i,%i,%i,%i,%i", (config.split-SCROLL_BAR_WIDTH-2)+3, config.height-11,(config.split-SCROLL_BAR_WIDTH-2)+7, config.height-7, (config.split-SCROLL_BAR_WIDTH-2)+11,config.height-11)
      WindowPolygon(win, points,
         0x000000, 0, 1, -- pen (solid, width 1)
         0x000000, 0, -- brush (solid)
         true, -- close
         false) -- alt fill
   else
      -- draw bottom scroll button unpressed
      WindowRectOp(win, 5, (config.split-SCROLL_BAR_WIDTH-2), config.height-SCROLL_BAR_WIDTH, config.split-2, config.height, 5,  15 + 0x800)
      points = string.format("%i,%i,%i,%i,%i,%i", (config.split-SCROLL_BAR_WIDTH-2)+3, config.height-11,(config.split-SCROLL_BAR_WIDTH-2)+7, config.height-7, (config.split-SCROLL_BAR_WIDTH-2)+11,config.height-11)
      WindowPolygon(win, points,
         0x000000, 0, 1,   -- pen (solid, width 1)
         0x000000, 0, --brush (solid)
         true, --close
         false) --alt fill
   end
   
   
    -- determine left scrollbar position indicator
    totalSteps = #races
    if (totalSteps <= racesFit-1) then
       totalSteps = 1
    end
    SCROLL_BAR_HEIGHT = (config.height-(2*SCROLL_BAR_WIDTH)-titleHeight)
    if (not dragscrolling) then
      stepNum = raceDisplayedStart-1
      barPos = SCROLL_BAR_WIDTH + titleHeight + ((SCROLL_BAR_HEIGHT/totalSteps) * stepNum)
      barSize = (SCROLL_BAR_HEIGHT/math.max(racesFit-1,totalSteps)) * (racesFit-1)
      if barSize < 10 then
        barSize = 10
      end
      if barPos+barSize > SCROLL_BAR_WIDTH+titleHeight+SCROLL_BAR_HEIGHT then
        barPos = SCROLL_BAR_WIDTH+titleHeight+SCROLL_BAR_HEIGHT - barSize
      end
      WindowAddHotspot(win, "leftscroller", (config.split-SCROLL_BAR_WIDTH-2), barPos, config.split-2, barPos+barSize, "MouseOver", "CancelMouseOver", "MouseDown", "CancelMouseDown", "MouseUp", "", 1, 0)
      WindowDragHandler(win, "leftscroller", "ScrollerMoveCallback", "ScrollerReleaseCallback", 0)
    
    end
    WindowRectOp(win, 5, (config.split-SCROLL_BAR_WIDTH-2), barPos, config.split-2, barPos+barSize, 5, 15 + 0x800) -- scrollbar position indicator
    
    
   -- determine right scrollbar position indicator
   totalSteps2 = #text
   if (totalSteps2 <= textFit-1) then
      totalSteps2 = 1 
   end
   SCROLL_BAR_HEIGHT2 = (config.height-(3*SCROLL_BAR_WIDTH)-titleHeight)
   if (not dragscrolling) then
      stepNum2 = textStart-1
      barPos2 = SCROLL_BAR_WIDTH +titleHeight+ ((SCROLL_BAR_HEIGHT2/totalSteps2) * stepNum2)
      barSize2 = (SCROLL_BAR_HEIGHT2/math.max(textFit-1,totalSteps2)) * (textFit-1)
      if barSize2 < 10 then
         barSize2 = 10
      end
      if barPos2+barSize2 > SCROLL_BAR_WIDTH+titleHeight+SCROLL_BAR_HEIGHT2 then
         barPos2 = SCROLL_BAR_WIDTH+titleHeight+SCROLL_BAR_HEIGHT2 - barSize2
      end
      WindowAddHotspot(win, "rightscroller", (config.width-SCROLL_BAR_WIDTH), barPos2, config.width, barPos2+barSize2, "MouseOver", "CancelMouseOver", "MouseDown", "CancelMouseDown", "MouseUp", "", 1, 0)
      WindowDragHandler(win, "rightscroller", "ScrollerMoveCallback", "ScrollerReleaseCallback", 0)
   end
   WindowRectOp(win, 5, (config.width-SCROLL_BAR_WIDTH), barPos2, config.width, barPos2+barSize2, 5, 15 + 0x800) -- scrollbar position indicator
    
end
function destroyWindow(name, list, args)
	WindowShow (win, false)
	visible = "false"
end
function scheduleRedraw()
	if redraw_scheduled == false then
		redraw_scheduled = true
		DoAfterSpecial(0.1, 'drawWindows()', sendto.script)
	end
end
function forceRedraw()
  if redraw_scheduled == false then
    redraw_scheduled = true
    drawWindows()
  end
end
function wheel_move (flags, hotspot_id)
  if hotspot_id == "leftbackground" then
    if bit.band(flags, 0x100) ~= 0 then
      if raceDisplayedStart < #races-racesFit+2 then
        -- down
        raceDisplayedStart = math.max(1, math.min(#races-racesFit+2, raceDisplayedStart+3))
        raceDisplayedEnd = math.min(#races, raceDisplayedStart+racesFit-2)    
        forceRedraw()
      end
    elseif raceDisplayedStart > 1 then
      -- up
      raceDisplayedStart = math.max(1, raceDisplayedStart-3)
      raceDisplayedEnd = math.min(#races, raceDisplayedStart+racesFit-2)
      forceRedraw()
    end
  elseif hotspot_id == "rightbackground" then
    if bit.band(flags, 0x100) ~= 0 then
      if textStart < #text-textFit+2 then
        -- down
        textStart = math.max(1, math.min(#text-textFit+2, textStart+3))
        textEnd = math.min(#text, textStart+textFit-2)    
        forceRedraw()
      end
    elseif textStart > 1 then
      -- up
      textStart = math.max(1, textStart-3)
      textEnd = math.min(#text, textStart+textFit-2)
      forceRedraw()
    end
  end
end -- wheel_move
function ScrollerMoveCallback(flags, hotspot_id)
  mouseposy = WindowInfo(win, 18)
  windowtop = WindowInfo(win, 2)
  if hotspot_id == "leftscroller" then
    barPos = math.max(mouseposy-windowtop+clickdelta, SCROLL_BAR_WIDTH+titleHeight)
    if barPos > config.height-(SCROLL_BAR_WIDTH)-barSize then
      barPos = config.height-(SCROLL_BAR_WIDTH)-barSize
      raceDisplayedStart = math.max(1,#races-racesFit+2)
      raceDisplayedEnd = #races
    else
      raceDisplayedStart = math.max(1,math.floor((barPos-SCROLL_BAR_WIDTH-titleHeight)/(SCROLL_BAR_HEIGHT/totalSteps)+1))
      raceDisplayedEnd = math.min(raceDisplayedStart + racesFit-2, #races)
    end
  elseif hotspot_id == "rightscroller" then
    barPos2 = math.max(mouseposy-windowtop+clickdelta, SCROLL_BAR_WIDTH+titleHeight)
    if barPos2 > config.height-(SCROLL_BAR_WIDTH*2)-barSize2 then
      barPos2 = config.height-(SCROLL_BAR_WIDTH*2)-barSize2
      textStart = math.max(1,#text-textFit+2)
      textEnd = #text
    else
      textStart = math.max(1,math.floor((barPos2-SCROLL_BAR_WIDTH-titleHeight)/(SCROLL_BAR_HEIGHT/totalSteps2)+1))
      textEnd = math.min(#text, textStart+textFit-2)
    end
  end
  scheduleRedraw()
end
function ScrollerReleaseCallback(flags, hotspot_id)
   dragscrolling = false
   scheduleRedraw()
end
----------------------------------------------------------------------
-- Called as resizer is dragged.
----------------------------------------------------------------------
function ResizeMoveCallback(flags, hotspot_id)
   posx, posy = WindowInfo (win, 17), WindowInfo (win, 18)
   config.width = config.width + posx - startposx
   startposx = posx
   if (config.width < MIN_WIDTH) then
      config.width = MIN_WIDTH
      startposx = windowinfo.window_left+config.width
   elseif (windowinfo.window_left+config.width > GetInfo(281)) then
      config.width = GetInfo(281)-windowinfo.window_left
      startposx = GetInfo(281)
   end
   
   config.height = config.height + posy - startposy
   startposy = posy
   if (config.height < MIN_HEIGHT) then
   	config.height = MIN_HEIGHT
   	startposy = windowinfo.window_top+config.height
   elseif (windowinfo.window_top+config.height > GetInfo(280)) then
   	config.height = GetInfo(280)-windowinfo.window_top
   	startposy = GetInfo(280)
   end
   
   
	if (utils.timer() - lastRefresh > 0.0333) then
		SetUpHotspotsAndDraw(false)
		lastRefresh = utils.timer()
	end
end
---------------------------------------------------------------------------------
-- Called after the resize widget is released.
---------------------------------------------------------------------------------
function ResizeReleaseCallback ()
  config.height = titleHeight+(raceLineHeight*(racesFit-1))+3 -- snap height down to not have dead space after last line
  SetUpHotspotsAndDraw(false) -- true here causes old lines to re-wrap at the new size
end
---------------------------------------------------------------------------------
-- Called as window split is being dragged.
---------------------------------------------------------------------------------
function SplitMoveCallback(flags, hotspot_id)
  posx = WindowInfo(win, 17)
  config.split = config.split + posx - startposx
  startposx = posx
  if (config.split < MIN_SPLIT) then
    config.split = MIN_SPLIT
    startposx = windowinfo.window_left+config.split
  elseif (windowinfo.window_left+config.split > GetInfo(281)) then -- prevent moving split off right edge of screen
    config.split = GetInfo(281)-windowinfo.window_left
    startposx = GetInfo(281)
  end
  
  if (utils.timer() - lastRefresh > 0.0333) then
		SetUpHotspotsAndDraw(false)
		lastRefresh = utils.timer()
	end
end
---------------------------------------------------------------------------------
-- Called after window split is released.
---------------------------------------------------------------------------------
function SplitReleaseCallback()
  SetUpHotspotsAndDraw(false)
end
---------------------------------------------------------------------------------
-- Called when mouse button is pressed on hotspot.
---------------------------------------------------------------------------------
function MouseDown(flags, hotspot_id)
  if (hotspot_id == "resize" or hotspot_id == "splitmove") then
    startposx, startposy = WindowInfo (win, 17), WindowInfo (win, 18)
  elseif (hotspot_id == "leftscroller") then
    clickdelta = WindowHotspotInfo(win, "leftscroller", 2)-WindowInfo (win, 15)
    dragscrolling = true
  elseif (hotspot_id == "rightscroller") then
    clickdelta = WindowHotspotInfo(win, "rightscroller", 2)-WindowInfo (win, 15)
    dragscrolling = true
  elseif (hotspot_id == "leftup" or hotspot_id == "leftdown") then
    keepscrolling = hotspot_id
    scrollbar()
  elseif (hotspot_id == "rightup" or hotspot_id == "rightdown") then
    keepscrolling = hotspot_id
    scrollbar2()
  elseif (hotspot_id == "leftbackground") then
    raceClick()
  end
end
---------------------------------------------------------------------------------
-- Called when mouse moved away from hotspot. Doesn't really apply for draggables.
---------------------------------------------------------------------------------
function CancelMouseDown(flags, hotspot_id)
  keepscrolling = ""
  scheduleRedraw()
end
---------------------------------------------------------------------------------
-- Called when mouse button released on hotspot.
---------------------------------------------------------------------------------
function MouseUp(flags, hotspot_id, win)
   if bit.band (flags, miniwin.hotspot_got_rh_mouse) ~= 0 then
      right_click_menu()
   end
   keepscrolling = ""
   return true
end
function LeftClickOnly(flags, hotspot_id, win)
	if bit.band (flags, miniwin.hotspot_got_rh_mouse) ~= 0 then
    return true
	end
	return false
end
function right_click_menu(hotspot_id)
	menu ="!"
  menu = menu .."^Race Sorting|>Apply main class filter|"
  
  for i, v in ipairs(matrix_class) do
    menu = menu..((filter_main_class==v and "+") or "")..v.."|"
  end
  menu = menu.."<|>Apply level filters|"
  for i, v in ipairs(matrix_class) do
    local found = false
    for k, j in pairs(filter_classes) do
      if j==v then -- class belongs to sorting filter
        found = true
      end
    end
    menu = menu..((found and "+") or "")..v.."|"
  end
  menu = menu.."<|>Apply stat filters|"
  for i, v in ipairs(matrix_stats) do
    local found = false
      for k, j in pairs(filter_stats) do
        if j==v then -- stat belongs to sorting filter
          found = true
        end
      end
    menu = menu..((found and "+") or "")..v.."|"
  end
  menu = menu .. "<|Sort alphabetically|Clear filters"
  
  result = tonumber(WindowMenu (win,
		WindowInfo (win, 14),  -- x position
		WindowInfo (win, 15),   -- y position
		menu))
    
    
  if result~=nil then
    if result > 0 and result <= #matrix_class then -- chose a main class
      if filter_main_class==matrix_class[result] then -- remove main class choice
        filter_main_class = ""
      else
        filter_main_class = matrix_class[result]
      end
    elseif result > #matrix_class and result <= #matrix_class*2 then -- chose a level filter
      local choice = matrix_class[result-#matrix_class]
      local found = 0
      for k, v in pairs(filter_classes) do
        if v==choice then -- choice already in filter, remove it
          found = k
        end
      end
      if found>0 then
        table.remove(filter_classes, found)
      else
        filter_classes[#filter_classes + 1] = choice
      end
    elseif result > #matrix_class*2 and result <= #matrix_class*2+#matrix_stats then -- chose a stat filter
      local choice = matrix_stats[result-#matrix_class*2]
      local found = 0
      for k, v in pairs(filter_stats) do
        if v==choice then -- choice already in filter, remove it
          found = k
        end
      end
      if found>0 then
        table.remove(filter_stats, found)
      else
        filter_stats[#filter_stats + 1] = choice
      end
    elseif result == #matrix_class*2+#matrix_stats+1 then -- chose alpha sort
      sortByAlpha()
      return
    elseif result == #matrix_class*2+#matrix_stats+2 then -- chose clear filters
      clearFilters()
      return
    end
    sortByFilter(filter_main_class, filter_classes, filter_stats)
  end
end
keepscrolling = ""
require "wait"
function scrollbar()
   wait.make(
   function()
      while keepscrolling == "leftup" or keepscrolling == "leftdown" do
         if keepscrolling == "leftup" then
            if (raceDisplayedStart > 1) then
               raceDisplayedStart = raceDisplayedStart - 1
               raceDisplayedEnd = raceDisplayedEnd - 1
            else
                 keepscrolling = ""
            end
         elseif keepscrolling == "leftdown" then
            if (raceDisplayedEnd < #races) then
               raceDisplayedStart = raceDisplayedStart + 1
               raceDisplayedEnd = raceDisplayedEnd + 1
            else
               keepscrolling = ""
            end
         end
         wait.time(0.1)
         forceRedraw()
      end
   end
   )
end
function scrollbar2()
   wait.make(
   function()
      while keepscrolling == "rightup" or keepscrolling == "rightdown" do
         if keepscrolling == "rightup" then
            if (textStart > 1) then
               textStart = textStart - 1
               textEnd = textEnd - 1
            else
                 keepscrolling = ""
            end
         elseif keepscrolling == "rightdown" then
            if (textEnd < #text) then
               textStart = textStart + 1
               textEnd = textEnd + 1
            else
               keepscrolling = ""
            end
         end
         wait.time(0.1)
         forceRedraw()
      end
   end
   )
end
function OnPluginInstall () 	
  -- get default config
  if not config then
    config = default_config
  end
  
  --- Setup the windows
  SetUpHotspotsAndDraw(true)  
    
end -- OnPluginInstall
--================================================================================
-- Called by OnPluginInstall, but also by redraw routine to refresh the screen
-- and (if the first time) add the resizer tag, otherwise move the resizer relative
-- to the main window.
--=================================================================================
function SetUpHotspotsAndDraw(firstTime)
	if (firstTime) then
    
		WindowCreate (win, 0, 0, config.width, config.height, miniwin.pos_center_all, 0, ColourNameToRGB("black")) -- create window
		windowinfo = movewindow.install (win, 6) -- default to 6 (on top right)
		check(WindowFont (win, font, font_name, font_size, false, false, false, false))
    -- spacing stuff
    titleHeight = WindowFontInfo(win, font, 1)+4
    raceLineHeight = WindowFontInfo(win, font, 1)+spacer
    textLineHeight = WindowFontInfo(win, font, 1)+1
    
    --effectiveWidth = math.min(config.width, GetInfo(281)-windowinfo.window_left)
		WindowAddHotspot (win, "resize", config.width-RESIZE_TAG_SIZE, config.height-RESIZE_TAG_SIZE, config.width, config.height, "MouseOver", "CancelMouseOver", "MouseDown", "CancelMouseDown", "MouseUp", "", 6, 0)
		WindowDragHandler(win, "resize", "ResizeMoveCallback", "ResizeReleaseCallback", 0)
    WindowAddHotspot (win, "splitmove", config.split-1, titleHeight, config.split+1, config.height-1, "MouseOver", "CancelMouseOver", "MouseDown", "CancelMouseDown", "MouseUp", "", 8, 0)
    WindowDragHandler(win, "splitmove", "SplitMoveCallback", "SplitReleaseCallback", 0)
    -- make background hotspots for scrolling
    WindowAddHotspot (win, "leftbackground", 2, titleHeight, config.split-SCROLL_BAR_WIDTH-2, config.height-2, "MouseOver", "CancelMouseOver", "MouseDown", "CancelMouseDown", "MouseUp", "",0, 0)
    WindowScrollwheelHandler(win, "leftbackground", "wheel_move")
    -- left scroll bar up/down buttons
    WindowAddHotspot(win, "leftup", config.split-1-SCROLL_BAR_WIDTH, titleHeight, config.split-1, titleHeight+SCROLL_BAR_WIDTH, "MouseOver", "CancelMouseOver", "MouseDown", "CancelMouseDown", "MouseUp", "", 1, 0)
    WindowAddHotspot(win, "leftdown", config.split-1-SCROLL_BAR_WIDTH, config.height-SCROLL_BAR_WIDTH, config.split-1, config.height, "MouseOver", "CancelMouseOver", "MouseDown", "CancelMouseDown", "MouseUp", "", 1, 0)
    WindowAddHotspot (win, "rightbackground", config.split+2, titleHeight, config.width-SCROLL_BAR_WIDTH-2, config.height-2, "MouseOver", "CancelMouseOver", "MouseDown", "CancelMouseDown", "MouseUp", "",0, 0)    
    WindowScrollwheelHandler(win, "rightbackground", "wheel_move")
    -- right scroll bar up/down buttons
    WindowAddHotspot(win, "rightup", config.width-SCROLL_BAR_WIDTH, titleHeight, config.width-2, titleHeight+SCROLL_BAR_WIDTH, "MouseOver", "CancelMouseOver", "MouseDown", "CancelMouseDown", "MouseUp", "", 1, 0)
    WindowAddHotspot(win, "rightdown", config.width-SCROLL_BAR_WIDTH, config.height-(2*SCROLL_BAR_WIDTH), config.width-2, config.height-SCROLL_BAR_WIDTH, "MouseOver", "CancelMouseOver", "MouseDown", "CancelMouseDown", "MouseUp", "", 1, 0)
	else -- not our first time drawing
		-- everything has already been made
		-- just move them back into place
		--effectiveWidth = math.min(config.width, GetInfo(281)-windowinfo.window_left)
		WindowResize(win, config.width, config.height, 0x000000)
		WindowMoveHotspot(win, "resize", config.width-RESIZE_TAG_SIZE, config.height-RESIZE_TAG_SIZE, config.width, config.height)
    WindowMoveHotspot(win, "splitmove", config.split-1, WindowFontInfo(win, font, 1)+4, config.split+1, config.height-1)
    
    WindowMoveHotspot(win, "leftbackground", 2, WindowFontInfo(win, font, 1)+4, config.split-SCROLL_BAR_WIDTH-2, config.height-2)
    WindowMoveHotspot(win, "rightbackground", config.split+2, titleHeight, config.width-SCROLL_BAR_WIDTH-2, config.height-2)
    WindowMoveHotspot(win, "leftup",config.split-1-SCROLL_BAR_WIDTH, titleHeight, config.split-1, titleHeight+SCROLL_BAR_WIDTH)
    WindowMoveHotspot(win, "leftdown",config.split-1-SCROLL_BAR_WIDTH, config.height-SCROLL_BAR_WIDTH, config.split-1, config.height)
    WindowMoveHotspot(win, "rightup",config.width-SCROLL_BAR_WIDTH, titleHeight, config.width-2, titleHeight+SCROLL_BAR_WIDTH)
    WindowMoveHotspot(win, "rightdown",config.width-SCROLL_BAR_WIDTH, config.height-(2*SCROLL_BAR_WIDTH), config.width-2, config.height-SCROLL_BAR_WIDTH)
	end
  
  -- left window
  racesFit = math.ceil((config.height-titleHeight)/raceLineHeight)
  
  raceDisplayedStart = 1
  raceDisplayedEnd = math.min(racesFit, #races)
  -- right window
  textFit = math.ceil((config.height-titleHeight)/textLineHeight)
  
  textStart = 1
  textEnd = math.min(#text, textFit)
    
  redraw_scheduled = true
  drawWindows()
end
function drawWindows()
	if redraw_scheduled == false then
		return
	else
		redraw_scheduled = false
	end
  if visible == "true" then
    drawWindow()
  end
end
function drawResizer(window, winwidth, winheight)
   -- draw the resize widget bottom right corner.
   WindowRectOp(win, 2, winwidth-SCROLL_BAR_WIDTH, winheight-SCROLL_BAR_WIDTH, 0, 0, SCROLL_BACKGROUND_COLOUR) -- resizer background
   WindowLine(window, winwidth-3, winheight-2, winwidth-2, winheight-3, 0xffffff, 0, 2)
   WindowLine(window, winwidth-4, winheight-2, winwidth-2, winheight-4, 0x696969, 0, 1)
   WindowLine(window, winwidth-6, winheight-2, winwidth-2, winheight-6, 0xffffff, 0, 2)
   WindowLine(window, winwidth-7, winheight-2, winwidth-2, winheight-7, 0x696969, 0, 1)
   WindowLine(window, winwidth-9, winheight-2, winwidth-2, winheight-9, 0xffffff, 0, 2)
   WindowLine(window, winwidth-10, winheight-2, winwidth-2, winheight-10, 0x696969, 0, 1)
   WindowLine(window, winwidth-12, winheight-2, winwidth-2, winheight-12, 0xffffff, 0, 2)
   WindowLine(window, winwidth-13, winheight-2, winwidth-2, winheight-13, 0x696969, 0, 1)
end
function OnPluginSaveState ()
  movewindow.save_state (win)
  SetVariable("config", serialize.save("config"))
  SetVariable("races", serialize.save("races"))
  SetVariable("visible", visible)
end -- function OnPluginSaveState
function OnPluginDisable()
  WindowShow(win, false)
end
  ]]> 
  </script>
  </muclient>
