<?xml version="1.0" encoding="iso-8859-1" ?> 
<!DOCTYPE muclient> 
<muclient>
<plugin name="LotJRaceBrowser" author="@Johnson" id="a4e8153e52b1b6d490ed4b10" language="Lua" purpose="Browse LotJ Races" save_state="y" requires="4.84" version="1.09">
<description trim="y">
<![CDATA[ 

Sections of this plugin are based on work by Fiendish of Aardwolfmud and other community members.
See 'http://www.gammon.com.au/forum/?id=9385'

To use this plugin:

Type 'racescan' to gather information from the game and populate into the browser.
Type 'raceshow' to display the browser if you previously closed it.
Type 'racehide' or click the X to close the browser.
Type 'raceclear' to clear the stored race information.

This plugin creates a visual index of all current LotJ races. The race list can be sorted by
right clicking anywhere in the window and choosing filters to apply.

  ]]> 
  </description>
  </plugin>
<!--   Get our standard constants   --> 
	<include name="constants.lua" /> 
<!--   Triggers    --> 
<triggers>

  <!--
  [   0/   0]:  Besalisk       Bith           Bothan         Gran          
              Human          Hutt           Ithorian       Mon_calamari  
              Muun           Neimoidian     Quermian       Rodian        
              Twi'lek        Utai           Vurk           Zabrak        
[  50/   0]:  Cerean        
[ 250/   0]:  Jawa          
[ 250/ 250]:  Pau'an
  -->

  <trigger match="^(\[(((?P<price>[\s\d]+)\/(?P<dep>[\s\d]+))|App Only )\]\:)? (?P<racesFound>.*)$" script="raceListScanAdd" regexp="y" enabled="n" group="RacelistScan" omit_from_output="y" omit_from_log="y" sequence="100" />
  <!--trigger match="^([\s\d]+)\((\d)\)\> (.*) (\d+)\((\d)\)\> (.*) (\d+)\((\d)\)\> (.*) (\d+)\((\d)\)\> (.*)$" script="raceListScanAdd" regexp="y" enabled="n" group="RacelistScan"  omit_from_output="y" omit_from_log="y" sequence="100" -->
  <!--trigger match="^([\s\d]+)\((\d)\)\> (.*) (\d+)\((\d)\)\> (.*) (\d+)\((\d)\)\> (.*)$" script="raceListScanAdd" regexp="y" enabled="n" group="RacelistScan"  omit_from_output="y" omit_from_log="y" sequence="100" -->
  <!--trigger match="^([\s\d]+)\((\d)\)\> (.*) (\d+)\((\d)\)\> (.*)$" script="raceListScanAdd" regexp="y" enabled="n" group="RacelistScan"  omit_from_output="y" omit_from_log="y" sequence="100" -->
  <!--trigger match="^([\s\d]+)\((\d)\)\> (.*)$" script="raceListScanAdd" regexp="y" enabled="n" group="RacelistScan"  omit_from_output="y" omit_from_log="y" sequence="100" -->

  <trigger name="RacelistScanStart" match="^Points/Dep.   Races\n-------------------------------------------------------------------------\Z" 
    multi_line="y" 
    lines_to_match="2" 
    script="enableRaceListScan" 
    regexp="y" 
    enabled="n" 
    omit_from_output="y" 
    omit_from_log="y" 
    sequence="100" />
  <trigger name="RacelistScanStop" match="^-------------------------------------------------------------------------\n\(S\)yntax\: showrace \<race\>\Z" 
      multi_line="y" 
      lines_to_match="2" 
      script="stopRacelistScan" 
      regexp="y" 
      enabled="n" 
      omit_from_output="y" 
      omit_from_log="y" 
      sequence="100" />
  <!--
    match="^\(R\)ace\: (.*)\nStr Plus\:([\s\d,-]+)Dex Plus\:([\s\d,-]+)Wis Plus\:([\s\d,-]+)Int Plus\:([\s\d,-]+)\nCon Plus\:([\s\d,-]+)Cha Plus\:([\s\d,-]+)Lck Plus\:([\s\d,-]+)\nHit Pts\:([\s\d,-]+)AC Mod\:([\s\d,-]+)Frc Plus\:([\s\d,-]+)\nPrice\:([\s\d,-]+)Deposit\:([\s\d,-]+)App Only\:(.*)\Z"
    -->
  
  <trigger 
    match="^\(R\)ace: (.*)\n   Str Plus: (.*)Dex Plus: (.*)Wis Plus: (.*)Int Plus: (.*)\n   Con Plus: (.*)Cha Plus: (.*)Lck Plus: (.*)\n   Hit Pts: (.*)AC Mod: (.*)Frc Plus: (.*)\n   Price: (.*)Deposit: (.*)App Only: (.*)\Z"
   script="addRaceScanFirst"
   multi_line="y"
   lines_to_match="5"
   regexp="y"
   enabled="n"
   group="raceScanFirst" 
   omit_from_output="y" 
   omit_from_log="y" 
   sequence="100" />
  
  <trigger match="^Players of this race must pick (.*) as their main\.$" script="addRaceMainClass" regexp="y" enabled="n" group="raceScanSecond"  omit_from_output="y" omit_from_log="y" sequence="100" />
  
  <trigger match="^\(D\)efault Language: (.*)$" script="addRaceScanLanguage" regexp="y" enabled="n" group="raceScanLanguage" omit_from_output="y" omit_from_log="y" sequence="100" />
  <trigger match="^\(P\)ossible (skin|plating) colors: $" script="addRaceScanColors" regexp="y" enabled="n" group="raceScanColors" omit_from_output="y" omit_from_log="y" sequence="100" />
  
  <!--trigger match="^\((\d+)\)([\w\s]+)\((\d+)\)([\w\s]+)$" script="addSkinColors" regexp="y" group="SkinColors" enabled="n"  omit_from_output="y" omit_from_log="y" sequence="100" -->
  <trigger match="^(.*)$" script="addSkinColors" regexp="y" group="SkinColors" enabled="n" omit_from_output="y" omit_from_log="y" sequence="100" />
  <trigger match="^$" script="stopSkinColors" regexp="y" group="SkinColors" enabled="n" omit_from_output="y" omit_from_log="y" sequence="100" />
  <trigger match="^(.*) \- (.*)$" script="addExtraAttrib" regexp="y" group="ExtraAttribs" enabled="n" omit_from_output="y" omit_from_log="y" sequence="100" />
  <trigger match="^$" script="stopExtraAttribs" regexp="y" group="ExtraAttribs" enabled="n" omit_from_output="n" omit_from_log="y" sequence="100" />
  <trigger match="^(.*)   (.*)$" script="addRaceLevels" regexp="y" group="RaceLevels" enabled="n" omit_from_output="y" omit_from_log="y" sequence="100" />
  <trigger match="^science(.*)$" script="stopRaceLevels" regexp="y" group="RaceLevels" enabled="n"  omit_from_output="y" omit_from_log="y" sequence="101" />
  <trigger name="gagAll" match="^(.*)$" regexp="y" keep_evaluating="y" omit_from_output="y" omit_from_log="y" enabled="n" sequence="100" />
</triggers>

<aliases>

	<alias match="racescan" script="startRacelistScan" enabled="y" regexp="n" ignore_case="y" group="LotJRaceBrowser" sequence="100" />
	<alias match="raceclear" script="clearTable" enabled="y" regexp="n" ignore_case="y" group="LotJRaceBrowser" sequence="100" />
	<alias match="raceshow" script="showWindow" enabled="y" regexp="n" ignore_case="y" group="LotJRaceBrowser" sequence="100" />
	<alias match="racehide" script="hideWindow" enabled="y" regexp="n" ignore_case="y" group="LotJRaceBrowser" sequence="100" />
  <alias match="raceprint *" script="printRace" enabled="y" regexp="n" ignore_case="y" group="LotJRaceBrowser" sequence="100" />



</aliases>
<!--   Script    --> 
<script>
<![CDATA[

require "movewindow"
require "copytable"
require "serialize"
require "tprint"
require "pairsByKeys"

 -- enable these to ensure everything works smooth
SetOption("enable_triggers", true)
SetOption("enable_scripts", true)

local AUTHOR = GetPluginInfo(GetPluginID(), 2) -- author info
local VERSION = string.format("%1.2f", GetPluginInfo(GetPluginID(), 19)) -- version info
local win = "win_" .. GetPluginID()  -- unique window name
local font = "f"
local default_font_name = GetInfo(20)
local default_font_size = GetInfo(243)
local font_name = GetVariable("font_name") or default_font_name
local font_size = tonumber(GetVariable("font_size")) or default_font_size
local RESIZE_TAG_SIZE = 10
local visible = GetVariable("visible") or "true"
local MIN_WIDTH   = 50
local MIN_HEIGHT  = 50
local MIN_SPLIT   = 75
local redraw_scheduled = false


-- default config
local default_config = {  height = 300,
            width = 750,
            split = 150, -- location from left for window split
            backcolor = "black",
            }

-- replace default with loaded config
loadstring(GetVariable("config") or "") ()

local SCROLL_BACKGROUND_COLOUR = 0xE8E8E8
local SCROLL_BAR_COLOUR = 0x111111
local SCROLL_DETAIL_COLOUR = 0x000000
local SCROLL_BAR_WIDTH = 15

local titleHeight = 0

local lastRefresh = 0

local filter_main_class = ""
local filter_classes = {}
local filter_stats = {}
local filter_attribs = {}
-- list of all possible race attributes
attribs = {}

races = {}
local newRace = {}

local raceSelected = -1

local raceDisplayedStart = 0
local raceDisplayedEnd = 0
local raceLineHeight = 0
local spacer = 3

local currentRace = {}
local currentRaceIndex = 0
local skinColors = {}
local extraAttribs = {}
local raceLevels = {{}}

local text = {}
local textStart = 0
local textEnd = 0

local lines = {}

local polys = {}

loadstring(GetVariable("races") or "") ()
loadstring(GetVariable("attribs") or "") ()


function printBrowseList()
  local posy = titleHeight
  local font_height = WindowFontInfo(win, font, 1)
  if #races > 0 then
    for i = raceDisplayedStart, raceDisplayedEnd do
      WindowText (win, font, races[i].name..((races[i].weight and " - "..string.format("%.2f", races[i].weight)) or ""), 5, posy, 0, 0, ColourNameToRGB(((i==raceSelected and "red") or ((races[i].str~=nil and "white") or "darkgray"))))
      posy = posy + font_height + spacer
    end
  end
end

function printRace(name, line, args)
  local num = tonumber(args[1])
  if num then
    if races[num] then
      tprint(races[num])
    end
  end
end

function raceClick()
  hottop = WindowHotspotInfo(win, "leftbackground", 2)
  clickpos = WindowInfo(win, 15)
  raceIndex = math.floor((clickpos-hottop)/raceLineHeight)+raceDisplayedStart
  --Note("tFit: "..textFit.." tStart: "..textStart.." eEnd: "..textEnd.." #text: "..#text)
  updateSelectedRace()
end

function updateRaceText()
  if raceSelected > -1 then -- we chose something
    local race = races[raceSelected]
    if race.price == nil or race.dep==nil or race.language==nil or race.ac==nil or race.hp==nil or race.apponly==nil or race.str==nil or race.dex==nil or race.con==nil or race.int==nil or race.wis==nil or race.cha==nil or race.frc==nil or race.lck==nil then
    -- tried to access while still scanning or invalid scan data
      text = {}
      addText( {"red","Either your race data is invalid or scan is still underway..."}, font, "center")
      textEnd = math.min(#text, textStart+textFit-2)
      return
    end
    if race ~= nil then
      text = {} -- clear the text
      lines = {}
      polys = {}
      local left = config.split+2
      local top = titleHeight
      local right = config.width-SCROLL_BAR_WIDTH
      local bot = config.height
      local filler = string.rep("-", 20)
      local title_width = WindowTextWidth(win, font, race.name)
      addText( {"white",filler.."Race"..filler}, font, "center")
      addText( {"cyan",race.name}, font, "center")

      addText( {"white", filler.."Stats"..filler}, font, "center")
      addText( {"white","Price: ",((race.price==0 and "lime") or "red"),race.price,"white"," Deposit: ",((race.dep==0 and "lime") or "red"),race.dep,"white"," Language: ","red",race.language}, font, "center")
      addText( {"white","AC: ","red",race.ac,"white"," Base HP: ","red",race.hp,"white"," App Only: ",((race.apponly=="Yes" and "red") or "lime"),race.apponly}, font, "center")
      addText( {"white","Str: ","red",race.str,"white"," Dex: ","red",race.dex,"white"," Con: ","red",race.con}, font, "center")
      addText( {"white","Int: ","red",race.int,"white"," Wis: ","red",race.wis,"white"," Cha: ","red",race.cha}, font, "center")
      addText( {"white","Frc: ","red",race.frc,"white"," Lck: ","red",race.lck,"white"," Era Restrict: ",((race.erarestrict==0 and "lime") or "red"),race.erarestrict}, font, "center")

      addText( {"white",filler.."Levels"..filler}, font, "center")
      local levelTitle = "               COM PIL ENG HUN SMU LEA ESP SLI MED SCI"
      addText( {"white",levelTitle}, font, "center")
      -- spacing stuff for class filter highlighting
      local levelTitleWidth = WindowTextWidth(win, font, "  "..levelTitle)
      local levelClassWidth = WindowTextWidth(win, font, "                ")
      local spaceWidth = WindowTextWidth(win, font, " ")
      local levelHeadingWidth = WindowTextWidth(win, font, " COM")

      local bound = { left = config.split+2, top = titleHeight, right = config.width-SCROLL_BAR_WIDTH, bot = config.height-2 } -- valid bounding box for drawing

      -- add highlight box for class filters
      for _, v in pairs(filter_classes) do
        local index = class_matrix[v] or 0
        local line = { left = (bound.left+((bound.right-bound.left)/2))-(levelTitleWidth/2)+levelClassWidth+(levelHeadingWidth*(index-1))-1,
                       top = bound.top+((#text-textStart)*textLineHeight),
                       right = (bound.left+((bound.right-bound.left)/2))-(levelTitleWidth/2)+levelClassWidth+(levelHeadingWidth+(levelHeadingWidth*(index-1)))-spaceWidth,
                       bot = bound.top+(((#text-textStart)+#matrix_class+1)*textLineHeight) }
        addPoly( string.format("%i,%i,%i,%i,%i,%i,%i,%i", line.left, line.top, line.right, line.top, line.right, line.bot, line.left, line.bot), ColourNameToRGB("white"), 1+0x2000, 1, ColourNameToRGB("white"), 1, true, false )
      end

      for a, b in pairsByKeys(race.levels) do
        local t = {}
        t[#t+1]=((a==race.mainclass and "cyan") or "white")
        t[#t+1]=string.format("%14s",a)..": "
        for i, j in ipairs(b.levels) do
          t[#t+1]=((tonumber(j)>130 and "red") or ((tonumber(j)>100 and "yellow") or ((tonumber(j)>70 and "cyan") or ((tonumber(j)>30 and "lime") or "blue"))))
          --((j=="5" and "red") or ((j=="4" and "yellow") or ((j=="3" and "cyan") or ((j=="2" and "lime") or "blue")))) 
          t[#t+1]=j.." "
        end
        addText( t, font, "center")
        -- add highlight box for main class filter
        if a==filter_main_class then
          local alltext = ""
          for x, y in ipairs(t) do
            if math.fmod(x-1, 2)==1 then -- text
              alltext = alltext..y
            end
          end
          local textWidth = WindowTextWidth(win, font, alltext)
          local line = { left = ((bound.left+((bound.right-bound.left)/2))-(textWidth/2)), top = bound.top+((#text-textStart)*textLineHeight), right = ((bound.left+((bound.right-bound.left)/2))+(textWidth/2)), bot = bound.top+(((#text-textStart)+1)*textLineHeight) }
          --addLine( line.left, line.top, line.right, line.top, ColourNameToRGB("white"), 0+0x0100, 1 )
          --addLine( line.left, line.bot, line.right, line.bot, ColourNameToRGB("white"), 0+0x0100, 1 )
          --addLine( line.left, line.top, line.left, line.bot, ColourNameToRGB("white"), 0+0x0100, 1 )
          --addLine( line.right, line.top, line.right, line.bot, ColourNameToRGB("white"), 0+0x0100, 1 )
          addPoly( string.format("%i,%i,%i,%i,%i,%i,%i,%i", line.left, line.top, line.right, line.top, line.right, line.bot, line.left, line.bot), ColourNameToRGB("white"), 1+0x2000, 1, ColourNameToRGB("white"), 1, true, false )
        end
      end
      if #race.attribs > 0 then
        addText( {"white",filler.."Extra Arributes"..filler}, font, "center")
        local temp = ""
        for i, j in ipairs(race.attribs) do
          addText( {"lime",j.name,"white"," - ","lime",j.desc}, font, "center")
        end
      end

    textEnd = math.min(#text, textStart+textFit-2)
    end
  end
  
end

function addText(addtext, font, align, pos)
  local line = { t = copytable.deep(addtext), f = font, a = align, p = pos }
  text[#text + 1] = line
end

function addLine(x1, y1, x2, y2, pencolour, penstyle, penwidth)
  --[[  pencolour is RGB colour for this line
        penstyle is 0 -- solid
                    1 -- dash: -------
                    2 -- dot:  .......
                    3 -- dashdot: _._._._.
                    4 -- dashdotdot: _.._.._
                    5 -- null (no pen)
                    6 -- insideframe: a solid pen, dawn inside the shape
                 
    -- also you can add in the style:
    
      0x0000 - round ends (0 = the default)
      0x0100 - square ends (256)
      0x0200 - flat ends (512)
      0x0000 - round joins (0 = the default)
      0x1000 - bevel joins (4096)
      0x2000 - miter joins (8192)
      
        penwidth - width of the pen in pixels. for styles 1 to 4 only a width of 1 is valid.
                   for a particular shape, specify style 5 (no pen) if you only want to fill 
                   the shape, and not stroke it as well.
      
    ]]--
    local line = { x1 = x1, y1 = y1, x2 = x2, y2 = y2, pc = pencolour, ps = penstyle, pw = penwidth }
    lines[#lines + 1] = line
end

function addPoly(points, pencolour, penstyle, penwidth, brushcolour, brushstyle, close, winding)
  local line = { p = points, pc = pencolour, ps = penstyle, pw = penwidth, bc = brushcolour, bs = brushstyle, cl = close, w = winding }
  polys[#polys + 1] = line
end

function drawText()
  --textEnd = math.min(textFit, #text)
  local posy = titleHeight
  local bound = { left = config.split+2, top = titleHeight, right = config.width-SCROLL_BAR_WIDTH, bot = config.height-2 } -- valid bounding box for drawing

  if #text >= 1 then
    for i = textStart, textEnd do
      v = text[i]
      if v~=nil then
        local pos = {}
        local alltext = ""
        for a, b in ipairs(v.t) do
          if math.fmod(a-1, 2)==1 then -- text
            alltext = alltext..b
          end
        end

      local textWidth = WindowTextWidth(win, v.f, alltext)
      local textHeight = WindowFontInfo(win, v.f, 1)
      if v.a == "left" then
        pos = { left = bound.left, top = posy, right = bound.left+textWidth, bot = posy+textHeight }
      elseif v.a == "center" then
        pos = { left = (bound.left+((bound.right-bound.left)/2))-(textWidth/2), top = posy, right = (bound.left+((bound.right-bound.left)/2))+(textWidth/2), bot = posy+textHeight }
      elseif v.a == "right" then
        pos = { left = bound.right-textWidth, top = posy, right = bound.right, bot = posy+textHeight }
      else
        pos = v.p
      end
      local colour = ""
      for a, b in ipairs(v.t) do
        if math.fmod(a-1, 2)==0 then -- got the colour
          colour = b
        elseif math.fmod(a-1, 2)==1 then -- got the text
          tWidth = WindowTextWidth(win, v.f, b)
          pos.left = pos.left + WindowText(win, v.f, b, pos.left, pos.top, pos.left+tWidth, pos.bot, ColourNameToRGB(colour))
        end
      end

      posy = posy + textLineHeight
    end
  end
  end

end

function drawLines()
  for i, v in ipairs(lines) do
    WindowLine(win, v.x1, v.y1, v.x2, v.y2, v.pc, v.ps, v.pw)
  end
end

function drawPolys()
  for i, v in ipairs(polys) do
    WindowPolygon(win, v.p, v.pc, v.ps, v.pw, v.bc, v.bs, v.cl, v.w)
  end
end

function findBestClass(levels)
  local best = 0
  

end

function addLevels(list)
  local total = 0
  for i, v in pairs(list) do
    total = total + v
  end
  return total
end

local raceCostGroup = {}

function raceListScanAdd(name, line, args)
  local race = {}
  --if (args.price ~= '' and args.dep ~= '') then
  --  raceCostGroup.price = tonumber(args.price)
  --  raceCostGroup.dep = tonumber(args.dep)
  --  raceCostGroup.apponly = "No"
  --end
  --if (args[1]=="[App Only ]:") then
  --  raceCostGroup.price = 0
  --  raceCostGroup.dep = 0
  --  raceCostGroup.apponly = "Yes"
  --end
  --Note("price: " ..((args.price and args.price) or raceCostGroup.price).." dep: "..((args.dep and args.dep) or raceCostGroup.dep).." app:"..((args.apponly and args.apponly) or raceCostGroup.apponly))
  local racesSplit = utils.split(Trim(args.racesFound), " ")
  for i, v in ipairs(racesSplit) do
    if (v~='') then
      race.index = #races
      race.name = v
      --race.price = raceCostGroup.price
      --race.dep = raceCostGroup.dep
      --race.apponly = raceCostGroup.apponly
      --Note("found race name: "..v.." Price: "..race.price.." Dep: "..race.dep.." App: "..race.apponly)
      races[#races + 1] = race
      race = {}
    end
  end

end

function startRacelistScan(name, line, args)
  races = {}
  SendNoEcho("showrace")
  EnableTrigger("RacelistScanStart", true)
  EnableTrigger("gagAll", true)
  ColourNote("yellow", "", "Racelist Scan started...")

end

function enableRaceListScan(name, line, args)
  EnableTriggerGroup("RacelistScan", true)
  EnableTrigger("RacelistScanStart", false)
  EnableTrigger("RacelistScanStop", true)
  
end

function stopRacelistScan(name, line, args)
  EnableTriggerGroup("RacelistScan", false)
  EnableTrigger("RacelistScanStart", false)
  EnableTrigger("RacelistScanStop", false)
  ColourNote("yellow", "", "Racelist Scan complete. Found "..#races.." races.")
  races.scantime = os.time()
  SetUpHotspotsAndDraw(false)
  --tprint(races)
  startRaceScan()
end

function startRaceScan(name, line, args)
  currentRaceIndex = 0
  ColourNote("yellow", "", "Race Scan started...\n\n")
  scanNextRace()
end

function scanNextRace(name, line, args)
  currentRaceIndex = currentRaceIndex + 1
  if currentRaceIndex > #races then
    ColourNote("yellow","","Race Scan complete.")
    EnableTrigger("gagAll", false)
    BuildRaceAttribs()
    --tprint(races)
  else
    currentRace = races[currentRaceIndex]
    DeleteLines(1)
    ColourNote("silver","","Scan "..string.format("%2.2f",((currentRaceIndex/#races)*100)).."% completed.")
    SendNoEcho("showrace \""..currentRace.name.."\"")
    EnableTriggerGroup("raceScanFirst", true)
  end
  scheduleRedraw()
end

function BuildRaceAttribs()
  attribs = {}
  for i, v in ipairs(races) do
    for k, j in ipairs(v.attribs or {}) do
      local found = false
      for a, b in ipairs(attribs or {}) do
        if b==j.name then found = true end
      end
      if not found then
        attribs[#attribs + 1] = j.name
      end
    end
  end
end

function sortByAlpha()
  table.sort(races, function (k1, k2) return k1.name < k2.name end )
  clearFilters()
end

function sortByFilter(class, filter, stats, attribs)
  --table.sort(races, function (k1, k2) return getSubclassLevelsByClass(k1, class, filter, stats) > getSubclassLevelsByClass(k2, class, filter, stats) end )
  for a=1, #races do
    findRaceWeightValue(races[a], class, filter, stats, attribs)
  end
  table.sort(races, function (k1, k2) return k1.weight > k2.weight end )
  updateSelectedRace()
end

function clearFilters()
  filter_main_class = ""
  filter_classes = {}
  filter_stats = {}
  filter_attribs = {}
  for i, _ in ipairs(races) do
    races[i].weight = 0
  end
  updateSelectedRace()
end
  

function updateSelectedRace()
  if races[raceIndex] ~= nil then
    raceSelected = raceIndex
    updateRaceText()
  end
  forceRedraw()
end

class_matrix = {  ["combat"] = 1, 
                        ["piloting"] = 2, 
                        ["engineering"] = 3, 
                        ["bounty hunting"] = 4, 
                        ["smuggling"] = 5, 
                        ["leadership"] = 6, 
                        ["espionage"] = 7, 
                        ["slicer"] = 8, 
                        ["medical"] = 9, 
                        ["science"] = 10 }
                        
matrix_class = { "combat", "piloting", "engineering", "bounty hunting", "smuggling", "leadership", "espionage", "slicer", "medical", "science" }
  matrix_stats = { "price", "dep", "str", "dex", "con", "int", "wis", "cha", "frc", "lck", "ac", "hp", "apponly", "erarestrict" }

function findRaceWeightValue(race, main, class_filter, stat_filter, attrib_filter)
  local num = 0
  if main~="" then -- picked a main class
    if #class_filter == 0 then -- no class filters, find average of all levels
      local sum = 0
      for a=1, #matrix_class do
        sum = sum + race.levels[main].levels[a]
      end
      num = num + sum / #matrix_class
    else -- we have class filters, add them up 
      local sum = 0
      for _, v in pairs(class_filter) do
        sum = sum + race.levels[main].levels[class_matrix[v]]
      end
      num = num + sum / #class_filter
    end
  else -- didn't pick a main class
    if #class_filter > 0 then -- we have class filters, add them up
      for _, class in pairs(matrix_class) do
        local sum = 0
        for _, filter in pairs(class_filter) do 
          sum = sum + race.levels[class].levels[class_matrix[filter]]
        end
        num = num + sum / #matrix_class / #class_filter
      end
    end
  end
  for _, v in pairs(stat_filter) do
    num = num + getRaceStat(race, v)
  end
  -- add a flat 1000 if this race has the desired attribute
  for _, v in pairs(attrib_filter) do
    for _, j in pairs(race.attribs) do
      if v==j.name then num = num + 1000 end
    end
  end
  race.weight = num
end


function getRaceStat(r, s)
  if r[s] ~= nil then
    if s=="price" or s=="dep" then -- normalize price and deposit to be in line with stats
      return -r[s]/100
    elseif s=="apponly" then -- convert apponly into a number
      return ((r[s]=="Yes" and -100) or 0)
    elseif s=="ac" then -- convert ac to positive and normalize
      return -r[s]/25
    elseif s=="hp" then -- normalize hp
      return r[s]/250
    else
      return r[s]
    end
  end
end

  function addRaceScanFirst(name, line, args)

  if currentRace.name ~= args[1] then
    ColourNote("red","","Mismatched race names detected ("..currentRace.name.."~="..args[1]..") aborting...")
    stopRaceScan()
    return
  end
  currentRace.str = tonumber(args[2])
  currentRace.dex = tonumber(args[3])
  currentRace.wis = tonumber(args[4])
  currentRace.int = tonumber(args[5])
  currentRace.con = tonumber(args[6])
  currentRace.cha = tonumber(args[7])
  currentRace.lck = tonumber(args[8])
  currentRace.hp =  tonumber(args[9])
  currentRace.ac =  tonumber(args[10])
  currentRace.frc = tonumber(args[11])
  currentRace.price = tonumber(args[12])
  currentRace.dep = tonumber(args[13])
  currentRace.apponly = Trim(args[14])
  EnableTriggerGroup("raceScanFirst", false)
  DeleteLines(1)
  startRaceScanLanguage()
end

function addRaceMainClass(name, line, args)
  currentRace.mainclass = args[1]
end

function startRaceScanLanguage(name, line, args)
  EnableTriggerGroup("raceScanLanguage", true)
end
function addRaceScanLanguage(name, line, args)
  currentRace.language = Trim(args[1])
  EnableTriggerGroup("raceScanLanguage", false)
  EnableTriggerGroup("raceScanColors", true)
  --DeleteLines(1)
end

  function addRaceScanColors(name, line, args)
    EnableTriggerGroup("raceScanColors", false)
    startSkinColors()
  end

function startSkinColors(name, line, args)
  skinColors = {}
  EnableTriggerGroup("SkinColors", true)
end

function addSkinColors(name, line, args)
  local color = {}
  local colorsFound = utils.split(args[0], " ")
  for i, v in ipairs(colorsFound) do
    if (v~='') then
      color.index = #skinColors
      color.name = v
      skinColors[#skinColors + 1] = color
      color = {}
    end
  end
end

function stopSkinColors(name, line, args)
  EnableTriggerGroup("SkinColors", false)
  currentRace.skincolors = copytable.deep(skinColors)
  startExtraAttribs()
end

function startExtraAttribs(name, line, args)
  extraAttribs = {}
  EnableTriggerGroup("ExtraAttribs", true)
end

function addExtraAttrib(name, line, args)
  local attrib = { name = Trim(args[1]), desc = Trim(args[2]) }
  extraAttribs[#extraAttribs + 1] = attrib
end
  

function stopExtraAttribs(name, line, args)
  EnableTriggerGroup("ExtraAttribs", false)
  currentRace.attribs = copytable.deep(extraAttribs)
  startRaceLevels()
end

function startRaceLevels(name, line, args)
  raceLevels = {}
  EnableTriggerGroup("RaceLevels", true)
end

function addRaceLevels(name, line, args)
  local levels = {}
  --levels.class = Trim(args[1])
  args[2] = string.gsub(Trim(args[2]), "   ", " ")
  levels.levels = utils.split(Trim(args[2]), " ")
  --raceLevels[#raceLevels + 1] = levels
  raceLevels[Trim(args[1])] = levels
  if Trim(args[1])=="science" then stopRaceLevels(name, line, args) end
end

function stopRaceLevels(name, line, args)
  EnableTriggerGroup("RaceLevels", false)
  currentRace.levels = copytable.deep(raceLevels)
  races[currentRaceIndex] = currentRace
  scanNextRace()
end

function stopRaceScan(name, line, args)
  EnableTriggerGroup("raceScanFirst", false)
  EnableTriggerGroup("SkinColors", false)
  EnableTriggerGroup("ExtraAttribs", false)
  EnableTriggerGroup("RaceLevels", false)
  EnableTrigger("gagAll", false)
end

function getRaceByIndex(index)
  for i, v in pairs(races) do
    if i==index then
      return v
    end
  end
  ColourNote("red","","Error, no race with that index ("..index..")")
  return
end

function beginScan(name, line, args)
end
function clearTable(name, line, args)
  races = {}
  text = {}
  config = default_config
  ColourNote("yellow","","Race list tables cleared.")
  OnPluginSaveState()
  SetUpHotspotsAndDraw(true)
end

function showWindow(name, line, args)
  visible = "true"
  scheduleRedraw()
  WindowShow(win, true)
  SetUpHotspotsAndDraw(false)
end
function hideWindow(name, line, args)
  visible = "false"
  WindowShow(win, false)
end

function setupWindow(name, line, args)


end


function drawWindow(name, line, args)
	WindowRectOp (win, miniwin.rect_fill, 0, 0, config.width, config.height, ColourNameToRGB(config.backcolor))  -- draw blank rectangle to "erase" window contents
  -- drag handler
  movewindow.add_drag_handler (win, 0, 0, config.width-30, titleHeight)		

	 -- draw border
  WindowRectOp (win, miniwin.rect_draw_edge, 0, 0, 0, 0, miniwin.rect_edge_etched, miniwin.rect_edge_at_all)
  WindowRectOp (win, miniwin.rect_frame, 1, titleHeight, config.split, config.height-1, ColourNameToRGB("white"))
	WindowRectOp (win, miniwin.rect_frame, config.split+1, titleHeight, config.width-1, config.height-1, ColourNameToRGB("white"))

  printBrowseList()
    
  drawText()
  drawLines()
  drawPolys()
  
  -- draw scrollbars
  drawScrollbars()
    
    
  -- draw X in the corner to close the window
  --WindowRectOp(win, 5, config.width-15, 1, config.width, titleHeight, 5, 15+ 0x0800)
  WindowLine (win, config.width-15, 5, config.width-5, 15, ColourNameToRGB ("white"), miniwin.pen_solid, 1)
  WindowLine (win, config.width-15, 15, config.width-5, 5, ColourNameToRGB ("white"), miniwin.pen_solid, 1)
  WindowAddHotspot(win, "windowX", 
        config.width-15, 5, config.width-5, 15,
  			"",                   --mousehover
  			"",                   --mouseoffhover
  			"destroyWindow",      --mousedown
  			"CancelMouseDown",                   --mouseoffdown
  			"LeftClickOnly",                   --mouseup
  			"Close race browser window",
  			1, 0)
  -- heading line
 	WindowText (win, font, "LotJ Race Browser v"..VERSION, 3, 3, 0, 0, ColourNameToRGB  "white")
  drawRefreshButton()
  drawAlphaButton()
  drawResizer(win, config.width, config.height)
  WindowShow (win,  true)
end

function drawRefreshButton()
  local display = ""
  if races.scantime then
    local daysold = tonumber(string.format("%1.0f", os.difftime(os.time(), tonumber(races.scantime))/86400))
    display = "Race data is "..((daysold>0 and daysold.." day"..((daysold>1 and "s")or "").." old") or "current")
  else
    display = "No race data"
  end
  WindowText(win, font, display, config.width-WindowTextWidth(win, font, display)-40, 3, 0, 0, ColourNameToRGB("white"))

  WindowAddHotspot(win, "refreshbutton", config.width-30, 1, config.width-15, titleHeight, "", "", "startRacelistScan", "", "", "Update race data", 1, 0)
  points = string.format("%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i", config.width-23, titleHeight-12, config.width-19, titleHeight-8, config.width-21,titleHeight-8,config.width-21, titleHeight-3,config.width-25, titleHeight-3,config.width-25,titleHeight-8,config.width-27, titleHeight-8)
  WindowPolygon(win, points, ColourNameToRGB("white"), 0, 1, ColourNameToRGB("white"), 0, true, false)
  

end

function drawAlphaButton()
  local versionWidth = WindowTextWidth(win, font, "LotJ Race Browser v"..VERSION)
  local sortXOffset = 50
  local sortButtonSize = WindowTextWidth(win, font, "aA")
  WindowText(win, font, "aA", versionWidth + sortXOffset, 3, 0, 0, ColourNameToRGB("white"))
  WindowAddHotspot(win, "alphaSortButton", versionWidth + sortXOffset, 3, versionWidth + sortXOffset + sortButtonSize, titleHeight, "", "", "sortByAlpha", "", "", "Sort races alphabetically", 1, 0)
  WindowRectOp(win, miniwin.rect_draw_edge, versionWidth + sortXOffset-2, 1, versionWidth + sortXOffset + sortButtonSize+2, titleHeight, miniwin.rect_edge_etched, miniwin.rect_edge_at_all)
end

function drawScrollbars(name, line, args)

   -- left Scrollbar base
   WindowRectOp(win, 2, config.split-2-SCROLL_BAR_WIDTH, titleHeight, config.split-2, config.height-2, SCROLL_BACKGROUND_COLOUR) -- scroll bar background
   WindowRectOp(win, 1, config.split-2-SCROLL_BAR_WIDTH+1, SCROLL_BAR_WIDTH+titleHeight+1, config.split-2-1, config.height-SCROLL_BAR_WIDTH-1, SCROLL_DETAIL_COLOUR) -- scroll bar background inset rectangle
   
   -- right Scrollbar base
   WindowRectOp(win, 2, config.width-SCROLL_BAR_WIDTH, titleHeight, config.width, -SCROLL_BAR_WIDTH, SCROLL_BACKGROUND_COLOUR) -- scroll bar background
   WindowRectOp(win, 1, config.width-SCROLL_BAR_WIDTH+1, SCROLL_BAR_WIDTH+titleHeight+1, config.width-1, config.height-(2*SCROLL_BAR_WIDTH)-1, SCROLL_DETAIL_COLOUR) -- scroll bar background inset rectangle

   
   -- draw right scrollbar up and down arrows

   if (keepscrolling == "rightup") then
      -- draw top scroll button pressed
      WindowRectOp(win, 5, (config.width-SCROLL_BAR_WIDTH), titleHeight, 0, titleHeight+SCROLL_BAR_WIDTH, 10,  15 + 0x800) -- up arrow pushed
      points = string.format("%i,%i,%i,%i,%i,%i", (config.width-SCROLL_BAR_WIDTH)+3, titleHeight+9,(config.width-SCROLL_BAR_WIDTH)+7, titleHeight+5,(config.width-SCROLL_BAR_WIDTH)+11, titleHeight+9)
      WindowPolygon(win, points,
         0x000000, 0, 1, -- pen (solid, width 1)
         0x000000, 0, -- brush (solid)
         true, -- close
         false) -- alt fill
   else
      -- draw top scroll button unpressed
      WindowRectOp(win, 5, (config.width-SCROLL_BAR_WIDTH), titleHeight, config.width, titleHeight+SCROLL_BAR_WIDTH, 5, 15 + 0x800)
      points = string.format("%i,%i,%i,%i,%i,%i", (config.width-SCROLL_BAR_WIDTH)+3, titleHeight+9,(config.width-SCROLL_BAR_WIDTH)+7, titleHeight+5,(config.width-SCROLL_BAR_WIDTH)+11, titleHeight+9)
      WindowPolygon(win, points,
         0x000000, 0, 1,   -- pen (solid, width 1)
         0x000000, 0, --brush (solid)
         true, --close
         false)  --alt fill
   end
    
   if (keepscrolling == "rightdown") then
      -- draw bottom scroll button pressed
      WindowRectOp(win, 5, (config.width-SCROLL_BAR_WIDTH), config.height-(SCROLL_BAR_WIDTH*2), 0, config.height-SCROLL_BAR_WIDTH-1, 10,  15 + 0x800) 
      points = string.format("%i,%i,%i,%i,%i,%i", (config.width-SCROLL_BAR_WIDTH)+3, (config.height-SCROLL_BAR_WIDTH)-11,(config.width-SCROLL_BAR_WIDTH)+7, (config.height-SCROLL_BAR_WIDTH)-7, (config.width-SCROLL_BAR_WIDTH)+11,(config.height-SCROLL_BAR_WIDTH)-11)
      WindowPolygon(win, points,
         0x000000, 0, 1, -- pen (solid, width 1)
         0x000000, 0, -- brush (solid)
         true, -- close
         false) -- alt fill
   else
      -- draw bottom scroll button unpressed
      WindowRectOp(win, 5, (config.width-SCROLL_BAR_WIDTH), config.height-(SCROLL_BAR_WIDTH*2), config.width, config.height-SCROLL_BAR_WIDTH, 5,  15 + 0x800)
      points = string.format("%i,%i,%i,%i,%i,%i", (config.width-SCROLL_BAR_WIDTH)+3, (config.height-SCROLL_BAR_WIDTH)-11,(config.width-SCROLL_BAR_WIDTH)+7, (config.height-SCROLL_BAR_WIDTH)-7, (config.width-SCROLL_BAR_WIDTH)+11,(config.height-SCROLL_BAR_WIDTH)-11)
      WindowPolygon(win, points,
         0x000000, 0, 1,   -- pen (solid, width 1)
         0x000000, 0, --brush (solid)
         true, --close
         false) --alt fill
   end
   
      -- draw left scrollbar up and down arrows

   if (keepscrolling == "leftup") then
      -- draw top scroll button pressed
      WindowRectOp(win, 5, (config.split-SCROLL_BAR_WIDTH-2), titleHeight, config.split-2, titleHeight+SCROLL_BAR_WIDTH, 10,  15 + 0x800) -- up arrow pushed
      points = string.format("%i,%i,%i,%i,%i,%i", (config.split-SCROLL_BAR_WIDTH-2)+3, titleHeight+9,(config.split-SCROLL_BAR_WIDTH-2)+7, titleHeight+5,(config.split-SCROLL_BAR_WIDTH-2)+11, titleHeight+9)
      WindowPolygon(win, points,
         0x000000, 0, 1, -- pen (solid, width 1)
         0x000000, 0, -- brush (solid)
         true, -- close
         false) -- alt fill
   else
      -- draw top scroll button unpressed
      WindowRectOp(win, 5, (config.split-SCROLL_BAR_WIDTH-2), titleHeight, config.split-2, titleHeight+SCROLL_BAR_WIDTH, 5, 15 + 0x800)
      points = string.format("%i,%i,%i,%i,%i,%i", (config.split-SCROLL_BAR_WIDTH-2)+3, titleHeight+9,(config.split-SCROLL_BAR_WIDTH-2)+7, titleHeight+5,(config.split-SCROLL_BAR_WIDTH-2)+11, titleHeight+9)
      WindowPolygon(win, points,
         0x000000, 0, 1,   -- pen (solid, width 1)
         0x000000, 0, --brush (solid)
         true, --close
         false)  --alt fill
   end
    
   if (keepscrolling == "leftdown") then
      -- draw bottom scroll button pressed
      WindowRectOp(win, 5, (config.split-SCROLL_BAR_WIDTH-2), config.height-SCROLL_BAR_WIDTH, config.split-2, config.height-1, 10,  15 + 0x800) 
      points = string.format("%i,%i,%i,%i,%i,%i", (config.split-SCROLL_BAR_WIDTH-2)+3, config.height-11,(config.split-SCROLL_BAR_WIDTH-2)+7, config.height-7, (config.split-SCROLL_BAR_WIDTH-2)+11,config.height-11)
      WindowPolygon(win, points,
         0x000000, 0, 1, -- pen (solid, width 1)
         0x000000, 0, -- brush (solid)
         true, -- close
         false) -- alt fill
   else
      -- draw bottom scroll button unpressed
      WindowRectOp(win, 5, (config.split-SCROLL_BAR_WIDTH-2), config.height-SCROLL_BAR_WIDTH, config.split-2, config.height, 5,  15 + 0x800)
      points = string.format("%i,%i,%i,%i,%i,%i", (config.split-SCROLL_BAR_WIDTH-2)+3, config.height-11,(config.split-SCROLL_BAR_WIDTH-2)+7, config.height-7, (config.split-SCROLL_BAR_WIDTH-2)+11,config.height-11)
      WindowPolygon(win, points,
         0x000000, 0, 1,   -- pen (solid, width 1)
         0x000000, 0, --brush (solid)
         true, --close
         false) --alt fill
   end
   
   
    -- determine left scrollbar position indicator

    totalSteps = #races
    if (totalSteps <= racesFit-1) then
       totalSteps = 1
    end
    SCROLL_BAR_HEIGHT = (config.height-(2*SCROLL_BAR_WIDTH)-titleHeight)
    if (not dragscrolling) then
      stepNum = raceDisplayedStart-1
      barPos = SCROLL_BAR_WIDTH + titleHeight + ((SCROLL_BAR_HEIGHT/totalSteps) * stepNum)
      barSize = (SCROLL_BAR_HEIGHT/math.max(racesFit-1,totalSteps)) * (racesFit-1)
      if barSize < 10 then
        barSize = 10
      end
      if barPos+barSize > SCROLL_BAR_WIDTH+titleHeight+SCROLL_BAR_HEIGHT then
        barPos = SCROLL_BAR_WIDTH+titleHeight+SCROLL_BAR_HEIGHT - barSize
      end
      WindowAddHotspot(win, "leftscroller", (config.split-SCROLL_BAR_WIDTH-2), barPos, config.split-2, barPos+barSize, "MouseOver", "CancelMouseOver", "MouseDown", "CancelMouseDown", "MouseUp", "", 1, 0)
      WindowDragHandler(win, "leftscroller", "ScrollerMoveCallback", "ScrollerReleaseCallback", 0)
    
    end
    WindowRectOp(win, 5, (config.split-SCROLL_BAR_WIDTH-2), barPos, config.split-2, barPos+barSize, 5, 15 + 0x800) -- scrollbar position indicator
    
    
   -- determine right scrollbar position indicator
   totalSteps2 = #text
   if (totalSteps2 <= textFit-1) then
      totalSteps2 = 1 
   end
   SCROLL_BAR_HEIGHT2 = (config.height-(3*SCROLL_BAR_WIDTH)-titleHeight)
   if (not dragscrolling) then
      stepNum2 = textStart-1
      barPos2 = SCROLL_BAR_WIDTH +titleHeight+ ((SCROLL_BAR_HEIGHT2/totalSteps2) * stepNum2)
      barSize2 = (SCROLL_BAR_HEIGHT2/math.max(textFit-1,totalSteps2)) * (textFit-1)
      if barSize2 < 10 then
         barSize2 = 10
      end
      if barPos2+barSize2 > SCROLL_BAR_WIDTH+titleHeight+SCROLL_BAR_HEIGHT2 then
         barPos2 = SCROLL_BAR_WIDTH+titleHeight+SCROLL_BAR_HEIGHT2 - barSize2
      end
      WindowAddHotspot(win, "rightscroller", (config.width-SCROLL_BAR_WIDTH), barPos2, config.width, barPos2+barSize2, "MouseOver", "CancelMouseOver", "MouseDown", "CancelMouseDown", "MouseUp", "", 1, 0)
      WindowDragHandler(win, "rightscroller", "ScrollerMoveCallback", "ScrollerReleaseCallback", 0)
   end
   WindowRectOp(win, 5, (config.width-SCROLL_BAR_WIDTH), barPos2, config.width, barPos2+barSize2, 5, 15 + 0x800) -- scrollbar position indicator
    
end

function destroyWindow(name, list, args)
	WindowShow (win, false)
	visible = "false"
end

function scheduleRedraw()
	if not redraw_scheduled then
		redraw_scheduled = true
		DoAfterSpecial(0.1, 'drawWindows()', sendto.script)
	end
end

function forceRedraw()
  if not redraw_scheduled then
    redraw_scheduled = true
    drawWindows()
  end
end

function wheel_move (flags, hotspot_id)
  if hotspot_id == "leftbackground" then
    if bit.band(flags, 0x100) ~= 0 then
      if raceDisplayedStart < #races-racesFit+2 then
        -- down
        raceDisplayedStart = math.max(1, math.min(#races-racesFit+2, raceDisplayedStart+3))
        raceDisplayedEnd = math.min(#races, raceDisplayedStart+racesFit-2)    
        forceRedraw()
      end
    elseif raceDisplayedStart > 1 then
      -- up
      raceDisplayedStart = math.max(1, raceDisplayedStart-3)
      raceDisplayedEnd = math.min(#races, raceDisplayedStart+racesFit-2)
      forceRedraw()
    end
  elseif hotspot_id == "rightbackground" then
    if bit.band(flags, 0x100) ~= 0 then
      if textStart < #text-textFit+2 then
        -- down
        textStart = math.max(1, math.min(#text-textFit+2, textStart+3))
        textEnd = math.min(#text, textStart+textFit-2)    
        forceRedraw()
      end
    elseif textStart > 1 then
      -- up
      textStart = math.max(1, textStart-3)
      textEnd = math.min(#text, textStart+textFit-2)
      forceRedraw()
    end

  end
end -- wheel_move


function ScrollerMoveCallback(flags, hotspot_id)
  mouseposy = WindowInfo(win, 18)
  windowtop = WindowInfo(win, 2)
  if hotspot_id == "leftscroller" then
    barPos = math.max(mouseposy-windowtop+clickdelta, SCROLL_BAR_WIDTH+titleHeight)
    if barPos > config.height-(SCROLL_BAR_WIDTH)-barSize then
      barPos = config.height-(SCROLL_BAR_WIDTH)-barSize
      raceDisplayedStart = math.max(1,#races-racesFit+2)
      raceDisplayedEnd = #races
    else
      raceDisplayedStart = math.max(1,math.floor((barPos-SCROLL_BAR_WIDTH-titleHeight)/(SCROLL_BAR_HEIGHT/totalSteps)+1))
      raceDisplayedEnd = math.min(raceDisplayedStart + racesFit-2, #races)
    end
  elseif hotspot_id == "rightscroller" then
    barPos2 = math.max(mouseposy-windowtop+clickdelta, SCROLL_BAR_WIDTH+titleHeight)
    if barPos2 > config.height-(SCROLL_BAR_WIDTH*2)-barSize2 then
      barPos2 = config.height-(SCROLL_BAR_WIDTH*2)-barSize2
      textStart = math.max(1,#text-textFit+2)
      textEnd = #text
    else
      textStart = math.max(1,math.floor((barPos2-SCROLL_BAR_WIDTH-titleHeight)/(SCROLL_BAR_HEIGHT/totalSteps2)+1))
      textEnd = math.min(#text, textStart+textFit-2)
    end
  end
  scheduleRedraw()
end

function ScrollerReleaseCallback(flags, hotspot_id)
  dragscrolling = false
  scheduleRedraw()
end

----------------------------------------------------------------------
-- Called as resizer is dragged.
----------------------------------------------------------------------
function ResizeMoveCallback(flags, hotspot_id)
   posx, posy = WindowInfo (win, 17), WindowInfo (win, 18)
   config.width = config.width + posx - startposx
   startposx = posx
   if (config.width < MIN_WIDTH) then
      config.width = MIN_WIDTH
      startposx = windowinfo.window_left+config.width
   elseif (windowinfo.window_left+config.width > GetInfo(281)) then
      config.width = GetInfo(281)-windowinfo.window_left
      startposx = GetInfo(281)
   end
   
   config.height = config.height + posy - startposy
   startposy = posy
   if (config.height < MIN_HEIGHT) then
   	config.height = MIN_HEIGHT
   	startposy = windowinfo.window_top+config.height
   elseif (windowinfo.window_top+config.height > GetInfo(280)) then
   	config.height = GetInfo(280)-windowinfo.window_top
   	startposy = GetInfo(280)
   end
   
   
	if (utils.timer() - lastRefresh > 0.0333) then
		SetUpHotspotsAndDraw(false)
		lastRefresh = utils.timer()
	end
end
---------------------------------------------------------------------------------
-- Called after the resize widget is released.
---------------------------------------------------------------------------------
function ResizeReleaseCallback ()
  config.height = titleHeight+(raceLineHeight*(racesFit-1))+3 -- snap height down to not have dead space after last line
  SetUpHotspotsAndDraw(false) -- true here causes old lines to re-wrap at the new size
end
---------------------------------------------------------------------------------
-- Called as window split is being dragged.
---------------------------------------------------------------------------------
function SplitMoveCallback(flags, hotspot_id)
  posx = WindowInfo(win, 17)
  config.split = config.split + posx - startposx
  startposx = posx
  if (config.split < MIN_SPLIT) then
    config.split = MIN_SPLIT
    startposx = windowinfo.window_left+config.split
  elseif (windowinfo.window_left+config.split > GetInfo(281)) then -- prevent moving split off right edge of screen
    config.split = GetInfo(281)-windowinfo.window_left
    startposx = GetInfo(281)
  end
  
  if (utils.timer() - lastRefresh > 0.0333) then
		SetUpHotspotsAndDraw(false)
		lastRefresh = utils.timer()
	end
end
---------------------------------------------------------------------------------
-- Called after window split is released.
---------------------------------------------------------------------------------
function SplitReleaseCallback()
  SetUpHotspotsAndDraw(false)
end
---------------------------------------------------------------------------------
-- Called when mouse button is pressed on hotspot.
---------------------------------------------------------------------------------
function MouseDown(flags, hotspot_id)
  if (hotspot_id == "resize" or hotspot_id == "splitmove") then
    startposx, startposy = WindowInfo (win, 17), WindowInfo (win, 18)
  elseif (hotspot_id == "leftscroller") then
    clickdelta = WindowHotspotInfo(win, "leftscroller", 2)-WindowInfo (win, 15)
    dragscrolling = true
  elseif (hotspot_id == "rightscroller") then
    clickdelta = WindowHotspotInfo(win, "rightscroller", 2)-WindowInfo (win, 15)
    dragscrolling = true
  elseif (hotspot_id == "leftup" or hotspot_id == "leftdown") then
    keepscrolling = hotspot_id
    scrollbar()
  elseif (hotspot_id == "rightup" or hotspot_id == "rightdown") then
    keepscrolling = hotspot_id
    scrollbar2()
  elseif (hotspot_id == "leftbackground") then
    raceClick()
  end
end
---------------------------------------------------------------------------------
-- Called when mouse moved away from hotspot. Doesn't really apply for draggables.
---------------------------------------------------------------------------------
function CancelMouseDown(flags, hotspot_id)
  keepscrolling = ""
  scheduleRedraw()
end
---------------------------------------------------------------------------------
-- Called when mouse button released on hotspot.
---------------------------------------------------------------------------------
function MouseUp(flags, hotspot_id, win)
   if bit.band (flags, miniwin.hotspot_got_rh_mouse) ~= 0 then
      right_click_menu()
   end
   keepscrolling = ""
   return true
end
function LeftClickOnly(flags, hotspot_id, win)
	if bit.band (flags, miniwin.hotspot_got_rh_mouse) ~= 0 then
    return true
	end
	return false
end

function right_click_menu(hotspot_id)

  local menu ="!"
  menu = menu .."^Race Sorting|>Apply main class filter|"

  for _, v in ipairs(matrix_class) do
    menu = menu..((filter_main_class==v and "+") or "")..v.."|"
  end
  menu = menu.."<|>Apply level filters|"
  for _, v in ipairs(matrix_class) do
    local found = false
    for _, j in pairs(filter_classes) do
      if j==v then -- class belongs to sorting filter
        found = true
      end
    end
    menu = menu..((found and "+") or "")..v.."|"
  end
  menu = menu.."<|>Apply stat filters|"
  for _, v in ipairs(matrix_stats) do
    local found = false
      for _, j in pairs(filter_stats) do
        if j==v then -- stat belongs to sorting filter
          found = true
        end
      end
    menu = menu..((found and "+") or "")..v.."|"
  end
  -- add filtering for racial attributes
  menu = menu.."<|>Apply racial attrib filters|"
  for _, v in ipairs(attribs) do
    local found = false
      for _, j in pairs(filter_attribs) do
        if j==v then -- attrib belongs to sorting filter
          found = true
        end
      end
    menu = menu..((found and "+") or "")..v.."|"
  end
  -- add static menu options at the end
  menu = menu .. "<|Sort alphabetically|Clear filters"

  local result = tonumber(WindowMenu (win,
    tonumber(WindowInfo (win, 14)) or 0,  -- x position
    tonumber(WindowInfo (win, 15)) or 0,   -- y position
    menu))


  if result~=nil then
    if result > 0 and result <= #matrix_class then -- chose a main class
      if filter_main_class==matrix_class[result] then -- remove main class choice
        filter_main_class = ""
      else
        filter_main_class = matrix_class[result]
      end
    elseif result > #matrix_class and result <= #matrix_class*2 then -- chose a level filter
      local choice = matrix_class[result-#matrix_class]
      local found = 0
      for i, v in ipairs(filter_classes) do
        if v==choice then -- choice already in filter, remove it
          found = i
        end
      end
      if found>0 then
        table.remove(filter_classes, found)
      else
        filter_classes[#filter_classes + 1] = choice
      end
    elseif result > #matrix_class*2 and result <= #matrix_class*2+#matrix_stats then -- chose a stat filter
      local choice = matrix_stats[result-#matrix_class*2]
      local found = 0
      for i, v in ipairs(filter_stats) do
        if v==choice then -- choice already in filter, remove it
          found = i
        end
      end
      if found>0 then
        table.remove(filter_stats, found)
      else
        filter_stats[#filter_stats + 1] = choice
      end
    elseif result > #matrix_class*2+#matrix_stats and result <= #matrix_class*2+#matrix_stats+#attribs then -- chose an attribute
      local choice = attribs[result-(#matrix_class*2+#matrix_stats)]
      local found = 0
      for i, v in ipairs(filter_attribs) do
        if v==choice then -- choice already in filter, remove it
          found = i
        end
      end
      if found>0 then
        table.remove(filter_attribs, found)
      else
        filter_attribs[#filter_attribs + 1] = choice
      end
    elseif result == #matrix_class*2+#matrix_stats+#attribs+1 then -- chose alpha sort
      sortByAlpha()
      return
    elseif result == #matrix_class*2+#matrix_stats+#attribs+2 then -- chose clear filters
      clearFilters()
      return
    end
    sortByFilter(filter_main_class, filter_classes, filter_stats, filter_attribs)
  end

end

keepscrolling = ""
require "wait"

function scrollbar()
   wait.make(
   function()
      while keepscrolling == "leftup" or keepscrolling == "leftdown" do
         if keepscrolling == "leftup" then
            if (raceDisplayedStart > 1) then
               raceDisplayedStart = raceDisplayedStart - 1
               raceDisplayedEnd = raceDisplayedEnd - 1
            else
                 keepscrolling = ""
            end
         elseif keepscrolling == "leftdown" then
            if (raceDisplayedEnd < #races) then
               raceDisplayedStart = raceDisplayedStart + 1
               raceDisplayedEnd = raceDisplayedEnd + 1
            else
               keepscrolling = ""
            end
         end
         wait.time(0.1)
         forceRedraw()
      end
   end
   )
end

function scrollbar2()
   wait.make(
   function()
      while keepscrolling == "rightup" or keepscrolling == "rightdown" do
         if keepscrolling == "rightup" then
            if (textStart > 1) then
               textStart = textStart - 1
               textEnd = textEnd - 1
            else
                 keepscrolling = ""
            end
         elseif keepscrolling == "rightdown" then
            if (textEnd < #text) then
               textStart = textStart + 1
               textEnd = textEnd + 1
            else
               keepscrolling = ""
            end
         end
         wait.time(0.1)
         forceRedraw()
      end
   end
   )
end

function OnPluginInstall () 	
  -- get default config
  if not config then
    config = default_config
  end
  
  --- Setup the windows
  SetUpHotspotsAndDraw(true)  
    
end -- OnPluginInstall
--================================================================================
-- Called by OnPluginInstall, but also by redraw routine to refresh the screen
-- and (if the first time) add the resizer tag, otherwise move the resizer relative
-- to the main window.
--=================================================================================
function SetUpHotspotsAndDraw(firstTime)
	if (firstTime) then
    
		WindowCreate (win, 0, 0, config.width, config.height, miniwin.pos_center_all, 0, ColourNameToRGB("black")) -- create window
		windowinfo = movewindow.install (win, 6) -- default to 6 (on top right)
		check(WindowFont (win, font, font_name, font_size, false, false, false, false))
    -- spacing stuff
    titleHeight = WindowFontInfo(win, font, 1)+4
    raceLineHeight = WindowFontInfo(win, font, 1)+spacer
    textLineHeight = WindowFontInfo(win, font, 1)+1
    
		WindowAddHotspot (win, "resize", config.width-RESIZE_TAG_SIZE, config.height-RESIZE_TAG_SIZE, config.width, config.height, "MouseOver", "CancelMouseOver", "MouseDown", "CancelMouseDown", "MouseUp", "", 6, 0)
		WindowDragHandler(win, "resize", "ResizeMoveCallback", "ResizeReleaseCallback", 0)
    WindowAddHotspot (win, "splitmove", config.split-1, titleHeight, config.split+1, config.height-1, "MouseOver", "CancelMouseOver", "MouseDown", "CancelMouseDown", "MouseUp", "", 8, 0)
    WindowDragHandler(win, "splitmove", "SplitMoveCallback", "SplitReleaseCallback", 0)
    -- make background hotspots for scrolling
    WindowAddHotspot (win, "leftbackground", 2, titleHeight, config.split-SCROLL_BAR_WIDTH-2, config.height-2, "MouseOver", "CancelMouseOver", "MouseDown", "CancelMouseDown", "MouseUp", "",0, 0)
    WindowScrollwheelHandler(win, "leftbackground", "wheel_move")
    -- left scroll bar up/down buttons
    WindowAddHotspot(win, "leftup", config.split-1-SCROLL_BAR_WIDTH, titleHeight, config.split-1, titleHeight+SCROLL_BAR_WIDTH, "MouseOver", "CancelMouseOver", "MouseDown", "CancelMouseDown", "MouseUp", "", 1, 0)
    WindowAddHotspot(win, "leftdown", config.split-1-SCROLL_BAR_WIDTH, config.height-SCROLL_BAR_WIDTH, config.split-1, config.height, "MouseOver", "CancelMouseOver", "MouseDown", "CancelMouseDown", "MouseUp", "", 1, 0)

    WindowAddHotspot (win, "rightbackground", config.split+2, titleHeight, config.width-SCROLL_BAR_WIDTH-2, config.height-2, "MouseOver", "CancelMouseOver", "MouseDown", "CancelMouseDown", "MouseUp", "",0, 0)    
    WindowScrollwheelHandler(win, "rightbackground", "wheel_move")
    -- right scroll bar up/down buttons
    WindowAddHotspot(win, "rightup", config.width-SCROLL_BAR_WIDTH, titleHeight, config.width-2, titleHeight+SCROLL_BAR_WIDTH, "MouseOver", "CancelMouseOver", "MouseDown", "CancelMouseDown", "MouseUp", "", 1, 0)
    WindowAddHotspot(win, "rightdown", config.width-SCROLL_BAR_WIDTH, config.height-(2*SCROLL_BAR_WIDTH), config.width-2, config.height-SCROLL_BAR_WIDTH, "MouseOver", "CancelMouseOver", "MouseDown", "CancelMouseDown", "MouseUp", "", 1, 0)

	else -- not our first time drawing
		-- everything has already been made
		-- just move them back into place
		WindowResize(win, config.width, config.height, 0x000000)
		WindowMoveHotspot(win, "resize", config.width-RESIZE_TAG_SIZE, config.height-RESIZE_TAG_SIZE, config.width, config.height)
    WindowMoveHotspot(win, "splitmove", config.split-1, WindowFontInfo(win, font, 1)+4, config.split+1, config.height-1)
    
    WindowMoveHotspot(win, "leftbackground", 2, WindowFontInfo(win, font, 1)+4, config.split-SCROLL_BAR_WIDTH-2, config.height-2)
    WindowMoveHotspot(win, "rightbackground", config.split+2, titleHeight, config.width-SCROLL_BAR_WIDTH-2, config.height-2)
    WindowMoveHotspot(win, "leftup",config.split-1-SCROLL_BAR_WIDTH, titleHeight, config.split-1, titleHeight+SCROLL_BAR_WIDTH)
    WindowMoveHotspot(win, "leftdown",config.split-1-SCROLL_BAR_WIDTH, config.height-SCROLL_BAR_WIDTH, config.split-1, config.height)
    WindowMoveHotspot(win, "rightup",config.width-SCROLL_BAR_WIDTH, titleHeight, config.width-2, titleHeight+SCROLL_BAR_WIDTH)
    WindowMoveHotspot(win, "rightdown",config.width-SCROLL_BAR_WIDTH, config.height-(2*SCROLL_BAR_WIDTH), config.width-2, config.height-SCROLL_BAR_WIDTH)
	end
  
  -- left window
  racesFit = math.ceil((config.height-titleHeight)/raceLineHeight)
  
  raceDisplayedStart = 1
  raceDisplayedEnd = math.min(racesFit, #races)
  -- right window
  textFit = math.ceil((config.height-titleHeight)/textLineHeight)
  
  textStart = 1
  textEnd = math.min(#text, textFit)
    
  redraw_scheduled = true
  drawWindows()
end


function drawWindows()
	if not redraw_scheduled then
		return
  end
  if visible == "true" then
    redraw_scheduled = false
    drawWindow()
  end
end
function drawResizer(window, winwidth, winheight)
   -- draw the resize widget bottom right corner.
   WindowRectOp(win, 2, winwidth-SCROLL_BAR_WIDTH, winheight-SCROLL_BAR_WIDTH, 0, 0, SCROLL_BACKGROUND_COLOUR) -- resizer background
   WindowLine(window, winwidth-3, winheight-2, winwidth-2, winheight-3, 0xffffff, 0, 2)
   WindowLine(window, winwidth-4, winheight-2, winwidth-2, winheight-4, 0x696969, 0, 1)
   WindowLine(window, winwidth-6, winheight-2, winwidth-2, winheight-6, 0xffffff, 0, 2)
   WindowLine(window, winwidth-7, winheight-2, winwidth-2, winheight-7, 0x696969, 0, 1)
   WindowLine(window, winwidth-9, winheight-2, winwidth-2, winheight-9, 0xffffff, 0, 2)
   WindowLine(window, winwidth-10, winheight-2, winwidth-2, winheight-10, 0x696969, 0, 1)
   WindowLine(window, winwidth-12, winheight-2, winwidth-2, winheight-12, 0xffffff, 0, 2)
   WindowLine(window, winwidth-13, winheight-2, winwidth-2, winheight-13, 0x696969, 0, 1)
end

function OnPluginSaveState ()
  movewindow.save_state (win)
  SetVariable("config", serialize.save("config"))
  SetVariable("races", serialize.save("races"))
  SetVariable("attribs", serialize.save("attribs"))
  SetVariable("visible", visible)
end -- function OnPluginSaveState

function OnPluginDisable()
  WindowShow(win, false)
end

  ]]> 
  </script>
  </muclient>
 
